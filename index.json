[{"content":"Unicodeä¸°å¯Œäº†æ—¥å¸¸ä½¿ç”¨çš„å­—ç¬¦é›†, è®©æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ä¸€ç§ç®€å•ä¾¿æ·çš„æ–¹å¼è¡¨è¾¾å„ç§å¥‡æ€ªçš„å­—ç¬¦, æ¯”å¦‚æƒ³è¦åœ¨è¾“å…¥ä¸€ä¸ªé›ªäººSnowman, U+2603\nâ˜ƒ latexä½œä¸ºæ—¥å¸¸ä½¿ç”¨çš„æ’ç‰ˆå·¥å…·, æ€ä¹ˆåœ¨latexä¸­æ’å…¥ä¸€ä¸ªunicode? ä¸€èˆ¬æ¥è®², åº”è¯¥Ctrl+C, Ctrl+Vå°±å¯ä»¥, æˆ‘ä»¬æ¥çœ‹çœ‹ä¸‹é¢çš„ä»£ç \n\\documentclass[utf8]{article} \\begin{document} \\huge Unicode char \\texttt{U+13105} is ğ“„… Unicode char \\texttt{U+16E4} is á›¤ Unicode char \\texttt{U+25E6} is â—¦ \\end{document} ç„¶è€Œè¾“å‡ºçš„PDFä¸­å¹¶æ²¡æœ‰åŒ…å«æ‰€æœ‰çš„Unicodeå­—ç¬¦, çœ‹èµ·æ¥è¿™ä¸ªé—®é¢˜è¿˜å­˜åœ¨ä¸€å®šçš„å…±æ€§unicode-characters-not-displaying-in-xetex, è€Œä¸”ä¼¼ä¹æ˜¯ä¸ªå­—ä½“é—®é¢˜.\nTex Engineä½¿ç”¨xelatex\næˆ‘ä»¬æ¥è¯•è¯•æ›´æ¢ä¸ºFreeMonoå­—ä½“\n\\documentclass[utf8]{article} \\usepackage{fontspec} \\setmainfont{FreeMono} \\begin{document} \\huge Unicode char \\texttt{U+13105} is ğ“„… Unicode char \\texttt{U+16E4} is á›¤ Unicode char \\texttt{U+25E6} is â—¦ \\end{document} Ha!ç°åœ¨á›¤å·²ç»å¯ä»¥æ­£å¸¸æ˜¾ç¤ºäº†, ğ“„…å´å˜æˆäº†ä¸€ä¸ªå¥‡æ€ªå­—ç¬¦. å…¶å®è¿™æ˜¯å› ä¸ºåœ¨FreeMonoå­—ä½“ä¸­ç¼ºå¤±å­—ç¬¦ğ“„…, è€Œá›¤ä¹‹æ‰€ä»¥èƒ½æ˜¾ç¤ºæ˜¯å› ä¸ºFreeMonoåŒ…å«äº†è¿™ä¸ªå­—ç¬¦.\nå› æ­¤æˆ‘ä»¬å¯ä»¥å‘ç°, åœ¨xelatexä¸­ä½¿ç”¨Unicode, éœ€è¦ä½¿ç”¨æ­£ç¡®çš„å­—ä½“, å³å­—ä½“ä¸­è¦åŒ…å«åº”ç›¸åº”çš„unicodeå­—ç¬¦.\né‚£æ–°çš„é—®é¢˜æ¥äº†, æ€ä¹ˆçŸ¥é“ä»€ä¹ˆå­—ä½“åŒ…å«äº†ğ“„…? é€›äº†ä¸€åœˆstackoverflowå‘ç°fileformat.infoå¯ä»¥è§£å†³è¿™ä¸ªé—®é¢˜.\nğ“„…å…¶å®åœ¨Egyptian Hieroglyphsä¸­, æ‰¾åˆ°ç›¸åº”çš„å­—ä½“Noto Sans Egyptian Hieroglyphs\næœ€åä¸€æ­¥, æˆ‘ä»¬è¦åŠ å…¥ç¼ºå¤±çš„å­—ç¬¦, å¹¶ä¸ºğ“„…æŒ‡å®šæ­£ç¡®çš„å­—ä½“\n\\usepackage{newunicodechar} \\newfontfamily{\\substitutett}{Noto Sans Egyptian Hieroglyphs} \\newunicodechar{ğ“„…}{{\\substitutett ğ“„…}} æœ€ç»ˆå°±å¯ä»¥æ­£å¸¸æ˜¾ç¤ºæ‰€æœ‰çš„Unicodeå­—ç¬¦äº†.\nReference\nhttps://jwodder.github.io/kbits/posts/unicode-latex/\n","permalink":"https://Anlarry.github.io/posts/tool/xelatexunicode/","summary":"Unicodeä¸°å¯Œäº†æ—¥å¸¸ä½¿ç”¨çš„å­—ç¬¦é›†, è®©æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ä¸€ç§ç®€å•ä¾¿æ·çš„æ–¹å¼è¡¨è¾¾å„ç§å¥‡æ€ªçš„å­—ç¬¦, æ¯”å¦‚æƒ³è¦åœ¨è¾“å…¥ä¸€ä¸ªé›ªäººSnowman, U+2603\nâ˜ƒ latexä½œä¸ºæ—¥å¸¸ä½¿ç”¨çš„æ’ç‰ˆå·¥å…·, æ€ä¹ˆåœ¨latexä¸­æ’å…¥ä¸€ä¸ªunicode? ä¸€èˆ¬æ¥è®², åº”è¯¥Ctrl+C, Ctrl+Vå°±å¯ä»¥, æˆ‘ä»¬æ¥çœ‹çœ‹ä¸‹é¢çš„ä»£ç \n\\documentclass[utf8]{article} \\begin{document} \\huge Unicode char \\texttt{U+13105} is ğ“„… Unicode char \\texttt{U+16E4} is á›¤ Unicode char \\texttt{U+25E6} is â—¦ \\end{document} ç„¶è€Œè¾“å‡ºçš„PDFä¸­å¹¶æ²¡æœ‰åŒ…å«æ‰€æœ‰çš„Unicodeå­—ç¬¦, çœ‹èµ·æ¥è¿™ä¸ªé—®é¢˜è¿˜å­˜åœ¨ä¸€å®šçš„å…±æ€§unicode-characters-not-displaying-in-xetex, è€Œä¸”ä¼¼ä¹æ˜¯ä¸ªå­—ä½“é—®é¢˜.\nTex Engineä½¿ç”¨xelatex\næˆ‘ä»¬æ¥è¯•è¯•æ›´æ¢ä¸ºFreeMonoå­—ä½“\n\\documentclass[utf8]{article} \\usepackage{fontspec} \\setmainfont{FreeMono} \\begin{document} \\huge Unicode char \\texttt{U+13105} is ğ“„… Unicode char \\texttt{U+16E4} is á›¤ Unicode char \\texttt{U+25E6} is â—¦ \\end{document} Ha!ç°åœ¨á›¤å·²ç»å¯ä»¥æ­£å¸¸æ˜¾ç¤ºäº†, ğ“„…å´å˜æˆäº†ä¸€ä¸ªå¥‡æ€ªå­—ç¬¦. å…¶å®è¿™æ˜¯å› ä¸ºåœ¨FreeMonoå­—ä½“ä¸­ç¼ºå¤±å­—ç¬¦ğ“„…, è€Œá›¤ä¹‹æ‰€ä»¥èƒ½æ˜¾ç¤ºæ˜¯å› ä¸ºFreeMonoåŒ…å«äº†è¿™ä¸ªå­—ç¬¦.\nå› æ­¤æˆ‘ä»¬å¯ä»¥å‘ç°, åœ¨xelatexä¸­ä½¿ç”¨Unicode, éœ€è¦ä½¿ç”¨æ­£ç¡®çš„å­—ä½“, å³å­—ä½“ä¸­è¦åŒ…å«åº”ç›¸åº”çš„unicodeå­—ç¬¦.\né‚£æ–°çš„é—®é¢˜æ¥äº†, æ€ä¹ˆçŸ¥é“ä»€ä¹ˆå­—ä½“åŒ…å«äº†ğ“„…? é€›äº†ä¸€åœˆstackoverflowå‘ç°fileformat.infoå¯ä»¥è§£å†³è¿™ä¸ªé—®é¢˜.\nğ“„…å…¶å®åœ¨Egyptian Hieroglyphsä¸­, æ‰¾åˆ°ç›¸åº”çš„å­—ä½“Noto Sans Egyptian Hieroglyphs","title":"Unicode with xelatex"},{"content":"System Call Cost åº”ç”¨ç¨‹åºé€šè¿‡System Callå‘kernelè¯·æ±‚æœåŠ¡ã€‚ä¸€èˆ¬åº”ç”¨ç¨‹åºå‘èµ·ç³»ç»Ÿè°ƒç”¨åï¼Œä»ç”¨æˆ·æ€è¿›å…¥å†…æ ¸æ€ï¼Œæœ€åä»å¼‚å¸¸é€€å‡ºï¼Œè¿”å›ç”¨æˆ·æ€ã€‚\nä½†æ˜¯è¿™ç§åŒæ­¥çš„ç³»ç»Ÿè°ƒç”¨æœºåˆ¶å¯èƒ½å¯¹åº”ç”¨çš„æ€§èƒ½å¸¦æ¥é™åˆ¶ï¼š\nDirect Cost: åœ¨ç³»ç»Ÿè°ƒç”¨åï¼ŒCPUä¼šæ¸…ç©ºæµæ°´çº¿ã€‚ Indirect Cost: ç¨‹åºçš„å±€éƒ¨æ€§ä»¥åŠcacheå¯ä»¥æå‡æ€§èƒ½ã€‚ä½†æ˜¯åœ¨ç³»ç»Ÿè°ƒç”¨åï¼Œè¦åœ¨kernelç©ºé—´æ‰§è¡Œä»£ç ï¼Œè¿™å°±ä¼šå½±å“cacheæ€§èƒ½ã€‚è€Œä¸”åœ¨kernelå¤„ç†ç»“æŸè¿”å›ç”¨æˆ·åï¼Œç›¸æ¯”ä¸åŸæ¥çš„cacheï¼Œcacheå—åˆ°äº†æ±¡æŸ“ï¼Œå¸¦æ¥é—´æ¥æ€§èƒ½æŸå¤±ã€‚ å¯ä»¥çœ‹åˆ°åœ¨ç³»ç»Ÿè°ƒç”¨åï¼ŒIPC(Instructions Per Cycle)é™ä½ã€‚\nException-Less System Call exception-lessç³»ç»Ÿè°ƒç”¨ï¼Œè®©ç³»ç»Ÿè°ƒç”¨å¼‚æ­¥å®Œæˆã€‚åœ¨userå’Œkernelå…±äº«ä¸€äº›syscall pagesï¼Œç”¨è¿™äº›syscall pageè®°å½•å½“å‰è¯·æ±‚çš„ç³»ç»Ÿè°ƒç”¨ã€‚ç”¨æˆ·å‘èµ·ç³»ç»Ÿè°ƒç”¨åï¼Œåœ¨syscall pagesä¸­æ·»åŠ æ–°çš„entryåå°±å¯ä»¥è¿”å›ã€‚åŒæ—¶ï¼Œæœ‰ä¸€äº›ç‰¹æ®Šçš„kernel threadï¼Œsyscall threadï¼Œåœ¨syscall pagesä¸­æ‰¾åˆ°è¯·æ±‚çš„ç³»ç»Ÿè°ƒç”¨ï¼ŒæŠŠè¿”å›å€¼å†™åœ¨ç›¸åº”çš„æ¡ç›®ã€‚æœ€åç”¨æˆ·å°±é€šè¿‡å¯ä»¥æ£€æŸ¥syscall pagesï¼Œæ‹¿åˆ°è¿”å›å€¼ã€‚\né‚£è¿™ç§å°†invokeå’Œexecuteè§£è€¦çš„è®¾è®¡æ€ä¹ˆåšæœ‰ä»€ä¹ˆå¥½å¤„å‘¢ï¼Ÿ\nå¯ä»¥æ¨è¿Ÿæ‰§è¡Œï¼ŒæŠŠsyscallæŒ‰batchæ‰§è¡Œï¼Œé™ä½modeä¹‹é—´è½¬åŒ–çš„ä»£ä»·ï¼Œimprove temporal localityã€‚ å¯¹äºå¤šæ ¸ç³»ç»Ÿï¼Œå¯ä»¥æŠŠsyscallæ”¾åœ¨å¦ä¸€ä¸ªæ ¸ä¸Šæ‰§è¡Œï¼Œè¿™æ ·å°±å¯ä»¥é™ä½é—´æ¥ä»£ä»·ï¼Œimproved spatial localityã€‚ Implementation åœ¨å®ç°æ—¶ï¼Œä½œè€…æ·»åŠ ä¸¤ä¸ªæ–°çš„ç³»ç»Ÿè°ƒç”¨ï¼Œéƒ½é‡‡ç”¨åŒæ­¥çš„ç³»ç»Ÿè°ƒç”¨æœºåˆ¶ã€‚\nflexsc_registerï¼Œåšä¸€äº›syscall pageçš„æ˜ å°„ï¼Œå¹¶åˆ›å»ºsyscall threadï¼Œæ•°é‡ç­‰äºpageä¸­entryçš„æ•°é‡ã€‚ flexsc_waitï¼Œå› ä¸ºè¿™ç§å¼‚æ­¥æœºåˆ¶ï¼Œä¼šå‡ºç°ç”¨æˆ·éœ€è¦åœä¸‹æ¥ç­‰å¾…ç³»ç»Ÿè°ƒç”¨çš„å®Œæˆã€‚ syscall threadçš„è°ƒåº¦ï¼Œä¼šå½±å“exception-less syscallçš„æ€§èƒ½ã€‚å¯¹äºå•æ ¸ï¼Œè°ƒç”¨flexsc_waitåï¼Œè°ƒåº¦syscall threadå¤„ç†pageä¸­æ¯ä¸ªentryï¼Œå¦‚æœå‡ºç°é˜»å¡ï¼Œå°±ç”¨æ–°çš„syscall threadæ¥ç€å¤„ç†ä¸€ä¸‹ä¸ªentryã€‚å¤šæ ¸æ—¶ï¼Œone syscall thread per application and coreï¼Œè¿™æ ·å°±å¸¦æ¥äº†å¹¶è¡Œå¤„ç†çš„å¯èƒ½ã€‚\nFlexSC Threads ä½†æ˜¯è¿™æ ·å¼‚æ­¥æ–¹å¼ï¼Œå¯èƒ½ä¼šè®©ä½¿ç”¨å˜å¾—å¤æ‚ï¼Œè€Œä¸”éšç€å¤šæ ¸çš„å‘å±•ï¼Œä½œè€…å°±å®ç°äº†FlexSC-Threadsã€‚åˆ©ç”¨dynamic loadingï¼Œç³»ç»Ÿè°ƒç”¨æ—¶ï¼Œè°ƒç”¨ä¸€ä¸ªwrapperï¼Œè¿™æ ·å°±å¯ä»¥è®©åº”ç”¨å¾—åˆ°free lunchã€‚\nç»´æŠ¤$M$ä¸ªuser-mod threadï¼Œå¯¹ä¸€ä¸ªprocessï¼Œæ¯ä¸ªæ ¸ä¸Šåªæœ‰ä¸€ä¸ªå¯ä»¥è¢«kernelçœ‹è§ã€‚å‘èµ·ç³»ç»Ÿè°ƒç”¨çš„çº¿ç¨‹ï¼Œåœ¨å†™å¥½entryåï¼Œå°±ä¼šè¢«åˆ‡æ¢æ‰§è¡Œä¸€ä¸‹threadã€‚ç”¨å®Œreadyçš„user-mode threadï¼Œå°±çœ‹çœ‹syscall pageä¸Šæœ‰æ²¡æœ‰å®Œæˆçš„ã€‚å¦‚æœè¿˜æ²¡æœ‰readyçš„ï¼Œå°±éœ€è¦è°ƒç”¨ä¸‹flexsc_waitã€‚\nå¯¹äºè¿™ç§è®¾è®¡ï¼Œéœ€è¦æé«˜å¹¶å‘ï¼Œæ¥æå‡æ€§èƒ½ã€‚highly threaded workloadsæ˜¯FlexSC-Threadsçš„ç†æƒ³ç¯å¢ƒã€‚\nReference\n[1] Soares L, Stumm M. FlexSC: Flexible System Call Scheduling with Exception-Less System Calls[C]//Osdi. 2010, 10: 33-46.\n","permalink":"https://Anlarry.github.io/posts/paper-reading/flexsc/","summary":"System Call Cost åº”ç”¨ç¨‹åºé€šè¿‡System Callå‘kernelè¯·æ±‚æœåŠ¡ã€‚ä¸€èˆ¬åº”ç”¨ç¨‹åºå‘èµ·ç³»ç»Ÿè°ƒç”¨åï¼Œä»ç”¨æˆ·æ€è¿›å…¥å†…æ ¸æ€ï¼Œæœ€åä»å¼‚å¸¸é€€å‡ºï¼Œè¿”å›ç”¨æˆ·æ€ã€‚\nä½†æ˜¯è¿™ç§åŒæ­¥çš„ç³»ç»Ÿè°ƒç”¨æœºåˆ¶å¯èƒ½å¯¹åº”ç”¨çš„æ€§èƒ½å¸¦æ¥é™åˆ¶ï¼š\nDirect Cost: åœ¨ç³»ç»Ÿè°ƒç”¨åï¼ŒCPUä¼šæ¸…ç©ºæµæ°´çº¿ã€‚ Indirect Cost: ç¨‹åºçš„å±€éƒ¨æ€§ä»¥åŠcacheå¯ä»¥æå‡æ€§èƒ½ã€‚ä½†æ˜¯åœ¨ç³»ç»Ÿè°ƒç”¨åï¼Œè¦åœ¨kernelç©ºé—´æ‰§è¡Œä»£ç ï¼Œè¿™å°±ä¼šå½±å“cacheæ€§èƒ½ã€‚è€Œä¸”åœ¨kernelå¤„ç†ç»“æŸè¿”å›ç”¨æˆ·åï¼Œç›¸æ¯”ä¸åŸæ¥çš„cacheï¼Œcacheå—åˆ°äº†æ±¡æŸ“ï¼Œå¸¦æ¥é—´æ¥æ€§èƒ½æŸå¤±ã€‚ å¯ä»¥çœ‹åˆ°åœ¨ç³»ç»Ÿè°ƒç”¨åï¼ŒIPC(Instructions Per Cycle)é™ä½ã€‚\nException-Less System Call exception-lessç³»ç»Ÿè°ƒç”¨ï¼Œè®©ç³»ç»Ÿè°ƒç”¨å¼‚æ­¥å®Œæˆã€‚åœ¨userå’Œkernelå…±äº«ä¸€äº›syscall pagesï¼Œç”¨è¿™äº›syscall pageè®°å½•å½“å‰è¯·æ±‚çš„ç³»ç»Ÿè°ƒç”¨ã€‚ç”¨æˆ·å‘èµ·ç³»ç»Ÿè°ƒç”¨åï¼Œåœ¨syscall pagesä¸­æ·»åŠ æ–°çš„entryåå°±å¯ä»¥è¿”å›ã€‚åŒæ—¶ï¼Œæœ‰ä¸€äº›ç‰¹æ®Šçš„kernel threadï¼Œsyscall threadï¼Œåœ¨syscall pagesä¸­æ‰¾åˆ°è¯·æ±‚çš„ç³»ç»Ÿè°ƒç”¨ï¼ŒæŠŠè¿”å›å€¼å†™åœ¨ç›¸åº”çš„æ¡ç›®ã€‚æœ€åç”¨æˆ·å°±é€šè¿‡å¯ä»¥æ£€æŸ¥syscall pagesï¼Œæ‹¿åˆ°è¿”å›å€¼ã€‚\né‚£è¿™ç§å°†invokeå’Œexecuteè§£è€¦çš„è®¾è®¡æ€ä¹ˆåšæœ‰ä»€ä¹ˆå¥½å¤„å‘¢ï¼Ÿ\nå¯ä»¥æ¨è¿Ÿæ‰§è¡Œï¼ŒæŠŠsyscallæŒ‰batchæ‰§è¡Œï¼Œé™ä½modeä¹‹é—´è½¬åŒ–çš„ä»£ä»·ï¼Œimprove temporal localityã€‚ å¯¹äºå¤šæ ¸ç³»ç»Ÿï¼Œå¯ä»¥æŠŠsyscallæ”¾åœ¨å¦ä¸€ä¸ªæ ¸ä¸Šæ‰§è¡Œï¼Œè¿™æ ·å°±å¯ä»¥é™ä½é—´æ¥ä»£ä»·ï¼Œimproved spatial localityã€‚ Implementation åœ¨å®ç°æ—¶ï¼Œä½œè€…æ·»åŠ ä¸¤ä¸ªæ–°çš„ç³»ç»Ÿè°ƒç”¨ï¼Œéƒ½é‡‡ç”¨åŒæ­¥çš„ç³»ç»Ÿè°ƒç”¨æœºåˆ¶ã€‚\nflexsc_registerï¼Œåšä¸€äº›syscall pageçš„æ˜ å°„ï¼Œå¹¶åˆ›å»ºsyscall threadï¼Œæ•°é‡ç­‰äºpageä¸­entryçš„æ•°é‡ã€‚ flexsc_waitï¼Œå› ä¸ºè¿™ç§å¼‚æ­¥æœºåˆ¶ï¼Œä¼šå‡ºç°ç”¨æˆ·éœ€è¦åœä¸‹æ¥ç­‰å¾…ç³»ç»Ÿè°ƒç”¨çš„å®Œæˆã€‚ syscall threadçš„è°ƒåº¦ï¼Œä¼šå½±å“exception-less syscallçš„æ€§èƒ½ã€‚å¯¹äºå•æ ¸ï¼Œè°ƒç”¨flexsc_waitåï¼Œè°ƒåº¦syscall threadå¤„ç†pageä¸­æ¯ä¸ªentryï¼Œå¦‚æœå‡ºç°é˜»å¡ï¼Œå°±ç”¨æ–°çš„syscall threadæ¥ç€å¤„ç†ä¸€ä¸‹ä¸ªentryã€‚å¤šæ ¸æ—¶ï¼Œone syscall thread per application and coreï¼Œè¿™æ ·å°±å¸¦æ¥äº†å¹¶è¡Œå¤„ç†çš„å¯èƒ½ã€‚\nFlexSC Threads ä½†æ˜¯è¿™æ ·å¼‚æ­¥æ–¹å¼ï¼Œå¯èƒ½ä¼šè®©ä½¿ç”¨å˜å¾—å¤æ‚ï¼Œè€Œä¸”éšç€å¤šæ ¸çš„å‘å±•ï¼Œä½œè€…å°±å®ç°äº†FlexSC-Threadsã€‚åˆ©ç”¨dynamic loadingï¼Œç³»ç»Ÿè°ƒç”¨æ—¶ï¼Œè°ƒç”¨ä¸€ä¸ªwrapperï¼Œè¿™æ ·å°±å¯ä»¥è®©åº”ç”¨å¾—åˆ°free lunchã€‚\nç»´æŠ¤$M$ä¸ªuser-mod threadï¼Œå¯¹ä¸€ä¸ªprocessï¼Œæ¯ä¸ªæ ¸ä¸Šåªæœ‰ä¸€ä¸ªå¯ä»¥è¢«kernelçœ‹è§ã€‚å‘èµ·ç³»ç»Ÿè°ƒç”¨çš„çº¿ç¨‹ï¼Œåœ¨å†™å¥½entryåï¼Œå°±ä¼šè¢«åˆ‡æ¢æ‰§è¡Œä¸€ä¸‹threadã€‚ç”¨å®Œreadyçš„user-mode threadï¼Œå°±çœ‹çœ‹syscall pageä¸Šæœ‰æ²¡æœ‰å®Œæˆçš„ã€‚å¦‚æœè¿˜æ²¡æœ‰readyçš„ï¼Œå°±éœ€è¦è°ƒç”¨ä¸‹flexsc_waitã€‚\nå¯¹äºè¿™ç§è®¾è®¡ï¼Œéœ€è¦æé«˜å¹¶å‘ï¼Œæ¥æå‡æ€§èƒ½ã€‚highly threaded workloadsæ˜¯FlexSC-Threadsçš„ç†æƒ³ç¯å¢ƒã€‚\nReference\n[1] Soares L, Stumm M. FlexSC: Flexible System Call Scheduling with Exception-Less System Calls[C]//Osdi.","title":"FlexSC"},{"content":"Background åŸºæœ¬å„ç§ä¸œè¥¿éƒ½å¯ä»¥ç”¨å›¾æ¥è¡¨ç¤ºï¼Œä¹Ÿå°±ä¿ƒæˆäº†GNNçš„å¿«é€Ÿå‘å±•ã€‚ç„¶è€Œå¾ˆå¤šå›¾éƒ½æœ‰è¿™æ ·çš„ç‰¹ç‚¹ï¼Œä¸€äº›èŠ‚ç‚¹çš„åº¦æ•°å¾ˆé«˜ç„¶è€Œå¤§å¤šæ•°èŠ‚ç‚¹çš„åº¦æ•°å¾ˆä½ã€‚\nè®­ç»ƒæ—¶è¦ç”¨é‚»å±…æ›´æ–°å½“å‰èŠ‚ç‚¹ï¼Œä¸èƒ½å°†æ•´ä¸ªå›¾å…¨éƒ¨æ‹¿æ¥è®­ç»ƒï¼Œå› æ­¤ä¸€èˆ¬é‡‡ç”¨graph sampling+mini batchï¼Œæ¯”å¦‚ï¼Œç»™$n$ä¸ªèŠ‚ç‚¹ï¼Œæ¯ä¸ªèŠ‚ç‚¹å¯¹é‚»å±…é‡‡æ ·ååœ¨è¿›è¡Œè®­ç»ƒã€‚\nç„¶è€Œäº§ç”Ÿäº†æ–°çš„é—®é¢˜ï¼Œé‡‡æ ·åœ¨æ•´ä¸ªè®­ç»ƒè¿‡ç¨‹ä¸­å äº†å¾ˆå¤šæ—¶é—´ã€‚\nå› æ­¤ï¼Œå¤§å®¶ä¹Ÿä¼šå»æƒ³ç”¨GPUåŠ é€Ÿé‡‡æ ·ï¼Œä½†æ˜¯naiveçš„æ–¹æ³•å¹¶ä¸èƒ½å¾ˆå¥½çš„åˆ©ç”¨GPUã€‚\n\u0026ldquo;Transit-Parallelism\u0026rdquo; ä½œè€…é¦–å…ˆå¯¹é‡‡æ ·è¿›è¡Œäº†æŠ½è±¡ï¼Œé‡‡æ ·ä»ä¸€èŠ‚ç‚¹å¼€å§‹ï¼Œæ‰©å±•å‡ºæ–°çš„èŠ‚ç‚¹åŠ å…¥sampleï¼Œå†ä»æ–°çš„èŠ‚ç‚¹æ‰©å±•$\\cdots$ï¼Œæ¯æ¬¡éå†é‚»å±…æ‰©å±•æ–°èŠ‚ç‚¹çš„èŠ‚ç‚¹ï¼Œä½œè€…æŠŠå®ƒå«åš\u0026quot;transit vertices\u0026quot;\nå°†é‡‡æ ·åˆ†æˆä¸¤ç±»ï¼š\nIndividual Transit Samplingï¼Œè¿™ä¸ªæ˜¯æŒ‰èŠ‚ç‚¹æ¥çš„ï¼Œæ¯ä¸ªtransitèŠ‚ç‚¹ä»é‚»å±…ä¸­é‡‡æ ·ä¸€å®šæ•°é‡çš„èŠ‚ç‚¹ Collective Transit Samplingï¼Œè¿™ä¸ªæ˜¯æŒ‰å±‚æ¥ï¼Œæ¯ä¸€å±‚ä»æ‰€æœ‰transitèŠ‚ç‚¹çš„é‚»å±…ä¸­é‡‡æ ·ä¸€å®šæ•°é‡çš„èŠ‚ç‚¹ CUDA \u0026amp; GPU\nä¸€ä¸ªCUDAç¨‹åºè¢«åˆ’åˆ†ç»™å¾ˆå¤šblocks of threadså®Œæˆå¹¶è¡Œï¼Œè€ŒGPUåˆç”±å¾ˆå¤šStreamingMultiprocessors (SMs)æ„æˆï¼Œæ¯ä¸ªblockè¢«æ”¾åˆ°SMä¸Šæ‰§è¡Œ\nä¸€ä¸ªblockçš„çº¿ç¨‹æ•°æ˜¯æœ‰é™çš„ï¼Œä½†æ˜¯ç›¸åŒçš„å¤§å°blockå¯ä»¥è¢«ç»„ç»‡æˆgridï¼Œäºæ˜¯kernel(a c++ function)å°±å¯ä»¥ç”¨gridé‡Œé¢æ‰€æœ‰çš„çº¿ç¨‹ã€‚ $$ thread \\xrightarrow[]{array} block \\xrightarrow[]{array} grid $$ ä¼—æ‰€å‘¨çŸ¥ï¼Œå†…å­˜å±‚æ¬¡ç»“æ„ï¼ŒGPUå½“ç„¶ä¹Ÿæœ‰ï¼š\nå‰é¢å·²ç»æåˆ°äº†blockä¼šåœ¨SMä¸Šæ‰§è¡Œï¼Œåœ¨ç‰©ç†å®ç°æ—¶ä¼šç”¨åˆ°SIMT(Single-Instruction, Multiple-Thread)ã€‚multiprocessorç”¨warp(a group of 32 threads)æ¥ç®¡ç†çº¿ç¨‹ã€‚\nwarpä¸­çš„çº¿ç¨‹éƒ½ä»ç›¸åŒçš„èµ·ç‚¹å¼€å§‹ï¼Œä½†æ˜¯æ¯ä¸ªçº¿ç¨‹éƒ½æœ‰è‡ªå·±çš„pcï¼Œå¯„å­˜å™¨çŠ¶æ€ä¹Ÿå¯èƒ½ä¸ä¸€æ ·ã€‚è€Œä¸”ä¸€ä¸ªwarpçš„threadæ‰§è¡Œçš„æŒ‡ä»¤è¿˜æ˜¯ç›¸åŒçš„ã€‚\nå¦‚æœå°±æ˜¯æ™®é€šçš„æ²¡æœ‰æ§åˆ¶æµçš„ä»£ç ï¼Œå¤§å®¶å°±ä¸€èµ·æ‰§è¡Œã€‚é‚£é‡åˆ°åˆ†æ”¯æ€ä¹ˆåŠï¼Œæ¯ä¸ªçº¿ç¨‹å¯èƒ½æœ‰ä¸åŒçš„è·¯å¾„ã€‚è¿™æ—¶å°±ä¼šå˜æˆä¸²è¡Œã€‚warpå»æ‰§è¡Œæ¯ä¸ªåˆ†æ”¯è·¯å¾„ï¼Œä¸åœ¨è·¯å¾„ä¸Šçš„threadå°±ç­‰ç€ã€‚è¿™å°±å¯èƒ½ä¼šå¾ˆå½±å“å¹¶è¡Œï¼Œä¹Ÿå°±æ˜¯Branch divergenceã€‚\nSample-Parallelismï¼Œå¯¹äºIndividual Transit Samplingå¯ä»¥å°†æ¯ä¸€å¯¹sampleå’Œtransitåˆ†é…$m_i$ä¸ªçº¿ç¨‹ï¼Œæ¯ä¸ªsampleæ”¾åˆ°ä¸€ä¸ªblocké‡Œã€‚å¯¹äºCollective Transit Samplingï¼Œéœ€è¦å…ˆæŠŠæ‰€æœ‰çš„é‚»å±…å­˜åˆ°global memoryé‡Œï¼Œå†é‡‡æ ·ã€‚\nåœ¨é‡‡æ ·æ—¶ï¼Œé‚»å±…å¤šçš„èŠ‚ç‚¹è®¡ç®—çš„æ—¶é—´å°±ä¼šæ›´ä¹…ã€‚å¦‚æœåŒä¸€ä¸ªwarpé‡Œé¢çš„ä¸¤ä¸ªthreadè¢«åˆ†ç»™ä¸¤ä¸ªé‚»å±…æ•°é‡ä¸åŒçš„transitï¼Œå°±ä¼šæœ‰divergenceã€‚è€Œä¸”ï¼Œå›¾å¾—å­˜åœ¨gobal memoryï¼Œshared memoryåˆ©ç”¨ä¸å……åˆ†ã€‚\nä½†æ˜¯å¦‚æœæ˜¯æŒ‰transitåˆ’åˆ†ï¼Œå±€éƒ¨æ€§å°±ä¼šæ›´å¥½ï¼ŒæŒ‰ç…§å·¥ä½œé‡éœ€æ±‚åˆ†é…çº¿ç¨‹æ•°é‡ã€‚æ˜¯ä¸æ˜¯æœ‰ç‚¹åƒå€’æ’ç´¢å¼• :-)\nçº¿ç¨‹ç»„ä¸­çš„çº¿ç¨‹ï¼Œä»–ä»¬åšçš„äº‹æƒ…æ›´ç›¸ä¼¼ï¼Œè€Œä¸”å·¥ä½œé‡ä¹Ÿå·®ä¸å¤šã€‚ä»–ä»¬è®¿é—®çš„é‚»å±…ä¹Ÿæ˜¯åŒä¸€ä¸ªtransitçš„ï¼Œèƒ½æ›´å¥½åˆ©ç”¨share memoryã€‚\nSampling Large Graphs NextDoorè¿˜å¯ä»¥å»å¯¹è¶…å‡ºGPU memoryçš„å›¾é‡‡æ ·ã€‚æ–¹æ³•æœ‰ç‚¹åƒmini batchï¼ŒæŠŠå›¾åˆ†æˆä¸ç›¸äº¤çš„å­å›¾ï¼Œæ¯æ¬¡å¯¹ä¸€ä¸ªå­å›¾å’Œå’Œå…¶transitèŠ‚ç‚¹é‡‡æ ·ã€‚\nReference\n[1] Jangda A, Polisetty S, Guha A, et al. Accelerating graph sampling for graph machine learning using gpus[C]//Proceedings of the Sixteenth European Conference on Computer Systems. 2021: 311-326.\n[2] Ward I R, Joyner J, Lickfold C, et al. A Practical Guide to Graph Neural Networks[J]. arXiv preprint arXiv:2010.05234, 2020.\n[3] CUDA C++ Programming Guide\n","permalink":"https://Anlarry.github.io/posts/paper-reading/nextdoor/","summary":"Background åŸºæœ¬å„ç§ä¸œè¥¿éƒ½å¯ä»¥ç”¨å›¾æ¥è¡¨ç¤ºï¼Œä¹Ÿå°±ä¿ƒæˆäº†GNNçš„å¿«é€Ÿå‘å±•ã€‚ç„¶è€Œå¾ˆå¤šå›¾éƒ½æœ‰è¿™æ ·çš„ç‰¹ç‚¹ï¼Œä¸€äº›èŠ‚ç‚¹çš„åº¦æ•°å¾ˆé«˜ç„¶è€Œå¤§å¤šæ•°èŠ‚ç‚¹çš„åº¦æ•°å¾ˆä½ã€‚\nè®­ç»ƒæ—¶è¦ç”¨é‚»å±…æ›´æ–°å½“å‰èŠ‚ç‚¹ï¼Œä¸èƒ½å°†æ•´ä¸ªå›¾å…¨éƒ¨æ‹¿æ¥è®­ç»ƒï¼Œå› æ­¤ä¸€èˆ¬é‡‡ç”¨graph sampling+mini batchï¼Œæ¯”å¦‚ï¼Œç»™$n$ä¸ªèŠ‚ç‚¹ï¼Œæ¯ä¸ªèŠ‚ç‚¹å¯¹é‚»å±…é‡‡æ ·ååœ¨è¿›è¡Œè®­ç»ƒã€‚\nç„¶è€Œäº§ç”Ÿäº†æ–°çš„é—®é¢˜ï¼Œé‡‡æ ·åœ¨æ•´ä¸ªè®­ç»ƒè¿‡ç¨‹ä¸­å äº†å¾ˆå¤šæ—¶é—´ã€‚\nå› æ­¤ï¼Œå¤§å®¶ä¹Ÿä¼šå»æƒ³ç”¨GPUåŠ é€Ÿé‡‡æ ·ï¼Œä½†æ˜¯naiveçš„æ–¹æ³•å¹¶ä¸èƒ½å¾ˆå¥½çš„åˆ©ç”¨GPUã€‚\n\u0026ldquo;Transit-Parallelism\u0026rdquo; ä½œè€…é¦–å…ˆå¯¹é‡‡æ ·è¿›è¡Œäº†æŠ½è±¡ï¼Œé‡‡æ ·ä»ä¸€èŠ‚ç‚¹å¼€å§‹ï¼Œæ‰©å±•å‡ºæ–°çš„èŠ‚ç‚¹åŠ å…¥sampleï¼Œå†ä»æ–°çš„èŠ‚ç‚¹æ‰©å±•$\\cdots$ï¼Œæ¯æ¬¡éå†é‚»å±…æ‰©å±•æ–°èŠ‚ç‚¹çš„èŠ‚ç‚¹ï¼Œä½œè€…æŠŠå®ƒå«åš\u0026quot;transit vertices\u0026quot;\nå°†é‡‡æ ·åˆ†æˆä¸¤ç±»ï¼š\nIndividual Transit Samplingï¼Œè¿™ä¸ªæ˜¯æŒ‰èŠ‚ç‚¹æ¥çš„ï¼Œæ¯ä¸ªtransitèŠ‚ç‚¹ä»é‚»å±…ä¸­é‡‡æ ·ä¸€å®šæ•°é‡çš„èŠ‚ç‚¹ Collective Transit Samplingï¼Œè¿™ä¸ªæ˜¯æŒ‰å±‚æ¥ï¼Œæ¯ä¸€å±‚ä»æ‰€æœ‰transitèŠ‚ç‚¹çš„é‚»å±…ä¸­é‡‡æ ·ä¸€å®šæ•°é‡çš„èŠ‚ç‚¹ CUDA \u0026amp; GPU\nä¸€ä¸ªCUDAç¨‹åºè¢«åˆ’åˆ†ç»™å¾ˆå¤šblocks of threadså®Œæˆå¹¶è¡Œï¼Œè€ŒGPUåˆç”±å¾ˆå¤šStreamingMultiprocessors (SMs)æ„æˆï¼Œæ¯ä¸ªblockè¢«æ”¾åˆ°SMä¸Šæ‰§è¡Œ\nä¸€ä¸ªblockçš„çº¿ç¨‹æ•°æ˜¯æœ‰é™çš„ï¼Œä½†æ˜¯ç›¸åŒçš„å¤§å°blockå¯ä»¥è¢«ç»„ç»‡æˆgridï¼Œäºæ˜¯kernel(a c++ function)å°±å¯ä»¥ç”¨gridé‡Œé¢æ‰€æœ‰çš„çº¿ç¨‹ã€‚ $$ thread \\xrightarrow[]{array} block \\xrightarrow[]{array} grid $$ ä¼—æ‰€å‘¨çŸ¥ï¼Œå†…å­˜å±‚æ¬¡ç»“æ„ï¼ŒGPUå½“ç„¶ä¹Ÿæœ‰ï¼š\nå‰é¢å·²ç»æåˆ°äº†blockä¼šåœ¨SMä¸Šæ‰§è¡Œï¼Œåœ¨ç‰©ç†å®ç°æ—¶ä¼šç”¨åˆ°SIMT(Single-Instruction, Multiple-Thread)ã€‚multiprocessorç”¨warp(a group of 32 threads)æ¥ç®¡ç†çº¿ç¨‹ã€‚\nwarpä¸­çš„çº¿ç¨‹éƒ½ä»ç›¸åŒçš„èµ·ç‚¹å¼€å§‹ï¼Œä½†æ˜¯æ¯ä¸ªçº¿ç¨‹éƒ½æœ‰è‡ªå·±çš„pcï¼Œå¯„å­˜å™¨çŠ¶æ€ä¹Ÿå¯èƒ½ä¸ä¸€æ ·ã€‚è€Œä¸”ä¸€ä¸ªwarpçš„threadæ‰§è¡Œçš„æŒ‡ä»¤è¿˜æ˜¯ç›¸åŒçš„ã€‚\nå¦‚æœå°±æ˜¯æ™®é€šçš„æ²¡æœ‰æ§åˆ¶æµçš„ä»£ç ï¼Œå¤§å®¶å°±ä¸€èµ·æ‰§è¡Œã€‚é‚£é‡åˆ°åˆ†æ”¯æ€ä¹ˆåŠï¼Œæ¯ä¸ªçº¿ç¨‹å¯èƒ½æœ‰ä¸åŒçš„è·¯å¾„ã€‚è¿™æ—¶å°±ä¼šå˜æˆä¸²è¡Œã€‚warpå»æ‰§è¡Œæ¯ä¸ªåˆ†æ”¯è·¯å¾„ï¼Œä¸åœ¨è·¯å¾„ä¸Šçš„threadå°±ç­‰ç€ã€‚è¿™å°±å¯èƒ½ä¼šå¾ˆå½±å“å¹¶è¡Œï¼Œä¹Ÿå°±æ˜¯Branch divergenceã€‚\nSample-Parallelismï¼Œå¯¹äºIndividual Transit Samplingå¯ä»¥å°†æ¯ä¸€å¯¹sampleå’Œtransitåˆ†é…$m_i$ä¸ªçº¿ç¨‹ï¼Œæ¯ä¸ªsampleæ”¾åˆ°ä¸€ä¸ªblocké‡Œã€‚å¯¹äºCollective Transit Samplingï¼Œéœ€è¦å…ˆæŠŠæ‰€æœ‰çš„é‚»å±…å­˜åˆ°global memoryé‡Œï¼Œå†é‡‡æ ·ã€‚\nåœ¨é‡‡æ ·æ—¶ï¼Œé‚»å±…å¤šçš„èŠ‚ç‚¹è®¡ç®—çš„æ—¶é—´å°±ä¼šæ›´ä¹…ã€‚å¦‚æœåŒä¸€ä¸ªwarpé‡Œé¢çš„ä¸¤ä¸ªthreadè¢«åˆ†ç»™ä¸¤ä¸ªé‚»å±…æ•°é‡ä¸åŒçš„transitï¼Œå°±ä¼šæœ‰divergenceã€‚è€Œä¸”ï¼Œå›¾å¾—å­˜åœ¨gobal memoryï¼Œshared memoryåˆ©ç”¨ä¸å……åˆ†ã€‚\nä½†æ˜¯å¦‚æœæ˜¯æŒ‰transitåˆ’åˆ†ï¼Œå±€éƒ¨æ€§å°±ä¼šæ›´å¥½ï¼ŒæŒ‰ç…§å·¥ä½œé‡éœ€æ±‚åˆ†é…çº¿ç¨‹æ•°é‡ã€‚æ˜¯ä¸æ˜¯æœ‰ç‚¹åƒå€’æ’ç´¢å¼• :-)\nçº¿ç¨‹ç»„ä¸­çš„çº¿ç¨‹ï¼Œä»–ä»¬åšçš„äº‹æƒ…æ›´ç›¸ä¼¼ï¼Œè€Œä¸”å·¥ä½œé‡ä¹Ÿå·®ä¸å¤šã€‚ä»–ä»¬è®¿é—®çš„é‚»å±…ä¹Ÿæ˜¯åŒä¸€ä¸ªtransitçš„ï¼Œèƒ½æ›´å¥½åˆ©ç”¨share memoryã€‚\nSampling Large Graphs NextDoorè¿˜å¯ä»¥å»å¯¹è¶…å‡ºGPU memoryçš„å›¾é‡‡æ ·ã€‚æ–¹æ³•æœ‰ç‚¹åƒmini batchï¼ŒæŠŠå›¾åˆ†æˆä¸ç›¸äº¤çš„å­å›¾ï¼Œæ¯æ¬¡å¯¹ä¸€ä¸ªå­å›¾å’Œå’Œå…¶transitèŠ‚ç‚¹é‡‡æ ·ã€‚\nReference\n[1] Jangda A, Polisetty S, Guha A, et al.","title":"NextDoor"},{"content":" Intro \u0026amp; Background MLæ¨¡å‹ä¼šå› ä¸ºè®­ç»ƒå’Œæµ‹è¯•æ—¶çš„æ•°æ®åˆ†å¸ƒä¸åŒï¼Œå¯¼è‡´å¾ˆå¤šé¢„æµ‹é”™è¯¯ã€‚å°†MLæ¨¡å‹ä¼˜åŒ–databaseä¹Ÿé¢å¯¹è¿™ä¸ªé—®é¢˜ã€‚\nActive learning Active leraning ä¸»åŠ¨å­¦ä¹ é‡‡ç”¨çš„æ–¹æ³•æ˜¯ï¼Œå¯ä»¥åœ¨unlabledçš„æ•°æ®ä¸­å†é€‰å‡ºä¸€äº›æ•°æ®ï¼Œä»orcaleå¾—åˆ°æ•°æ®çš„lableï¼Œä»æ–°çš„çŸ¥è¯†ä¸­å­¦ä¹ ã€‚\nAn illustrative example of pool-based active learning Execution cost prediction \u0026amp; Plan regression prediction ECPæ˜¯ä¸€ä¸ªå›å½’ä»»åŠ¡ï¼Œéœ€è¦é¢„æµ‹æ‰§è¡Œplanéœ€è¦çš„æ—¶é—´ã€‚åœ¨ä¼˜åŒ–æŸ¥è¯¢ä¸­ï¼Œå¯ä»¥ç”¨ECPæ¥å¯»æ‰¾æœ€ä¼˜çš„plan PRPæ˜¯ä¸€ä¸ªåˆ†ç±»ä»»åŠ¡ï¼Œç»™å‡ºä¸¤ä¸ªplanï¼Œéœ€è¦æ‰¾åˆ°å“ªä¸ªplanä»£ä»·æ›´é«˜ Architecture åœ¨è¿™é‡Œoracleå¯ä»¥ç”¨databaseçš„å‰¯æœ¬æ‰§è¡Œplanï¼Œè·å–plançš„æ‰§è¡Œæ—¶é—´ã€‚å› æ­¤ä¸åŒçš„planå°±æœ‰ä¸åŒçš„costã€‚\nå¼€å§‹ï¼Œç”¨æˆ·æŒ‡å®šbudgetï¼Œä¹‹åADCPè·å–lableæ•°æ®æ—¶ä¼šæ¶ˆè€—budgetã€‚ADCPè·å–target dataï¼Œé€‰å‡ºunlabeled dataç»™äº¤ç»™å‰¯æœ¬æ‰§è¡Œã€‚è·å¾—æ–°çŸ¥è¯†åretrain MLæ¨¡å‹ï¼Œå†å¯¹target dataæ•°æ®è¿›è¡Œé¢„æµ‹ï¼Œè¿™æ—¶é”™è¯¯å°±ä¼šé™ä½ã€‚\nä½†æ˜¯æ–°çš„ç¯å¢ƒå°±æœ‰æ–°çš„é—®é¢˜ã€‚active learningéœ€è¦é€‰å‡ºè¦æ ‡æ³¨çš„æ•°æ®ï¼Œnoiseä¼šå¸¦æ¥ä¸€äº›é—®é¢˜ã€‚å› æ­¤éœ€è¦ç»¼åˆè€ƒè™‘costã€robustã€ä»¥åŠactive learningæœ€ä¸ç¡®å®šçš„unlabelæ•°æ®ã€‚ $$ w_x=\\frac{u(x)}{c(x)} $$ $c(x)$è¡¨ç¤ºcostï¼Œ$u(x)$è¡¨ç¤ºuncertaintyï¼Œå› æ­¤xçš„æƒé‡å¯ä»¥ç†è§£æˆâ€œuncertainty per costâ€ã€‚\nåŒæ—¶ä¸ºäº†è§£å†³noiseï¼Œè½¬åŒ–ä¸ºæ¦‚ç‡å¹¶åŠ å…¥Gumbelå™ªéŸ³\n$$ p(x)=\\frac{w_x}{\\sum_{x\u0026rsquo;}w_{x\u0026rsquo;}} \\newline {\\rm arg}\\ \\max\\limits_{x} \\log p(x)+G_x $$\nå¦å¤–ï¼Œè¿˜éœ€è¦å‡å°‘sampleæ—¶çš„å†—ä½™ã€‚\nAlgo \u0026 Example Comparison \u0026amp; Why it works HALç›¸æ¯”äºå…¶ä»–ALç­–ç•¥åˆ©ç”¨äº†å„ç§ä¸åŒçš„ç‰¹ç‚¹ã€‚æ„Ÿè§‰è¿™æ˜¯ä¸ºä»€ä¹ˆHALå¯ä»¥workçš„ä¸€ä¸ªåŸå› ã€‚åœ¨å®éªŒä¸­ï¼ŒOPT(A crude baseline)ç›´æ¥ç”¨costä¼°è®¡(for PRP)ï¼ŒHuberå›å½’(for ECP)å¾—åˆ°labelä¸ç”¨retrainä¹Ÿä¸éœ€è¦é¢å¤–çš„labelï¼Œæ¯”å…¶å®ƒALé”™è¯¯è¦é«˜å‡ºå¾ˆå¤šã€‚\nStrategy Properties åœ¨åŒæ ·çš„bugdetä¸‹ï¼ŒHALé€‰å‡ºäº†æ›´å¤šçš„labelï¼Œä¹Ÿå°±æ˜¯è¯´å¹³å‡æ¯ä¸ªlabelçš„costæ›´ä½(a)ã€‚ä½†æ˜¯ï¼Œå¯¹costè¶…è¿‡å¹³å‡å€¼çš„æ•°æ®ï¼Œerrorä¹Ÿæ›´ä½(b)ã€‚\n","permalink":"https://Anlarry.github.io/posts/paper-reading/active-learning-for-ml-enhanced-database-systems/","summary":"Intro \u0026amp; Background MLæ¨¡å‹ä¼šå› ä¸ºè®­ç»ƒå’Œæµ‹è¯•æ—¶çš„æ•°æ®åˆ†å¸ƒä¸åŒï¼Œå¯¼è‡´å¾ˆå¤šé¢„æµ‹é”™è¯¯ã€‚å°†MLæ¨¡å‹ä¼˜åŒ–databaseä¹Ÿé¢å¯¹è¿™ä¸ªé—®é¢˜ã€‚\nActive learning Active leraning ä¸»åŠ¨å­¦ä¹ é‡‡ç”¨çš„æ–¹æ³•æ˜¯ï¼Œå¯ä»¥åœ¨unlabledçš„æ•°æ®ä¸­å†é€‰å‡ºä¸€äº›æ•°æ®ï¼Œä»orcaleå¾—åˆ°æ•°æ®çš„lableï¼Œä»æ–°çš„çŸ¥è¯†ä¸­å­¦ä¹ ã€‚\nAn illustrative example of pool-based active learning Execution cost prediction \u0026amp; Plan regression prediction ECPæ˜¯ä¸€ä¸ªå›å½’ä»»åŠ¡ï¼Œéœ€è¦é¢„æµ‹æ‰§è¡Œplanéœ€è¦çš„æ—¶é—´ã€‚åœ¨ä¼˜åŒ–æŸ¥è¯¢ä¸­ï¼Œå¯ä»¥ç”¨ECPæ¥å¯»æ‰¾æœ€ä¼˜çš„plan PRPæ˜¯ä¸€ä¸ªåˆ†ç±»ä»»åŠ¡ï¼Œç»™å‡ºä¸¤ä¸ªplanï¼Œéœ€è¦æ‰¾åˆ°å“ªä¸ªplanä»£ä»·æ›´é«˜ Architecture åœ¨è¿™é‡Œoracleå¯ä»¥ç”¨databaseçš„å‰¯æœ¬æ‰§è¡Œplanï¼Œè·å–plançš„æ‰§è¡Œæ—¶é—´ã€‚å› æ­¤ä¸åŒçš„planå°±æœ‰ä¸åŒçš„costã€‚\nå¼€å§‹ï¼Œç”¨æˆ·æŒ‡å®šbudgetï¼Œä¹‹åADCPè·å–lableæ•°æ®æ—¶ä¼šæ¶ˆè€—budgetã€‚ADCPè·å–target dataï¼Œé€‰å‡ºunlabeled dataç»™äº¤ç»™å‰¯æœ¬æ‰§è¡Œã€‚è·å¾—æ–°çŸ¥è¯†åretrain MLæ¨¡å‹ï¼Œå†å¯¹target dataæ•°æ®è¿›è¡Œé¢„æµ‹ï¼Œè¿™æ—¶é”™è¯¯å°±ä¼šé™ä½ã€‚\nä½†æ˜¯æ–°çš„ç¯å¢ƒå°±æœ‰æ–°çš„é—®é¢˜ã€‚active learningéœ€è¦é€‰å‡ºè¦æ ‡æ³¨çš„æ•°æ®ï¼Œnoiseä¼šå¸¦æ¥ä¸€äº›é—®é¢˜ã€‚å› æ­¤éœ€è¦ç»¼åˆè€ƒè™‘costã€robustã€ä»¥åŠactive learningæœ€ä¸ç¡®å®šçš„unlabelæ•°æ®ã€‚ $$ w_x=\\frac{u(x)}{c(x)} $$ $c(x)$è¡¨ç¤ºcostï¼Œ$u(x)$è¡¨ç¤ºuncertaintyï¼Œå› æ­¤xçš„æƒé‡å¯ä»¥ç†è§£æˆâ€œuncertainty per costâ€ã€‚\nåŒæ—¶ä¸ºäº†è§£å†³noiseï¼Œè½¬åŒ–ä¸ºæ¦‚ç‡å¹¶åŠ å…¥Gumbelå™ªéŸ³\n$$ p(x)=\\frac{w_x}{\\sum_{x\u0026rsquo;}w_{x\u0026rsquo;}} \\newline {\\rm arg}\\ \\max\\limits_{x} \\log p(x)+G_x $$\nå¦å¤–ï¼Œè¿˜éœ€è¦å‡å°‘sampleæ—¶çš„å†—ä½™ã€‚\nAlgo \u0026 Example Comparison \u0026amp; Why it works HALç›¸æ¯”äºå…¶ä»–ALç­–ç•¥åˆ©ç”¨äº†å„ç§ä¸åŒçš„ç‰¹ç‚¹ã€‚æ„Ÿè§‰è¿™æ˜¯ä¸ºä»€ä¹ˆHALå¯ä»¥workçš„ä¸€ä¸ªåŸå› ã€‚åœ¨å®éªŒä¸­ï¼ŒOPT(A crude baseline)ç›´æ¥ç”¨costä¼°è®¡(for PRP)ï¼ŒHuberå›å½’(for ECP)å¾—åˆ°labelä¸ç”¨retrainä¹Ÿä¸éœ€è¦é¢å¤–çš„labelï¼Œæ¯”å…¶å®ƒALé”™è¯¯è¦é«˜å‡ºå¾ˆå¤šã€‚\nStrategy Properties åœ¨åŒæ ·çš„bugdetä¸‹ï¼ŒHALé€‰å‡ºäº†æ›´å¤šçš„labelï¼Œä¹Ÿå°±æ˜¯è¯´å¹³å‡æ¯ä¸ªlabelçš„costæ›´ä½(a)ã€‚ä½†æ˜¯ï¼Œå¯¹costè¶…è¿‡å¹³å‡å€¼çš„æ•°æ®ï¼Œerrorä¹Ÿæ›´ä½(b)ã€‚","title":"Active Learning for ML Enhanced Database Systems"},{"content":"Inter-Process Communication å¾®å†…æ ¸ç›¸æ¯”ä¸å®å†…æ ¸ï¼Œå…·æœ‰æ›´å¥½çš„æ‰©å±•æ€§ã€å®‰å…¨æ€§ï¼Œä¹Ÿèƒ½å¤Ÿæ›´å¥½åœ°å®¹å¿é”™è¯¯ã€‚ä½†æ˜¯å¾®å†…æ ¸åªä¿ç•™å¾ˆåŸºæœ¬çš„åŠŸèƒ½ï¼Œå¾ˆå¤šæœåŠ¡éƒ½ä½œä¸ºä¸€ä¸ªç”¨æˆ·è¿›ç¨‹å­˜åœ¨ï¼Œè¿›ç¨‹ä¹‹é—´å¤§é‡ä½¿ç”¨IPCä¼ é€’æ¶ˆæ¯ã€‚\nå¦å¤–åœ¨å®å†…æ ¸ä¸­ä¹Ÿä¼šç»å¸¸ä½¿ç”¨IPCï¼Œå¦‚Android Binderã€‚\nOptimize synchronous IPC ä¸€èˆ¬IPCè¿‡ç¨‹éœ€è¦ç»è¿‡å†…æ ¸ï¼Œè¿™ä¸ªè¿‡ç¨‹éœ€è¦ä¿å­˜ç”¨æˆ·æ€çŠ¶æ€ï¼Œå½“é€€å‡ºå†…æ ¸æ—¶è¿˜éœ€æ¢å¤ç”¨æˆ·çŠ¶æ€ã€‚å› ä¸ºæ¯ä¸ªè¿›ç¨‹éƒ½åœ¨è‡ªå·±çš„è™šæ‹Ÿåœ°å€ç©ºé—´ä¸­ï¼ŒIPCè¿‡ç¨‹è¿˜éœ€è¦åˆ‡æ¢è™šæ‹Ÿåœ°å€ç©ºé—´ã€‚å¦å¤–è¿˜æœ‰ä¸€äº›é€»è¾‘éœ€è¦å¤„ç†ã€‚è¿™äº›éƒ½å¯¼è‡´IPCæœ‰è¾ƒé«˜çš„å»¶è¿Ÿã€‚\nseL4ç”¨fastpathé™ä½IPCå»¶è¿Ÿï¼Œæ¶ˆæ¯ä¼šè¢«ç«‹å³å‘é€ï¼Œè®©kernelç›´æ¥åˆ‡æ¢åˆ°serverè¿›ç¨‹é¿å…äº†è°ƒåº¦å™¨ï¼Œå› æ­¤å¯ä»¥æå‡IPCæ€§èƒ½ã€‚ä½†æ˜¯ä¹Ÿæ— æ³•é¿å…kernelã€‚\nå¦ä¸€æ–¹é¢å½“ä¼ é€’çš„æ¶ˆæ¯è¾ƒå¤§æ—¶ï¼ŒIPCä¸€èˆ¬éœ€è¦å°†æ¶ˆæ¯å¤åˆ¶åˆ°å†…æ ¸ï¼Œå†ä»å†…æ ¸å¤åˆ¶åˆ°å¦ä¸€ä¸ªè¿›ç¨‹ã€‚æˆ–è€…ä½¿ç”¨å…±äº«å†…å­˜ï¼Œå‡å°‘ä¸€æ¬¡å¤åˆ¶ã€‚\nåœ¨seL4ä¸Šæµ‹è¯•è´Ÿè½½ï¼ŒIPCå ç”¨çš„æ—¶é—´æ˜¯å¾ˆå¤šçš„ã€‚\nSkyBridge ä¸ºäº†æé«˜IPCæ€§èƒ½ï¼ŒSkyBridgeæƒ³æ³•æ˜¯IPCä¸ç»è¿‡kernel,senderå¯ä»¥ç›´æ¥è°ƒç”¨receiverçš„procedureã€‚ä¸è¿›è¿‡kernelå¦‚ä½•è°ƒç”¨receiverå‘¢ï¼Ÿä¼¼ä¹éœ€è¦ä¸€ä¸ªæ–°çš„æ¨¡å—å®Œæˆè¿™ä¸ªåŠŸèƒ½ï¼ŒSkyBridgeåˆ©ç”¨Intelä¸ºè™šæ‹ŸåŒ–æä¾›çš„ç¡¬ä»¶ï¼ŒEPT(extended page table) åˆ‡æ¢ï¼Œå…è®¸åœ¨ç”¨æˆ·æ€ä¸‹åˆ‡æ¢EPTï¼Œè¿™æ ·å°±å¯ä»¥å®ç°åœ¨ç”¨æˆ·æ€ä¸‹åˆ‡æ¢è™šæ‹Ÿåœ°å€ç©ºé—´ã€‚\nä½†æ˜¯ä¸ºäº†åˆ©ç”¨EPTåˆ‡æ¢ï¼Œå°±éœ€è¦åœ¨å¢åŠ ä¸€ä¸ªhypervisorã€‚ï¼ˆæœ‰å¯èƒ½ä¼šå½±å“æ€§èƒ½ï¼‰\nåœ¨è™šæ‹Ÿæœºä¸­è¿è¡Œçš„è¿›ç¨‹ï¼Œå¦‚æœè¦è®¿é—®å†…å­˜ä¼šç»è¿‡\nGVA(Guest virtual address)â¡GPA(Guest physical address)â¡HPA(Host physical address)\nè¿™æ ·çš„ä¸¤çº§åœ°å€è½¬æ¢ï¼Œç»è¿‡Guesté¡µè¡¨å¾—åˆ°GPAï¼Œå†ç»è¿‡EPTå¾—åˆ°HPA\nåŒæ—¶SkyBridgeä¸­çš„æ¯ä¸ªè¿›ç¨‹éƒ½åœ¨è‡ªå·±çš„è™šæ‹Ÿç©ºé—´ä¸­ï¼Œå½¼æ­¤ä¹‹é—´ç›¸äº’éš”ç¦»ã€‚å¦‚æœé€šè¿‡å°†è¿›ç¨‹æ”¾åœ¨åŒä¸€ä¸ªè™šæ‹Ÿç©ºé—´ï¼Œç„¶åç”¨EPTå°†ä»–ä»¬éš”ç¦»ï¼Œè¿™æ ·çš„è¯å½“è¿›ç¨‹æ•°å¾ˆå¤šçš„æ—¶å€™å°±ä¼šæ¯”è¾ƒå¤æ‚ã€‚\nä»ä¸Šå›¾å¯ä»¥çœ‹åˆ°SkyBridgeçš„ä¸¤ä¸ªkernelï¼šRootKernel( a tiny hypervisor)å’ŒSubKernel(å³microkernel)ã€‚\né¦–å…ˆserveråœ¨kernelä¸­æ³¨å†Œã€‚kernelä¼šå§trapoline-relatedä»£ç å’Œæ•°æ®æ˜ å°„åˆ°serverçš„è™šæ‹Ÿç©ºé—´ï¼Œå¹¶è¿”å›ä¸€ä¸ªIDç”¨æ¥ç»™clientè°ƒç”¨ã€‚clientå‘kernelæ³¨å†Œæ—¶æä¾›1server ID,kernelåŒæ ·å°†ä»£ç å’Œæ•°æ®æ˜ å°„åˆ°ä»–çš„è™šæ‹Ÿç©ºé—´ã€‚\nSubkernelè°ƒç”¨Rootkernelçš„å€Ÿå£è®©serverå’Œclientåœ¨EPT levelä¸Šç»‘å®šï¼Œkernelä¼šä¸ºclientå’Œserveré…ç½®EPTã€‚é…ç½®serverçš„EPTæ—¶ï¼ŒSkyBridgeæŠŠclientçš„é¡µè¡¨æ˜ å°„åˆ°ç›¸åº”serverçš„é¡µè¡¨ã€‚clientè°ƒç”¨direct_server_callï¼Œåˆ‡æ¢è‡³serverçš„EPTåä½¿ç”¨serverçš„é¡µè¡¨ç¿»è¯‘åç»­çš„åœ°å€ã€‚trapolineä»£ç å®‰è£…serverçš„stack,è°ƒç”¨handlerã€‚\nåœ¨æ‰§è¡Œè¿‡ç¨‹ä¸­ï¼Œclientçš„CR3(é¡µè¡¨åœ°å€)ä¸ä¼šå‘ç”Ÿæ”¹å˜ï¼ŒSkyBridgeå°†client CR3çš„HPAæ˜ å°„ä¸ºserver C3çš„HPAï¼Œè¿™æ ·å°±ç›¸å½“äºåˆ‡æ¢åˆ°äº†serverçš„ç©ºé—´ã€‚\nsomething else RootKernel \u0026amp; è™šæ‹ŸåŒ–å¼€é”€ï¼ŒRootkernelåªæä¾›æœ€åŸºæœ¬çš„åŠŸèƒ½ï¼ŒåŒæ—¶ä¸ºäº†é™ä½VM exitï¼ŒRootkernelå…è®¸åƒæ›´æ”¹CR3çš„æŒ‡ä»¤ä¸è§¦å‘VM exitã€è®©å¤–éƒ¨ä¸­æ–­ç›´æ¥åˆ°microkernelå¤„ç†ã€‚ä¸ºäº†è§£å†³EPT violationï¼ŒRootkernelç”¨1GBçš„é¡µï¼ŒæŠŠå¤§éƒ¨åˆ†hostç‰©ç†å†…å­˜æ˜ å°„åˆ°microkernelï¼ˆé™¤äº†Rootkernelä¿ç•™çš„éƒ¨åˆ†ï¼Œå¤§æ¦‚100MBï¼‰ã€‚è¿™æ ·microkernelè®¿é—®ç‰©ç†åœ°å€æ—¶ï¼Œå°±ä¸ä¼šæœ‰EPT iolationã€‚è¿™æ ·ä¸ä»…é™ä½äº†å¤„ç†TLB missçš„æ—¶é—´ï¼Œä¹Ÿé™ä½äº†TLS missçš„æ¬¡æ•°ã€‚\nillegal VMFUNCï¼Œå¯èƒ½ä¼šå¯¼è‡´ä¸€äº›å®‰å…¨é—®é¢˜ã€‚SkyBrdigeçš„æ–¹æ³•æ˜¯åŠŸèƒ½ç›¸åŒçš„æŒ‡ä»¤æ›¿æ¢ä¹‹å‰çš„æŒ‡ä»¤ã€‚\nXPC ä½†æ˜¯SkyBridgeéœ€è¦å·¥ä½œåœ¨è™šæ‹ŸåŒ–ç¯å¢ƒä¸­ï¼Œè€Œä¸”å½“å‡ºç°è°ƒç”¨é“¾çš„æ—¶å€™ï¼ˆe.g., A$\\rightarrow$B$\\rightarrow$Cï¼‰è¿™æ ·å‡ºç°æ¶ˆæ¯è¢«å¤šæ¬¡å¤åˆ¶çš„æƒ…å†µã€‚\nXPCä»ä¸¤ä¸ªæ–¹é¢æé«˜IPCæ€§èƒ½ï¼Œ\nè®©IPCä¸ç»è¿‡kernel ä¸å¤åˆ¶ä¼ é€’æ¶ˆæ¯ å’ŒSkyBridgeä¸€æ ·XPCä¹Ÿå±äºç¡¬ä»¶ä¼˜åŒ–IPCï¼ŒSkyBridgeé€šè¿‡VMFUNC, XPCåˆ™é€šè¿‡åœ¨æ–°çš„ç¡¬ä»¶ï¼ŒXPC engineã€‚XPC engineæä¾›äº†IPCçš„åŸºæœ¬åŠŸèƒ½ï¼Œå¦‚capabilityæ£€æŸ¥ã€ä¸Šä¸‹æ–‡åˆ‡æ¢ã€é«˜æ•ˆè½»é‡çº§çš„æ¶ˆæ¯ä¼ é€’æœºåˆ¶(relay-seg)ã€‚\nXPC engineæä¾›äº†ä¸¤ä¸ªç¡¬ä»¶åŸè¯­ï¼šUser-level Cross Process Callï¼ŒLightweight Message Transfer\nCross Procss Call x-entry, å’Œå…¶ä»–è¿›ç¨‹çš„procedureç»‘å®šã€‚æ¯ä¸ªè¿›ç¨‹å¯ä»¥åˆ›å»ºå¤šä¸ªx-entry,æ‰€æœ‰çš„x-entryéƒ½å­˜åœ¨x-entry-tableï¼ˆx-entry-table-regæŒ‡å‘çš„ä¸€ä¸ªå…¨å±€å†…å­˜ç©ºé—´ï¼‰ä¸­ã€‚é€šè¿‡x-entry-table-sizeæ§åˆ¶x-entry-tableçš„å¤§å°ã€‚xcall-cap(XPC call capability)è®°å½•æ¯ä¸ªentryçš„capabilityã€‚\nlink stack \u0026amp; linkage record, linkage recordç”¨æ¥ç»´æŠ¤è°ƒç”¨æ—¶çš„ä¿¡æ¯ï¼Œå­˜åœ¨link stackä¸­ã€‚link stackæ˜¯å­˜åœ¨link-regæŒ‡å‘çš„è¿›ç¨‹å†…å­˜ä¸­ã€‚å¯ä»¥è€ƒè™‘ä½¿ç”¨éé˜»å¡çš„æ–¹æ³•ä¼˜åŒ–å‹æ ˆï¼Œå‡å°‘å»¶è¿Ÿã€‚\nx-call, ç”¨æ¥è°ƒåœ¨ç”¨ä¸€ä¸ªx-entryã€‚XPC engineå»æ£€æŸ¥callerçš„xcall-capã€åŠ è½½x-entryå¹¶æ£€æŸ¥ã€åœ¨link stackä¸­å‹å…¥linkage recordã€åŠ è½½æ–°çš„é¡µè¡¨æŒ‡é’ˆã€‚\nx-reg, ä»link stackä¸­å¼¹å‡ºä¸€ä¸ªrecord,è¿”å›ä¹‹å‰çš„è¿›ç¨‹ã€‚CPUä¼šé¦–å…ˆæ£€æŸ¥linkage recordä¸­çš„æœ‰æ•ˆä½ï¼Œç„¶åæ¢å¤callerã€‚\nXPC Engine Cache, å¯ä»¥ç”¨cacheä¼˜åŒ–XPC engineå–x-entryå’Œcapabilityã€‚å› ä¸ºå¯¹å•çº¿ç¨‹IPCå…·æœ‰é«˜å±€éƒ¨æ€§ã€IPCæ˜¯å¯é¢„æµ‹çš„ã€‚\nRelay Segment relay-seg, æœ‰å››ä¸ªå­—æ®µï¼Œè™šåœ°å€åŸºå€ã€ç‰©ç†åœ°å€åŸºå€ã€é•¿åº¦ã€æƒé™ã€‚åœ°å€ç¿»è¯‘æ—¶ï¼Œseg-regçš„æ¯”é¡µè¡¨æœ‰æ›´é«˜çš„ä¼˜å…ˆçº§ã€‚\nseg-mask, è™½ç„¶ä¸èƒ½æ”¹å˜seg-regçš„æ˜ å°„ï¼Œä½†æ˜¯å¯ä»¥é€šè¿‡seg-maskç¼©å°relay-seg\nseg-list-reg, å­˜æ”¾seg-regçš„åˆ—è¡¨ï¼Œå­˜æ”¾åœ¨è¿›ç¨‹å†…å­˜ã€‚ä¸€ä¸ªè¿›ç¨‹å¯ä»¥åˆ›å»ºå¤šä¸ªrelay-segã€‚å¯ä»¥é€šè¿‡swapseg #regåˆ‡æ¢seg-reg\næ¯ä¸ªæ—¶åˆ»æ¯ä¸ªrelay-segåªèƒ½æœ‰ä¸€ä¸ªçº¿ç¨‹æ‰€æœ‰ï¼ŒåŒä¸€ä¸ªæ—¶åˆ»åªèƒ½æœ‰ä¸€ä¸ªæ ¸å¯¹relay-regè¿›è¡Œæ“ä½œï¼Œä¸ç„¶æœ‰ä¼šå¯¼è‡´TOCTTOCæ”»å‡»ã€‚\nåœ¨x-retæ—¶ï¼Œseg-regéœ€è¦å’Œè°ƒç”¨æ—¶ä¸€æ ·ï¼Œå› ä¸ºæœ‰å¯èƒ½æ¶æ„çš„ç¨‹åºä¼šå»ä¿®æ”¹seg-regã€‚\nReference\n[1] Mi, Zeyu, et al. \u0026ldquo;Skybridge: Fast and secure inter-process communication for microkernels.\u0026rdquo; Proceedings of the Fourteenth EuroSys Conference 2019. 2019.\n[2] Du, Dong, et al. \u0026ldquo;Xpc: Architectural support for secure and efficient cross process call.\u0026rdquo; Proceedings of the 46th International Symposium on Computer Architecture. 2019.\n[3] KVMç¡¬ä»¶è¾…åŠ©è™šæ‹ŸåŒ–ä¹‹ EPT(Extended Page Table)\n","permalink":"https://Anlarry.github.io/posts/paper-reading/skybridge-xpc/","summary":"Inter-Process Communication å¾®å†…æ ¸ç›¸æ¯”ä¸å®å†…æ ¸ï¼Œå…·æœ‰æ›´å¥½çš„æ‰©å±•æ€§ã€å®‰å…¨æ€§ï¼Œä¹Ÿèƒ½å¤Ÿæ›´å¥½åœ°å®¹å¿é”™è¯¯ã€‚ä½†æ˜¯å¾®å†…æ ¸åªä¿ç•™å¾ˆåŸºæœ¬çš„åŠŸèƒ½ï¼Œå¾ˆå¤šæœåŠ¡éƒ½ä½œä¸ºä¸€ä¸ªç”¨æˆ·è¿›ç¨‹å­˜åœ¨ï¼Œè¿›ç¨‹ä¹‹é—´å¤§é‡ä½¿ç”¨IPCä¼ é€’æ¶ˆæ¯ã€‚\nå¦å¤–åœ¨å®å†…æ ¸ä¸­ä¹Ÿä¼šç»å¸¸ä½¿ç”¨IPCï¼Œå¦‚Android Binderã€‚\nOptimize synchronous IPC ä¸€èˆ¬IPCè¿‡ç¨‹éœ€è¦ç»è¿‡å†…æ ¸ï¼Œè¿™ä¸ªè¿‡ç¨‹éœ€è¦ä¿å­˜ç”¨æˆ·æ€çŠ¶æ€ï¼Œå½“é€€å‡ºå†…æ ¸æ—¶è¿˜éœ€æ¢å¤ç”¨æˆ·çŠ¶æ€ã€‚å› ä¸ºæ¯ä¸ªè¿›ç¨‹éƒ½åœ¨è‡ªå·±çš„è™šæ‹Ÿåœ°å€ç©ºé—´ä¸­ï¼ŒIPCè¿‡ç¨‹è¿˜éœ€è¦åˆ‡æ¢è™šæ‹Ÿåœ°å€ç©ºé—´ã€‚å¦å¤–è¿˜æœ‰ä¸€äº›é€»è¾‘éœ€è¦å¤„ç†ã€‚è¿™äº›éƒ½å¯¼è‡´IPCæœ‰è¾ƒé«˜çš„å»¶è¿Ÿã€‚\nseL4ç”¨fastpathé™ä½IPCå»¶è¿Ÿï¼Œæ¶ˆæ¯ä¼šè¢«ç«‹å³å‘é€ï¼Œè®©kernelç›´æ¥åˆ‡æ¢åˆ°serverè¿›ç¨‹é¿å…äº†è°ƒåº¦å™¨ï¼Œå› æ­¤å¯ä»¥æå‡IPCæ€§èƒ½ã€‚ä½†æ˜¯ä¹Ÿæ— æ³•é¿å…kernelã€‚\nå¦ä¸€æ–¹é¢å½“ä¼ é€’çš„æ¶ˆæ¯è¾ƒå¤§æ—¶ï¼ŒIPCä¸€èˆ¬éœ€è¦å°†æ¶ˆæ¯å¤åˆ¶åˆ°å†…æ ¸ï¼Œå†ä»å†…æ ¸å¤åˆ¶åˆ°å¦ä¸€ä¸ªè¿›ç¨‹ã€‚æˆ–è€…ä½¿ç”¨å…±äº«å†…å­˜ï¼Œå‡å°‘ä¸€æ¬¡å¤åˆ¶ã€‚\nåœ¨seL4ä¸Šæµ‹è¯•è´Ÿè½½ï¼ŒIPCå ç”¨çš„æ—¶é—´æ˜¯å¾ˆå¤šçš„ã€‚\nSkyBridge ä¸ºäº†æé«˜IPCæ€§èƒ½ï¼ŒSkyBridgeæƒ³æ³•æ˜¯IPCä¸ç»è¿‡kernel,senderå¯ä»¥ç›´æ¥è°ƒç”¨receiverçš„procedureã€‚ä¸è¿›è¿‡kernelå¦‚ä½•è°ƒç”¨receiverå‘¢ï¼Ÿä¼¼ä¹éœ€è¦ä¸€ä¸ªæ–°çš„æ¨¡å—å®Œæˆè¿™ä¸ªåŠŸèƒ½ï¼ŒSkyBridgeåˆ©ç”¨Intelä¸ºè™šæ‹ŸåŒ–æä¾›çš„ç¡¬ä»¶ï¼ŒEPT(extended page table) åˆ‡æ¢ï¼Œå…è®¸åœ¨ç”¨æˆ·æ€ä¸‹åˆ‡æ¢EPTï¼Œè¿™æ ·å°±å¯ä»¥å®ç°åœ¨ç”¨æˆ·æ€ä¸‹åˆ‡æ¢è™šæ‹Ÿåœ°å€ç©ºé—´ã€‚\nä½†æ˜¯ä¸ºäº†åˆ©ç”¨EPTåˆ‡æ¢ï¼Œå°±éœ€è¦åœ¨å¢åŠ ä¸€ä¸ªhypervisorã€‚ï¼ˆæœ‰å¯èƒ½ä¼šå½±å“æ€§èƒ½ï¼‰\nåœ¨è™šæ‹Ÿæœºä¸­è¿è¡Œçš„è¿›ç¨‹ï¼Œå¦‚æœè¦è®¿é—®å†…å­˜ä¼šç»è¿‡\nGVA(Guest virtual address)â¡GPA(Guest physical address)â¡HPA(Host physical address)\nè¿™æ ·çš„ä¸¤çº§åœ°å€è½¬æ¢ï¼Œç»è¿‡Guesté¡µè¡¨å¾—åˆ°GPAï¼Œå†ç»è¿‡EPTå¾—åˆ°HPA\nåŒæ—¶SkyBridgeä¸­çš„æ¯ä¸ªè¿›ç¨‹éƒ½åœ¨è‡ªå·±çš„è™šæ‹Ÿç©ºé—´ä¸­ï¼Œå½¼æ­¤ä¹‹é—´ç›¸äº’éš”ç¦»ã€‚å¦‚æœé€šè¿‡å°†è¿›ç¨‹æ”¾åœ¨åŒä¸€ä¸ªè™šæ‹Ÿç©ºé—´ï¼Œç„¶åç”¨EPTå°†ä»–ä»¬éš”ç¦»ï¼Œè¿™æ ·çš„è¯å½“è¿›ç¨‹æ•°å¾ˆå¤šçš„æ—¶å€™å°±ä¼šæ¯”è¾ƒå¤æ‚ã€‚\nä»ä¸Šå›¾å¯ä»¥çœ‹åˆ°SkyBridgeçš„ä¸¤ä¸ªkernelï¼šRootKernel( a tiny hypervisor)å’ŒSubKernel(å³microkernel)ã€‚\né¦–å…ˆserveråœ¨kernelä¸­æ³¨å†Œã€‚kernelä¼šå§trapoline-relatedä»£ç å’Œæ•°æ®æ˜ å°„åˆ°serverçš„è™šæ‹Ÿç©ºé—´ï¼Œå¹¶è¿”å›ä¸€ä¸ªIDç”¨æ¥ç»™clientè°ƒç”¨ã€‚clientå‘kernelæ³¨å†Œæ—¶æä¾›1server ID,kernelåŒæ ·å°†ä»£ç å’Œæ•°æ®æ˜ å°„åˆ°ä»–çš„è™šæ‹Ÿç©ºé—´ã€‚\nSubkernelè°ƒç”¨Rootkernelçš„å€Ÿå£è®©serverå’Œclientåœ¨EPT levelä¸Šç»‘å®šï¼Œkernelä¼šä¸ºclientå’Œserveré…ç½®EPTã€‚é…ç½®serverçš„EPTæ—¶ï¼ŒSkyBridgeæŠŠclientçš„é¡µè¡¨æ˜ å°„åˆ°ç›¸åº”serverçš„é¡µè¡¨ã€‚clientè°ƒç”¨direct_server_callï¼Œåˆ‡æ¢è‡³serverçš„EPTåä½¿ç”¨serverçš„é¡µè¡¨ç¿»è¯‘åç»­çš„åœ°å€ã€‚trapolineä»£ç å®‰è£…serverçš„stack,è°ƒç”¨handlerã€‚\nåœ¨æ‰§è¡Œè¿‡ç¨‹ä¸­ï¼Œclientçš„CR3(é¡µè¡¨åœ°å€)ä¸ä¼šå‘ç”Ÿæ”¹å˜ï¼ŒSkyBridgeå°†client CR3çš„HPAæ˜ å°„ä¸ºserver C3çš„HPAï¼Œè¿™æ ·å°±ç›¸å½“äºåˆ‡æ¢åˆ°äº†serverçš„ç©ºé—´ã€‚\nsomething else RootKernel \u0026amp; è™šæ‹ŸåŒ–å¼€é”€ï¼ŒRootkernelåªæä¾›æœ€åŸºæœ¬çš„åŠŸèƒ½ï¼ŒåŒæ—¶ä¸ºäº†é™ä½VM exitï¼ŒRootkernelå…è®¸åƒæ›´æ”¹CR3çš„æŒ‡ä»¤ä¸è§¦å‘VM exitã€è®©å¤–éƒ¨ä¸­æ–­ç›´æ¥åˆ°microkernelå¤„ç†ã€‚ä¸ºäº†è§£å†³EPT violationï¼ŒRootkernelç”¨1GBçš„é¡µï¼ŒæŠŠå¤§éƒ¨åˆ†hostç‰©ç†å†…å­˜æ˜ å°„åˆ°microkernelï¼ˆé™¤äº†Rootkernelä¿ç•™çš„éƒ¨åˆ†ï¼Œå¤§æ¦‚100MBï¼‰ã€‚è¿™æ ·microkernelè®¿é—®ç‰©ç†åœ°å€æ—¶ï¼Œå°±ä¸ä¼šæœ‰EPT iolationã€‚è¿™æ ·ä¸ä»…é™ä½äº†å¤„ç†TLB missçš„æ—¶é—´ï¼Œä¹Ÿé™ä½äº†TLS missçš„æ¬¡æ•°ã€‚\nillegal VMFUNCï¼Œå¯èƒ½ä¼šå¯¼è‡´ä¸€äº›å®‰å…¨é—®é¢˜ã€‚SkyBrdigeçš„æ–¹æ³•æ˜¯åŠŸèƒ½ç›¸åŒçš„æŒ‡ä»¤æ›¿æ¢ä¹‹å‰çš„æŒ‡ä»¤ã€‚\nXPC ä½†æ˜¯SkyBridgeéœ€è¦å·¥ä½œåœ¨è™šæ‹ŸåŒ–ç¯å¢ƒä¸­ï¼Œè€Œä¸”å½“å‡ºç°è°ƒç”¨é“¾çš„æ—¶å€™ï¼ˆe.g., A$\\rightarrow$B$\\rightarrow$Cï¼‰è¿™æ ·å‡ºç°æ¶ˆæ¯è¢«å¤šæ¬¡å¤åˆ¶çš„æƒ…å†µã€‚\nXPCä»ä¸¤ä¸ªæ–¹é¢æé«˜IPCæ€§èƒ½ï¼Œ\nè®©IPCä¸ç»è¿‡kernel ä¸å¤åˆ¶ä¼ é€’æ¶ˆæ¯ å’ŒSkyBridgeä¸€æ ·XPCä¹Ÿå±äºç¡¬ä»¶ä¼˜åŒ–IPCï¼ŒSkyBridgeé€šè¿‡VMFUNC, XPCåˆ™é€šè¿‡åœ¨æ–°çš„ç¡¬ä»¶ï¼ŒXPC engineã€‚XPC engineæä¾›äº†IPCçš„åŸºæœ¬åŠŸèƒ½ï¼Œå¦‚capabilityæ£€æŸ¥ã€ä¸Šä¸‹æ–‡åˆ‡æ¢ã€é«˜æ•ˆè½»é‡çº§çš„æ¶ˆæ¯ä¼ é€’æœºåˆ¶(relay-seg)ã€‚\nXPC engineæä¾›äº†ä¸¤ä¸ªç¡¬ä»¶åŸè¯­ï¼šUser-level Cross Process Callï¼ŒLightweight Message Transfer\nCross Procss Call x-entry, å’Œå…¶ä»–è¿›ç¨‹çš„procedureç»‘å®šã€‚æ¯ä¸ªè¿›ç¨‹å¯ä»¥åˆ›å»ºå¤šä¸ªx-entry,æ‰€æœ‰çš„x-entryéƒ½å­˜åœ¨x-entry-tableï¼ˆx-entry-table-regæŒ‡å‘çš„ä¸€ä¸ªå…¨å±€å†…å­˜ç©ºé—´ï¼‰ä¸­ã€‚é€šè¿‡x-entry-table-sizeæ§åˆ¶x-entry-tableçš„å¤§å°ã€‚xcall-cap(XPC call capability)è®°å½•æ¯ä¸ªentryçš„capabilityã€‚","title":"SkyBridge \u0026 XPC"},{"content":"Codeforces Round #664 https://codeforces.com/contest/1395\nA é¢˜æ„\nç»™å››ç§é¢œè‰²çš„çƒï¼Œå¯ä»¥æŠŠä¸€ä¸ªçº¢è‰²ä¸€ä¸ªè“è‰²ä¸€ä¸ªç»¿è‰²æŸ“æˆç™½è‰²ï¼Œé—®èƒ½ä¸èƒ½å˜æˆå›æ–‡ä¸²\n#include \u0026lt;cstdio\u0026gt; #include \u0026lt;stack\u0026gt; #include \u0026lt;set\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;map\u0026gt; #include \u0026lt;time.h\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; //#include \u0026lt;memory.h\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;iomanip\u0026gt; #include \u0026lt;cassert\u0026gt; #include \u0026lt;unordered_map\u0026gt; #define P pair\u0026lt;int, int\u0026gt; #define LL long long #define LD long double #define PLL pair\u0026lt;LL, LL\u0026gt; #define mset(a, b) memset(a, b, sizeof(a)) #define rep(i, a, b) for (int i = a; i \u0026lt; b; i++) #define PI acos(-1.0) #define random(x) rand() % x #define debug(x) cout \u0026lt;\u0026lt; #x \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34; using namespace std; const int inf = 0x3f3f3f3f; const LL __64inf = 0x3f3f3f3f3f3f3f3f; #ifdef DEBUG const int MAX = 2e3 + 50; #else const int MAX = 2e6 + 500; #endif const int mod = 1e9 + 7; void file_read() { #ifdef DEBUG freopen(\u0026#34;in\u0026#34;, \u0026#34;r\u0026#34;, stdin); // freopen(\u0026#34;out\u0026#34;, \u0026#34;w\u0026#34;, stdout); #endif } int main() { file_read(); int T; LL a, b, c, d; scanf(\u0026#34;%d\u0026#34;, \u0026amp;T); while (T--) { cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; c \u0026gt;\u0026gt; d; LL tot = a + b + c + d; if(tot \u0026amp; 1) { int odd = (a \u0026amp; 1) + (b \u0026amp; 1) + (c \u0026amp; 1) + (d \u0026amp; 1); if(odd == 1) { puts(\u0026#34;Yes\u0026#34;); continue; } if(a \u0026gt; 0 and b \u0026gt; 0 and c \u0026gt; 0) { a--, b--, c--, d+=3; odd = (a \u0026amp; 1) + (b \u0026amp; 1) + (c \u0026amp; 1) + (d \u0026amp; 1); if(odd == 1) { puts(\u0026#34;Yes\u0026#34;); continue; } } puts(\u0026#34;No\u0026#34;); continue; }\telse { int odd = (a \u0026amp; 1) + (b \u0026amp; 1) + (c \u0026amp; 1) + (d \u0026amp; 1); if(odd == 0 ) { puts(\u0026#34;Yes\u0026#34;); continue; } if(a \u0026gt; 0 and b \u0026gt; 0 and c \u0026gt; 0 and d \u0026gt; 0) { a--, b--, c--, d += 3; odd = (a \u0026amp; 1) + (b \u0026amp; 1) + (c \u0026amp; 1) + (d \u0026amp; 1); if(odd == 0) { puts(\u0026#34;Yes\u0026#34;); continue; } }\tputs(\u0026#34;No\u0026#34;); } } return 0; } B é¢˜æ„\nåœ¨æ£‹ç›˜ä¸Šèµ°ï¼Œç±»ä¼¼äºè½¦ï¼Œæ±‚éå†æ‰€æœ‰æ ¼å­ä¸€æ¬¡çš„æ–¹æ¡ˆ\n#include \u0026lt;cstdio\u0026gt; #include \u0026lt;stack\u0026gt; #include \u0026lt;set\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;map\u0026gt; #include \u0026lt;time.h\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; //#include \u0026lt;memory.h\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;iomanip\u0026gt; #include \u0026lt;cassert\u0026gt; #include \u0026lt;unordered_map\u0026gt; #define P pair\u0026lt;int, int\u0026gt; #define LL long long #define LD long double #define PLL pair\u0026lt;LL, LL\u0026gt; #define mset(a, b) memset(a, b, sizeof(a)) #define rep(i, a, b) for (int i = a; i \u0026lt; b; i++) #define PI acos(-1.0) #define random(x) rand() % x #define debug(x) cout \u0026lt;\u0026lt; #x \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34; using namespace std; const int inf = 0x3f3f3f3f; const LL __64inf = 0x3f3f3f3f3f3f3f3f; #ifdef DEBUG const int MAX = 2e3 + 50; #else const int MAX = 2e6 + 500; #endif const int mod = 1e9 + 7; void file_read() { #ifdef DEBUG freopen(\u0026#34;in\u0026#34;, \u0026#34;r\u0026#34;, stdin); // freopen(\u0026#34;out\u0026#34;, \u0026#34;w\u0026#34;, stdout); #endif } void print(int x, int y) { printf(\u0026#34;%d %d\\n\u0026#34;, x, y); } bool vis[105][105]; int main() { file_read(); int n, m, x, y; int X, Y; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y; X = x, Y = y; print(x, y--); while(y \u0026gt;= 1) { print(x, y--); } y = Y+1; while(y \u0026lt;= m) { print(x, y++); } y = m; for(int i = x-1; i \u0026gt;= 1; i--) { if(y == m){ for(; y \u0026gt;= 1; y--) print(i, y); y = 1; } else if(y == 1) { for(; y \u0026lt;= m; y++) print(i, y); y = m; } } for(int i = x+1; i \u0026lt;= n; i++) { if(y == m){ for(; y \u0026gt;= 1; y--) print(i, y); y = 1; } else if(y == 1) { for(; y \u0026lt;= m; y++) print(i, y); y = m; } } return 0; } C é¢˜æ„\nç»™ä¸¤ä¸ªåºåˆ—$a$,$b$, å¯¹æ¯ä¸ª$a_i$å¯ä»¥é€‰æ‹©ä¸€ä¸ª$b_j$,$c_i=a_i \u0026amp; b_j$,æ±‚æœ€å°çš„$c_1|c_2|\\dots|c_n$\nSolution\nä»é«˜ä½åˆ°ä½ä½ï¼Œä½¿å¾—æ¯ä¸€ä½å°½å¯èƒ½ä¸º0ï¼Œç»´æŠ¤å¯¹äºæ¯ä¸ª$a_i$,å¯ä»¥ç”¨çš„$b_j$\n#include \u0026lt;cstdio\u0026gt; #include \u0026lt;stack\u0026gt; #include \u0026lt;set\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;map\u0026gt; #include \u0026lt;time.h\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; //#include \u0026lt;memory.h\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;iomanip\u0026gt; #include \u0026lt;cassert\u0026gt; #include \u0026lt;unordered_map\u0026gt; #define P pair\u0026lt;int, int\u0026gt; #define LL long long #define LD long double #define PLL pair\u0026lt;LL, LL\u0026gt; #define mset(a, b) memset(a, b, sizeof(a)) #define rep(i, a, b) for (int i = a; i \u0026lt; b; i++) #define PI acos(-1.0) #define random(x) rand() % x #define debug(x) cout \u0026lt;\u0026lt; #x \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34; using namespace std; const int inf = 0x3f3f3f3f; const LL __64inf = 0x3f3f3f3f3f3f3f3f; #ifdef DEBUG const int MAX = 2e3 + 50; #else const int MAX = 2e6 + 500; #endif const int mod = 1e9 + 7; void file_read() { #ifdef DEBUG freopen(\u0026#34;in\u0026#34;, \u0026#34;r\u0026#34;, stdin); // freopen(\u0026#34;out\u0026#34;, \u0026#34;w\u0026#34;, stdout); #endif } int n, m; LL a[MAX], b[MAX]; bool ok[205][205]; bool check(LL x) { bool res = true; for(int i = 1; i \u0026lt;= n; i++) { bool cur = false; for(int j = 1; j \u0026lt;= m; j++) { if(!ok[i][j]) continue; if((a[i] \u0026amp; b[j] \u0026amp; x) == 0) { cur = true; break; } } res \u0026amp;= cur; } if(res) { for(int i = 1; i \u0026lt;= n; i++) { for(int j = 1; j \u0026lt;= m; j++) { if((a[i] \u0026amp; b[j] \u0026amp; x) != 0) { ok[i][j] = false; } } } } return res; } int main() { file_read(); scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); for(int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; a[i]; for(int i = 1; i \u0026lt;= m; i++) cin \u0026gt;\u0026gt; b[i]; LL ans = 0; mset(ok, 1); for(LL i = 32; i \u0026gt;= 0; i--) { if(!check(1LL\u0026lt;\u0026lt;i)) { ans |= (1LL\u0026lt;\u0026lt;i); } } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; return 0; } D é¢˜æ„\nç»™ä»¥åºåˆ—$a$,å¯ä»¥é€‰$n$æ¬¡æ•°å­—ï¼Œå¦‚æœæ•°å­—å¤§äº$m$,é‚£ä¹ˆå$d$æ¬¡å°±ä¸èƒ½é€‰ï¼Œæ±‚é€‰å‡ºçš„æ•°å­—çš„æœ€å¤§å€¼\nSolution\næšä¸¾é€‰çš„æ•°å­—å°äºç­‰äº$m$çš„ä¸ªæ•°ï¼Œå¯ä»¥é€‰æ‹©è¶…è¿‡$m$çš„æ•°å­—å°±æ˜¯å›ºå®šçš„ï¼Œé€‰æ‹©æœ€å¤§çš„\n#include \u0026lt;cstdio\u0026gt; #include \u0026lt;stack\u0026gt; #include \u0026lt;set\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;map\u0026gt; #include \u0026lt;time.h\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; //#include \u0026lt;memory.h\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;iomanip\u0026gt; #include \u0026lt;cassert\u0026gt; #include \u0026lt;unordered_map\u0026gt; #define P pair\u0026lt;int, int\u0026gt; #define LL long long #define LD long double #define PLL pair\u0026lt;LL, LL\u0026gt; #define mset(a, b) memset(a, b, sizeof(a)) #define rep(i, a, b) for (int i = a; i \u0026lt; b; i++) #define PI acos(-1.0) #define random(x) rand() % x #define debug(x) cout \u0026lt;\u0026lt; #x \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34; using namespace std; const int inf = 0x3f3f3f3f; const LL __64inf = 0x3f3f3f3f3f3f3f3f; #ifdef DEBUG const int MAX = 2e3 + 50; #else const int MAX = 2e6 + 500; #endif const int mod = 1e9 + 7; void file_read() { #ifdef DEBUG freopen(\u0026#34;in\u0026#34;, \u0026#34;r\u0026#34;, stdin); // freopen(\u0026#34;out\u0026#34;, \u0026#34;w\u0026#34;, stdout); #endif } LL a[MAX]; LL A[MAX], B[MAX]; LL sa[MAX], sb[MAX]; int main() { file_read(); LL n, d, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; d \u0026gt;\u0026gt; m; for(int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; a[i]; sort(a+1, a+1+n, [](LL x, LL y) { return x \u0026gt; y; }); int tot1 = 0, tot2 = 0; for(int i = 1; i \u0026lt;= n; i++) { if(a[i] \u0026lt;= m) A[++tot1] = a[i]; else B[++tot2] = a[i]; } if(tot1 == 0) { LL nn = (n+d) / (d + 1); LL ans = 0; for(int i = 1; i \u0026lt;= nn; i++) { ans += B[i]; } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; return 0; } if(tot2 == 0) { LL ans = 0; for(int i = 1; i \u0026lt;= n; i++) { ans += A[i]; } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; return 0; } for(int i = 1; i \u0026lt;= tot1; i++) sa[i] = sa[i-1] + A[i]; for(int i = 1; i \u0026lt;= tot2; i++) sb[i] = sb[i-1] + B[i]; LL ans = 0; for(int i = 0; i \u0026lt;= tot1; i++) { LL cur = sa[i]; LL nn = (n-i+d) / (d+1); ans = max(cur+sb[nn], ans); } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; return 0; } E é¢˜æ„\nç»™ä¸€ä¸ªå›¾$G=(V,E)$,é€‰æ‹©ä¸€ä¸ªtuple $(c_1,\\dots, c_k)$ä½œä¸ºéå†å›¾çš„è§„åˆ™ï¼Œå‡ºåº¦ä¸º$i$çš„ç‚¹çš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹æ˜¯ç¬¬$c_i$å°çš„è¾¹æŒ‡å‘çš„ç‚¹ï¼Œé—®æœ‰å¤šå°‘ç§tupleå¯ä»¥æŠŠå›¾éå†ä¸€é\nSolution\nä¸èƒ½å‘ç°å…¶å®æœ€åçš„è·¯å¾„æ˜¯ä¸€ä¸ªç¯ï¼Œå¯ä»¥å¯¹æ¯ä¸ªç‚¹çš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹æ‰€ç»„æˆçš„é›†åˆæ˜¯$V$ï¼Œå› æ­¤å¯ä»¥é€šåˆ¤æ–­è¿‡è¿™æ˜¯å¦æˆç«‹æ¥æ£€æŸ¥ä¸€ä¸ªtuple å¦å¤–å¯ä»¥å°†ç‚¹æŒ‰å‡ºåº¦åˆ†ç±»ï¼Œç»´æŠ¤$S[i][j]$è¡¨ç¤ºå‡ºåº¦ä¸º$i$çš„ç‚¹ï¼Œé€‰ç¬¬$j$å°çš„è¾¹æ‰€åˆ°è¾¾çš„ç‚¹çš„é›†åˆ å¯ä»¥ç”¨hashåˆ¤æ–­é›†åˆæ˜¯å¦ç›¸ç­‰ï¼Œæœ‰å¯èƒ½ä¼šå†²çª #include \u0026lt;cstdio\u0026gt; #include \u0026lt;stack\u0026gt; #include \u0026lt;set\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;map\u0026gt; #include \u0026lt;time.h\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; //#include \u0026lt;memory.h\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;iomanip\u0026gt; #include \u0026lt;cassert\u0026gt; #include \u0026lt;unordered_map\u0026gt; #define P pair\u0026lt;int, int\u0026gt; #define LL long long #define LD long double #define PLL pair\u0026lt;LL, LL\u0026gt; #define mset(a, b) memset(a, b, sizeof(a)) #define rep(i, a, b) for (int i = a; i \u0026lt; b; i++) #define PI acos(-1.0) #define random(x) rand() % x #define debug(x) cout \u0026lt;\u0026lt; #x \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34; using namespace std; const int inf = 0x3f3f3f3f; const LL __64inf = 0x3f3f3f3f3f3f3f3f; #ifdef DEBUG const int MAX = 2e3 + 50; #else const int MAX = 2e6 + 500; #endif const int mod = 1e9 + 7; void file_read() { #ifdef DEBUG freopen(\u0026#34;in\u0026#34;, \u0026#34;r\u0026#34;, stdin); // freopen(\u0026#34;out\u0026#34;, \u0026#34;w\u0026#34;, stdout); #endif } #define ULL unsigned long long const int mod2 = 998244353; vector\u0026lt;P\u0026gt; G[MAX]; ULL s[100][100]; LL g[100][100]; LL t[100][100]; bool vis[MAX]; ULL val[MAX]; ULL TARGET1 = 1; LL TARGET2 = 1; LL TARGET3 = 1; int n, m, k; int ans; void dfs(int u) { vis[u] = 1; for(int i = 0; i \u0026lt; G[u].size(); i++) { int v = G[u][i].first; s[G[u].size()][i+1] *= (ULL)val[v]; g[G[u].size()][i+1] = g[G[u].size()][i+1] * val[v] % mod; t[G[u].size()][i+1] = t[G[u].size()][i+1] * val[v] % mod2; if(vis[v]) continue; dfs(v); } } void dfs2(int x, ULL cur1, LL cur2, LL cur3) { if(x \u0026gt; k) { if(cur1 == TARGET1 and cur2 == TARGET2 and cur3 == TARGET3) ans ++; return ; } for(int i = 1; i \u0026lt;= x; i++) { dfs2(x+1, cur1*s[x][i], cur2*g[x][i]%mod, cur3 * t[x][i] % mod2); } } int main() { srand((int)time(0)); file_read(); for(int i = 0; i \u0026lt; 100; i++) for(int j = 0; j \u0026lt; 100; j++) s[i][j] = g[i][j] = t[i][j] = 1; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;n, \u0026amp;m, \u0026amp;k); for(int i = 1; i \u0026lt;= n; i++) val[i] = rand() % mod; for(ULL i = 1; i \u0026lt;= n; i++) TARGET1 = TARGET1 * val[i], TARGET2 = TARGET2 * val[i] % mod, TARGET3 = TARGET3 * val[i] % mod2; for(int i = 1; i \u0026lt;= m; i++) { int u, v, w; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;u, \u0026amp;v, \u0026amp;w); G[u].push_back({v, w}); } for(int i = 1; i \u0026lt;= n; i++) { sort(G[i].begin(), G[i].end(), [](const P\u0026amp;A, const P\u0026amp;B){ return A.second \u0026lt; B.second; }); } dfs(1); dfs2(1, 1, 1, 1); printf(\u0026#34;%d\\n\u0026#34;, ans); return 0; } F é¢˜æ„\nå®šä¹‰ä¸²åªæœ‰Nå’ŒBï¼Œæœ‰å››ç§æ“ä½œï¼Œç»™$s_1, \\dots, s_n$ï¼Œæ±‚ä¸€ä¸ªä¸²$t$ä½¿å¾—å’Œ$s$çš„æœ€å¤§è·ç¦»æœ€å°\nSolution\nä¸éš¾å‘ç°å­—ç¬¦ä¸²å¯¹åº”ä¸€ä¸ªåæ ‡ï¼Œå¯¹äºä¸€ä¸ª$x,y$å¯ä»¥ç§»åŠ¨ä¸Šä¸‹å·¦å³ï¼Œæˆ–è€…å³ä¸Šï¼Œå·¦ä¸‹ å¯¹äºä¸€ä¸ªç‚¹ï¼Œåœ¨å›ºå®šè·ç¦»å†…å¯ä»¥è®¿é—®çš„ç‚¹æ˜¯ä¸€ä¸ªå…­è¾¹å½¢ è¦æ‰¾ä¸€ä¸ªæœ€å°åŠå¾„çš„å…­è¾¹å½¢è¦†ç›–æ‰€æœ‰çš„ç‚¹ å› æ­¤äºŒåˆ†åŠå¾„ï¼Œè®¡ç®—å…­è¾¹å½¢ä¸­å¿ƒçš„å¯è¡ŒåŒºåŸŸ æœ€ååœ¨å¯è¡ŒåŒºåŸŸé€‰ä¸€ä¸ªä½œä¸º$t$,ä¸èƒ½æ˜¯ç©ºä¸² #include \u0026lt;cstdio\u0026gt; #include \u0026lt;stack\u0026gt; #include \u0026lt;set\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;map\u0026gt; #include \u0026lt;time.h\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; //#include \u0026lt;memory.h\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;iomanip\u0026gt; #include \u0026lt;cassert\u0026gt; #include \u0026lt;unordered_map\u0026gt; #define P pair\u0026lt;int, int\u0026gt; #define LL long long #define LD long double #define PLL pair\u0026lt;LL, LL\u0026gt; #define mset(a, b) memset(a, b, sizeof(a)) #define rep(i, a, b) for (int i = a; i \u0026lt; b; i++) #define PI acos(-1.0) #define random(x) rand() % x #define debug(x) cout \u0026lt;\u0026lt; #x \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34; using namespace std; const int inf = 0x3f3f3f3f; const LL __inf64 = 0x3f3f3f3f3f3f3f3f; #ifdef DEBUG const int MAX = 2e3 + 50; #else const int MAX = 2e6 + 500; #endif const int mod = 1e9 + 7; void file_read() { #ifdef DEBUG freopen(\u0026#34;in\u0026#34;, \u0026#34;r\u0026#34;, stdin); // freopen(\u0026#34;out\u0026#34;, \u0026#34;w\u0026#34;, stdout); #endif } vector\u0026lt;P\u0026gt; pt; int xL, xR, yL, yR, zL, zR; bool check(int mid) { xL = -inf, xR = inf, yL = -inf, yR = inf, zL = -inf, zR = inf; for(auto p : pt) { xL = max(xL, p.first-mid); xR = min(xR, p.first+mid); yL = max(yL, p.second-mid); yR = min(yR, p.second+mid); zL = max(zL, p.first-p.second-mid); zR = min(zR, p.first-p.second+mid); } if(xL \u0026gt; xR || yL \u0026gt; yR || zL \u0026gt; zR) return false; yL = max(yL, xL-zR); yR = min(yR, xR-zL); if(yL \u0026gt; yR) return false; return true; } int main() { file_read(); int n; cin \u0026gt;\u0026gt; n; for(int i = 1; i \u0026lt;= n; i++) { string s; cin \u0026gt;\u0026gt; s; int x = 0, y = 0; for(auto c : s) { if(c == \u0026#39;B\u0026#39;) x++; else y++; } pt.emplace_back(x, y); } int l = 0, r = inf; while(l \u0026lt; r) { int mid = (l + r) \u0026gt;\u0026gt; 1; if(check(mid)) r = mid; else l = mid + 1; } // cout \u0026lt;\u0026lt; check(l) \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; check(l); int ansx, ansy; for(int x = max(0, xL); x \u0026lt;= xR; x++) { int curyL = max(yR, x-zR); int curyR = min(yR, x-zL); if(curyL \u0026gt; curyR) continue; if(x \u0026gt; 0 || curyR \u0026gt; 0) { ansx = x; ansy = curyR; break; }\t} cout \u0026lt;\u0026lt; l \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; while(ansx--) printf(\u0026#34;B\u0026#34;); while(ansy--) printf(\u0026#34;N\u0026#34;); return 0; } ","permalink":"https://Anlarry.github.io/posts/acm-icpc/codeforces-round-664/","summary":"Codeforces Round #664 https://codeforces.com/contest/1395\nA é¢˜æ„\nç»™å››ç§é¢œè‰²çš„çƒï¼Œå¯ä»¥æŠŠä¸€ä¸ªçº¢è‰²ä¸€ä¸ªè“è‰²ä¸€ä¸ªç»¿è‰²æŸ“æˆç™½è‰²ï¼Œé—®èƒ½ä¸èƒ½å˜æˆå›æ–‡ä¸²\n#include \u0026lt;cstdio\u0026gt; #include \u0026lt;stack\u0026gt; #include \u0026lt;set\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;map\u0026gt; #include \u0026lt;time.h\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; //#include \u0026lt;memory.h\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;iomanip\u0026gt; #include \u0026lt;cassert\u0026gt; #include \u0026lt;unordered_map\u0026gt; #define P pair\u0026lt;int, int\u0026gt; #define LL long long #define LD long double #define PLL pair\u0026lt;LL, LL\u0026gt; #define mset(a, b) memset(a, b, sizeof(a)) #define rep(i, a, b) for (int i = a; i \u0026lt; b; i++) #define PI acos(-1.","title":"Codeforces Round #664"},{"content":"Gym - 102501D Gnalcats https://codeforces.com/gym/102501/problem/D\né¢˜æ„ ç»™ä¸¤ç§æ ˆæ“ä½œåˆ¤æ–­æ˜¯å¦ç›¸ç­‰,å¦‚æœä¸¤ä¸ªæ“ä½œéƒ½failï¼Œä¹Ÿè®¤ä¸ºç›¸ç­‰\nSolution æ¨¡æ‹Ÿï¼Œæ¯ä¸ªæ°¨åŸºé…¸ä¸€ä¸ªhashå€¼ã€‚é€šè¿‡åˆ¤æ–­æœ€åæ ˆå…ƒç´ æ˜¯å¦å¯¹åº”hashç›¸ç­‰ï¼Œåˆ¤æ–­æ“ä½œæ˜¯å¦ç›¸ç­‰\n#include \u0026lt;cstdio\u0026gt; #include \u0026lt;stack\u0026gt; #include \u0026lt;set\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;map\u0026gt; #include \u0026lt;time.h\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; //#include \u0026lt;memory.h\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;iomanip\u0026gt; #include \u0026lt;cassert\u0026gt; #include \u0026lt;unordered_map\u0026gt; #define P pair\u0026lt;int, int\u0026gt; #define LL long long #define LD long double #define PLL pair\u0026lt;LL, LL\u0026gt; #define mset(a, b) memset(a, b, sizeof(a)) #define rep(i, a, b) for (int i = a; i \u0026lt; b; i++) #define PI acos(-1.0) #define random(x) rand() % x #define debug(x) cout \u0026lt;\u0026lt; #x \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34; using namespace std; const int inf = 0x3f3f3f3f; const LL __64inf = 0x3f3f3f3f3f3f3f3f; #ifdef DEBUG const int MAX = 2e3 + 50; #else const int MAX = 1e6 + 50; #endif const int mod = 1e9 + 7; void file_read() { #ifdef DEBUG freopen(\u0026#34;in\u0026#34;, \u0026#34;r\u0026#34;, stdin); // freopen(\u0026#34;out\u0026#34;, \u0026#34;w\u0026#34;, stdout); #endif } #define ULL unsigned long long struct DNA { struct Node { int l, r; unsigned LL val; Node(){} Node(int l, int r, unsigned LL val) : l(l), r(r), val(val) {} bool complex() const { return l and r; } }tr[MAX]; stack\u0026lt;int\u0026gt; stk; int tot; int num; DNA() : tot(1), num(1) { for(int i = 1; i \u0026lt;= (int)1e5; i++) { tr[tot] = Node(0, 0, num++); stk.push(tot); tot++; } } ULL hash(int u, int v) { ULL base = 131; return tr[u].val * base + tr[v].val; } bool op_C() { auto u = stk.top(); tr[tot] = tr[u]; stk.push(tot); tot++; return true;\t} bool op_D() { stk.pop(); return true; } bool op_L() { auto u = stk.top(); stk.pop(); if(!tr[u].complex()) return false;\t// tr[tot] = tr[tr[u].l]; // stk.push(tot); stk.push(tr[u].l); return true; } bool op_P() { auto u = stk.top(); stk.pop(); auto v = stk.top(); stk.pop(); tr[tot] = Node(u, v, hash(u, v)); stk.push(tot); tot++; return true; } bool op_R() { auto u = stk.top(); stk.pop(); if(!tr[u].complex()) return false; // tr[tot] = tr[tr[u].r]; // stk.push(tot++); stk.push(tr[u].r); return true; } bool op_S() { auto u = stk.top(); stk.pop(); auto v = stk.top(); stk.pop(); stk.push(u); stk.push(v); return true; } bool op_U() { auto u = stk.top(); stk.pop(); if(!tr[u].complex()) return false; stk.push(tr[u].r); stk.push(tr[u].l); return true; } bool op(const string \u0026amp;s) { bool res = true; for(auto c : s) { switch (c) { case \u0026#39;C\u0026#39;:res \u0026amp;= op_C(); break; case \u0026#39;D\u0026#39;:res \u0026amp;= op_D(); break; case \u0026#39;L\u0026#39;:res \u0026amp;= op_L(); break; case \u0026#39;P\u0026#39;:res \u0026amp;= op_P(); break; case \u0026#39;R\u0026#39;:res \u0026amp;= op_R(); break; case \u0026#39;S\u0026#39;:res \u0026amp;= op_S(); break; case \u0026#39;U\u0026#39;:res \u0026amp;= op_U(); break; default: break; } } return res ; } }; DNA A, B; int main() { file_read(); string s, t; cin \u0026gt;\u0026gt; s \u0026gt;\u0026gt; t; A = DNA(); B = DNA(); bool a = A.op(s); bool b = B.op(t); if(a ^ b) { puts(\u0026#34;False\u0026#34;); return 0; } if(!a and !b) { puts(\u0026#34;True\u0026#34;); return 0; } while(!A.stk.empty() and !B.stk.empty()) { auto u = A.stk.top(); A.stk.pop(); auto v = B.stk.top(); B.stk.pop(); if(A.tr[u].val != B.tr[v].val) { puts(\u0026#34;False\u0026#34;); return 0; } } if(!A.stk.empty() || !B.stk.empty()) { puts(\u0026#34;False\u0026#34;); return 0; } puts(\u0026#34;True\u0026#34;); return 0; } Gym - 102501J https://codeforces.com/gym/102501/problem/J\né¢˜æ„ ç»™ä¸€ä¸ªæ ‘çš„ä¸­åºéå†åºåˆ—ï¼Œåˆ¤æ–­æœ‰å¤šå°‘æ»¡è¶³ç±»ä¼¼å°æ ¹å †çš„æ ‘ï¼Œ$n\u0026lt;=1e5$\nSolution ç›´æ¥dpä¸€å®šä¼šè¶…æ—¶ è€ƒè™‘æ ¹å¯èƒ½åœ¨çš„ä½ç½®ï¼Œå³å½“å‰æœ€å°å…ƒç´ çš„ä½ç½® è€ƒè™‘é€‰è¿™äº›å…ƒç´ ä¸ºæ ¹ä¼šæœ‰å“ªäº›æ ‘ï¼Œå°±å¯ä»¥å‘ç°å½“å‰çš„æœ€å°å…ƒç´ å°†åºåˆ—åˆ†æˆå­æ®µï¼Œå½“å‰å…ƒç´ ä½œä¸ºæ ¹çš„ç§ç±»æ•°æ˜¯å¡ç‰¹å…°æ•° å› æ­¤é€’å½’è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œæ¯æ¬¡ç”¨æœ€å°å…ƒç´ åˆ†å‰²å½“å‰åºåˆ—ï¼Œæœ€åå…¶å®å°±æ˜¯ä¸€äº›å¡ç‰¹å…°æ•°çš„ä¹˜ç§¯ ç”¨å•è°ƒæ ˆä¼šæ›´ä¼˜ç¾ä¸€ç‚¹ #include \u0026lt;cstdio\u0026gt; #include \u0026lt;stack\u0026gt; #include \u0026lt;set\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;map\u0026gt; #include \u0026lt;time.h\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; //#include \u0026lt;memory.h\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;iomanip\u0026gt; #include \u0026lt;cassert\u0026gt; #include \u0026lt;unordered_map\u0026gt; #define P pair\u0026lt;int, int\u0026gt; #define LL long long #define LD long double #define PLL pair\u0026lt;LL, LL\u0026gt; #define mset(a, b) memset(a, b, sizeof(a)) #define rep(i, a, b) for (int i = a; i \u0026lt; b; i++) #define PI acos(-1.0) #define random(x) rand() % x #define debug(x) cout \u0026lt;\u0026lt; #x \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34; using namespace std; const int inf = 0x3f3f3f3f; const LL __64inf = 0x3f3f3f3f3f3f3f3f; #ifdef DEBUG const int MAX = 2e3 + 50; #else const int MAX = 2e6 + 500; #endif const int mod = 1e9 + 7; void file_read() { #ifdef DEBUG freopen(\u0026#34;in\u0026#34;, \u0026#34;r\u0026#34;, stdin); // freopen(\u0026#34;out\u0026#34;, \u0026#34;w\u0026#34;, stdout); #endif } int a[MAX]; LL fact[MAX]; LL inv[MAX]; map\u0026lt;int, vector\u0026lt;int\u0026gt;\u0026gt; pos; LL qpow(LL x, LL n) { LL res = 1; while(n) { if(n \u0026amp; 1) { res = res * x % mod; } x = x * x % mod; n \u0026gt;\u0026gt;= 1; } return res; } LL f(LL x) { return fact[2*x] * inv[x] % mod * inv[x+1] % mod; } int main() { file_read(); int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for(int i = 1; i \u0026lt;= n; i++) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i]); } fact[0] = 1; for(int i = 1; i \u0026lt; MAX; i++) fact[i] = 1LL * fact[i-1] * i % mod; inv[MAX-1] = qpow(fact[MAX-1], mod-2); for(int i = MAX-2; i \u0026gt;= 1; i--) inv[i] = 1LL * (i+1) * inv[i+1] % mod; inv[0] = 1; LL res = 1; stack\u0026lt;int\u0026gt; stk; for(int i = 1; i \u0026lt;= n; i++) { if(stk.empty()) { stk.push(a[i]); continue; } int cnt = 0; int cur = inf; while(!stk.empty() and stk.top() \u0026gt; a[i]) { if(stk.top() == cur) { cnt++; } else { res = res * f(cnt) % mod; cnt = 1; cur = stk.top(); } stk.pop(); } stk.push(a[i]); res = res * f(cnt) % mod; } int cur = inf; int cnt = 0; while(!stk.empty()) { if(stk.top() == cur) { cnt++; } else { res = res * f(cnt) % mod; cur = stk.top(); cnt = 1; } stk.pop(); } res = res * f(cnt ) % mod; printf(\u0026#34;%lld\\n\u0026#34;, res); } ","permalink":"https://Anlarry.github.io/posts/acm-icpc/gym-102501%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/","summary":"Gym - 102501D Gnalcats https://codeforces.com/gym/102501/problem/D\né¢˜æ„ ç»™ä¸¤ç§æ ˆæ“ä½œåˆ¤æ–­æ˜¯å¦ç›¸ç­‰,å¦‚æœä¸¤ä¸ªæ“ä½œéƒ½failï¼Œä¹Ÿè®¤ä¸ºç›¸ç­‰\nSolution æ¨¡æ‹Ÿï¼Œæ¯ä¸ªæ°¨åŸºé…¸ä¸€ä¸ªhashå€¼ã€‚é€šè¿‡åˆ¤æ–­æœ€åæ ˆå…ƒç´ æ˜¯å¦å¯¹åº”hashç›¸ç­‰ï¼Œåˆ¤æ–­æ“ä½œæ˜¯å¦ç›¸ç­‰\n#include \u0026lt;cstdio\u0026gt; #include \u0026lt;stack\u0026gt; #include \u0026lt;set\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;map\u0026gt; #include \u0026lt;time.h\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; //#include \u0026lt;memory.h\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;iomanip\u0026gt; #include \u0026lt;cassert\u0026gt; #include \u0026lt;unordered_map\u0026gt; #define P pair\u0026lt;int, int\u0026gt; #define LL long long #define LD long double #define PLL pair\u0026lt;LL, LL\u0026gt; #define mset(a, b) memset(a, b, sizeof(a)) #define rep(i, a, b) for (int i = a; i \u0026lt; b; i++) #define PI acos(-1.","title":"Gym 102501éƒ¨åˆ†é¢˜è§£"},{"content":"Gym 102460L Largest Quadrilateral Largest Quadrilateral\né¢˜æ„ ç»™$n$ä¸ªç‚¹ä»ä¸­é€‰å‡ºå››ä¸ªç‚¹ï¼Œä½¿å¾—é¢ç§¯æœ€å¤§\nSolution é¦–å…ˆï¼Œè‚¯å®šæ˜¯æ±‚å‡¸åŒ…ï¼Œè¦æ±‚çš„ç‚¹ä¸€å®šåœ¨å‡¸åŒ…ä¸Šã€‚ ä¸éš¾è”æƒ³åˆ°å‡¸åŒ…å¯¹æ¯ä¸ªè¾¹æ±‚æœ€å¤§ä¸‰è§’å½¢é¢ç§¯çš„é—®é¢˜ï¼Œä¹Ÿå°±æ˜¯æ—‹è½¬å¡å£³ã€‚ å¯ä»¥å°†é—®é¢˜è½¬åŒ–ä¸ºï¼Œå¯¹å‡¸åŒ…çš„æ¯ä¸€ä¸ªå¯¹è§’çº¿$A_iA_j$ï¼Œæ±‚æœ€å¤§é¢ç§¯çš„ä¸¤ä¸ªä¸‰è§’å½¢ï¼Œ$\\triangle{A_iA_jP}$, $\\triangle{A_iA_jQ}$, ç„¶åå°±å¯ä»¥æšä¸¾å¯¹è§’çº¿ï¼Œæ—‹è½¬å¡å£³ç®—æœ€å¤§é¢ç§¯ ç»†èŠ‚\nè¾“å‡ºçš„æ ¼å¼ å‡¸åŒ…ä¸Šåº”è¯¥ç•™ä¸‹å…±çº¿çš„ç‚¹ #include \u0026lt;cstdio\u0026gt; #include \u0026lt;stack\u0026gt; #include \u0026lt;set\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;map\u0026gt; #include \u0026lt;time.h\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; //#include \u0026lt;memory.h\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;iomanip\u0026gt; #include \u0026lt;cassert\u0026gt; // #include \u0026lt;unordered_map\u0026gt; #define P pair\u0026lt;int, int\u0026gt; #define LL long long #define LD long double #define PLL pair\u0026lt;LL, LL\u0026gt; #define mset(a, b) memset(a, b, sizeof(a)) #define rep(i, a, b) for (int i = a; i \u0026lt; b; i++) #define PI acos(-1.0) #define random(x) rand() % x #define debug(x) cout \u0026lt;\u0026lt; #x \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34; using namespace std; const int inf = 0x3f3f3f3f; const LL __64inf = 0x3f3f3f3f3f3f3f3f; #ifdef DEBUG const int MAX = 2e3 + 50; #else const int MAX = 1e6 + 50; #endif const int mod = 1e9+9; void file_read(){ #ifdef DEBUG freopen(\u0026#34;in\u0026#34;, \u0026#34;r\u0026#34;, stdin); // freopen(\u0026#34;out\u0026#34;, \u0026#34;w\u0026#34;, stdout); #endif } template\u0026lt;typename type\u0026gt; struct Vec { type x, y; Vec() {} Vec(type x, type y) : x(x), y(y) {} friend istream \u0026amp; operator \u0026gt;\u0026gt; (istream \u0026amp;in, Vec \u0026amp;A) { in \u0026gt;\u0026gt; A.x \u0026gt;\u0026gt; A.y; return in; } friend Vec operator - (const Vec \u0026amp;A, const Vec \u0026amp;B) { return Vec(A.x-B.x, A.y-B.y); } friend Vec operator + (const Vec \u0026amp;A, const Vec \u0026amp;B) { return Vec(A.x + B.x, A.y + B.y); } friend type det(const Vec \u0026amp;A, const Vec \u0026amp;B) { return A.x * B.y - A.y * B.x; } friend type dot(const Vec \u0026amp;A, const Vec \u0026amp;B) { return A.x * B.x + A.y * B.y; } friend bool operator \u0026lt; (const Vec \u0026amp;A, const Vec \u0026amp;B) { if(A.x != B.x) return A.x \u0026lt; B.x; return A.y \u0026lt; B.y; } friend type area(const Vec \u0026amp;A, const Vec \u0026amp;B) { return abs(det(A, B)); } friend type operator == (const Vec \u0026amp;A, const Vec \u0026amp;B) { return A.x == B.x and A.y == B.y; } }; template\u0026lt;typename type\u0026gt; vector\u0026lt;Vec\u0026lt;type\u0026gt;\u0026gt; convex_hull(vector\u0026lt;Vec\u0026lt;type\u0026gt;\u0026gt; \u0026amp;pt) { sort(pt.begin(), pt.end()); int n = pt.size(); vector\u0026lt;Vec\u0026lt;type\u0026gt;\u0026gt; res(2*n); int k = 0 ; for(int i = 0; i \u0026lt; n; i++) { while(k \u0026gt; 1 and det(res[k-1]-res[k-2], pt[i]-res[k-1]) \u0026lt; 0) // \u0026lt;=ä¼šwa k--; res[k++] = pt[i]; } for(int i = n-2, t = k; i \u0026gt;= 0; i--) { while(k \u0026gt; t and det(res[k-1]-res[k-2], pt[i]-res[k-1]) \u0026lt; 0) // \u0026lt;=ä¼šwa k--; res[k++] = pt[i]; } res.resize(k-1); return res; } struct ModI { int i, n; ModI(int n ) : i(0), n(n) { assert(n \u0026gt; 0) ;} ModI(int i, int n) : i(i%n), n(n) { assert(n \u0026gt; 0); } ModI operator ++ ( int ) { ModI row = ModI(i, n); i = (i + 1) % n; return row; } ModI operator + (int x) { ModI res = ModI(i, n); res.i = (res.i + x) % n; return res; } int operator = (int x) { return i = x; } bool operator \u0026lt; (int x) const { return i \u0026lt; x; } bool operator == (const ModI \u0026amp;other) const { return i == other.i; } operator int () { return i; } }; template\u0026lt;typename type\u0026gt; type area(const Vec\u0026lt;type\u0026gt; \u0026amp;A, const Vec\u0026lt;type\u0026gt; \u0026amp;B, const Vec\u0026lt;type\u0026gt; \u0026amp;C) { return area(A-B, A-C); } template\u0026lt;typename type\u0026gt; type rotateCalipers(vector\u0026lt;Vec\u0026lt;type\u0026gt;\u0026gt; pt) { int n = pt.size(); type res = 0; for(int i = 0; i \u0026lt; pt.size(); i++) { ModI p1 = ModI(i+1, n); ModI p2 = ModI(i+3, n); for(ModI j = ModI(i+2, n); j+1 != i; j++) { while(p1+1 != j and area(pt[p1], pt[i], pt[j]) \u0026lt; area(pt[p1+1], pt[i], pt[j])) p1 ++; if(j == p2) p2++; while(p2+1 != i and area(pt[p2], pt[i], pt[j]) \u0026lt; area(pt[p2+1], pt[i], pt[j])) p2 ++; auto cur = area(pt[p1], pt[i], pt[j]) + area(pt[p2], pt[i], pt[j]); res = max(res, cur); } } return res; } void out(LL ans) { if(ans \u0026amp; 1) { printf(\u0026#34;%lld.5\\n\u0026#34;, ans \u0026gt;\u0026gt; 1); } else { printf(\u0026#34;%lld\\n\u0026#34;, ans \u0026gt;\u0026gt; 1); } } int main() { file_read(); int T; scanf(\u0026#34;%d\u0026#34;, \u0026amp;T); while (T--) { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); vector\u0026lt;Vec\u0026lt;LL\u0026gt;\u0026gt; pt(n); for(int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; pt[i]; auto ch = convex_hull(pt); if(ch.size() \u0026lt; 3) { printf(\u0026#34;0\\n\u0026#34;); continue; } if(ch.size() == 3) { LL ans = 0; LL A = area(ch[0], ch[1], ch[2]); for(auto p : pt) { if(p == ch[0] or p == ch[1] or p == ch[2]) continue; auto a = area(p, ch[1], ch[2]); a = min(a, area(p, ch[0], ch[2])); a = min(a, area(p, ch[0], ch[1])); ans = max(ans, A-a); } out(ans); continue; } LL res = rotateCalipers(ch); out(res); } return 0; } ","permalink":"https://Anlarry.github.io/posts/acm-icpc/gym-102460l-largest-quadrilateral/","summary":"Gym 102460L Largest Quadrilateral Largest Quadrilateral\né¢˜æ„ ç»™$n$ä¸ªç‚¹ä»ä¸­é€‰å‡ºå››ä¸ªç‚¹ï¼Œä½¿å¾—é¢ç§¯æœ€å¤§\nSolution é¦–å…ˆï¼Œè‚¯å®šæ˜¯æ±‚å‡¸åŒ…ï¼Œè¦æ±‚çš„ç‚¹ä¸€å®šåœ¨å‡¸åŒ…ä¸Šã€‚ ä¸éš¾è”æƒ³åˆ°å‡¸åŒ…å¯¹æ¯ä¸ªè¾¹æ±‚æœ€å¤§ä¸‰è§’å½¢é¢ç§¯çš„é—®é¢˜ï¼Œä¹Ÿå°±æ˜¯æ—‹è½¬å¡å£³ã€‚ å¯ä»¥å°†é—®é¢˜è½¬åŒ–ä¸ºï¼Œå¯¹å‡¸åŒ…çš„æ¯ä¸€ä¸ªå¯¹è§’çº¿$A_iA_j$ï¼Œæ±‚æœ€å¤§é¢ç§¯çš„ä¸¤ä¸ªä¸‰è§’å½¢ï¼Œ$\\triangle{A_iA_jP}$, $\\triangle{A_iA_jQ}$, ç„¶åå°±å¯ä»¥æšä¸¾å¯¹è§’çº¿ï¼Œæ—‹è½¬å¡å£³ç®—æœ€å¤§é¢ç§¯ ç»†èŠ‚\nè¾“å‡ºçš„æ ¼å¼ å‡¸åŒ…ä¸Šåº”è¯¥ç•™ä¸‹å…±çº¿çš„ç‚¹ #include \u0026lt;cstdio\u0026gt; #include \u0026lt;stack\u0026gt; #include \u0026lt;set\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;map\u0026gt; #include \u0026lt;time.h\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; //#include \u0026lt;memory.h\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;iomanip\u0026gt; #include \u0026lt;cassert\u0026gt; // #include \u0026lt;unordered_map\u0026gt; #define P pair\u0026lt;int, int\u0026gt; #define LL long long #define LD long double #define PLL pair\u0026lt;LL, LL\u0026gt; #define mset(a, b) memset(a, b, sizeof(a)) #define rep(i, a, b) for (int i = a; i \u0026lt; b; i++) #define PI acos(-1.","title":"Gym 102460L Largest Quadrilateral "},{"content":"Codeforces Round #663 http://codeforces.com/contest/1391\nC é¢˜æ„\nå¯¹äºä¸€ä¸ªæ’åˆ—${p_1, p_2, \\dots, p_n}$ï¼Œå¯¹äºæ¯ä¸ªæ•°å­—$p_i$ï¼Œå‘å‰æ‰¾ç¬¬ä¸€ä¸ªå¤§äº$p_i$çš„$p_j$ï¼Œ$i$å’Œ$j$è¿ä¸€æ¡è¾¹ï¼Œå‘ååŒç†ã€‚æ±‚å¤šå°‘ç§æ’åˆ—ç”Ÿæˆçš„å›¾æ˜¯æœ‰ç¯çš„\nSolution\nå¯¹äº$p_i$ï¼Œå¦‚æœå­˜åœ¨$p_j\u0026gt;p_i(j\u0026lt;i)$, $p_k\u0026gt;p_i(k\u0026gt;i)$ï¼Œé‚£ä¹ˆå°±æ˜¯å­˜åœ¨ç¯çš„ é‚£ä¹ˆå¯¹äº$\\forall i$éƒ½ä¸æˆç«‹æ—¶ï¼Œå°±æ²¡æœ‰ç¯ æ­¤æ—¶å°±æ˜¯åºåˆ—çš„ç‰¹ç‚¹å°±æ˜¯,æ•°å­—$n$å·¦è¾¹å’Œå³è¾¹å‘ä¸¤è¾¹é€’å‡ å› æ­¤æ’åˆ—æ•°å°±æ˜¯$n!-2^{n-1}$ #include \u0026lt;cstdio\u0026gt; #include \u0026lt;stack\u0026gt; #include \u0026lt;set\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;map\u0026gt; #include \u0026lt;time.h\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;iomanip\u0026gt; #include \u0026lt;cassert\u0026gt; #define P pair\u0026lt;int, int\u0026gt; #define LL long long #define LD long double #define PLL pair\u0026lt;LL, LL\u0026gt; #define mset(a, b) memset(a, b, sizeof(a)) #define rep(i, a, b) for (int i = a; i \u0026lt; b; i++) #define PI acos(-1.0) #define random(x) rand() % x #define debug(x) cout \u0026lt;\u0026lt; #x \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34; using namespace std; const LL inf = 0x3f3f3f3f3f3f3f3f; #ifdef DEBUG const int MAX = 2e3 + 50; #else const int MAX = 2e6 + 50; #endif const int mod = 1e9+7; void file_read(){ #ifdef DEBUG freopen(\u0026#34;in\u0026#34;, \u0026#34;r\u0026#34;, stdin); #endif } int main(){ file_read(); LL n; scanf(\u0026#34;%lld\\n\u0026#34;, \u0026amp;n); LL fact = 1; for(LL i = 1; i \u0026lt;= n; i++) { fact = fact * i % mod; } LL pow2 = 1; for(int i = 1; i \u0026lt; n; i++) { pow2 = pow2 * 2 % mod; } LL res = (fact - pow2) % mod; if(res \u0026lt; 0) res += mod; printf(\u0026#34;%lld\\n\u0026#34;, res); } D é¢˜æ„\nç»™ä¸€ä¸ª01çŸ©é˜µï¼Œå¯¹äºæ¯ä¸ªå˜æˆä½å¶æ•°çš„æ­£æ–¹å½¢ï¼Œ1çš„ä¸ªæ•°å¿…é¡»æ—¶å¥‡æ•°ä¸ªï¼Œæ±‚æœ€å°æ”¹å˜01çš„æ¬¡æ•°\nSolution\né¦–å…ˆï¼Œå¯¹äº4*4çš„çŸ©é˜µæ˜¯æ— è§£çš„ï¼Œå› æ­¤ï¼Œ$n,m$å¿…æœ‰ä¸€ä¸ªå°äº4ï¼Œä¸å¦¨å‡è®¾$n\u0026lt;4$, ä¸”$n\u0026lt;m$ ç„¶åé—®é¢˜å°±å¯ä»¥dpï¼Œæšä¸¾çŠ¶æ€è½¬ç§» $$ dp[i][mask_y] = min(dp[i-1][mask_x]+cost(i,mask_y), dp[i][mask_y]) $$ #include \u0026lt;cstdio\u0026gt; #include \u0026lt;stack\u0026gt; #include \u0026lt;set\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;map\u0026gt; #include \u0026lt;time.h\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; //#include \u0026lt;memory.h\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;iomanip\u0026gt; #include \u0026lt;cassert\u0026gt; // #include \u0026lt;unordered_map\u0026gt; #define P pair\u0026lt;int, int\u0026gt; #define LL long long #define LD long double #define PLL pair\u0026lt;LL, LL\u0026gt; #define mset(a, b) memset(a, b, sizeof(a)) #define rep(i, a, b) for (int i = a; i \u0026lt; b; i++) #define PI acos(-1.0) #define random(x) rand() % x #define debug(x) cout \u0026lt;\u0026lt; #x \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34; using namespace std; const int inf = 0x3f3f3f3f; const LL __64inf = 0x3f3f3f3f3f3f3f3f; #ifdef DEBUG const int MAX = 2e3 + 50; #else const int MAX = 2e6 + 50; #endif const int mod = 1e9+7; void file_read(){ #ifdef DEBUG freopen(\u0026#34;in\u0026#34;, \u0026#34;r\u0026#34;, stdin); #endif } char s[10][MAX]; int dp[MAX][10]; int n, m; int cost(int col, int mask){ int res = 0; for(int i = 1; i \u0026lt;= n; i++) { int x = s[i][col] - \u0026#39;0\u0026#39;; int y = mask \u0026amp; 1; res += x != y; mask \u0026gt;\u0026gt;= 1; } return res; } bool check(int x, int y) { int A[2][10]; for(int i = 1; i \u0026lt;= n; i++) { int a = x \u0026amp; 1; int b = y \u0026amp; 1; A[0][i] = a; A[1][i] = b; x \u0026gt;\u0026gt;= 1; y \u0026gt;\u0026gt;= 1; } int res = A[0][1] ^ A[0][2] ^ A[1][1] ^ A[1][2]; if(!res) return false; if(n == 2) return true; res = A[0][2] ^ A[0][3] ^ A[1][2] ^ A[1][3]; return res; } int main(){ file_read(); scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); if(n == 1 || m == 1) { puts(\u0026#34;0\u0026#34;); return 0; } if(n \u0026gt;= 4 and m \u0026gt;= 4) { puts(\u0026#34;-1\u0026#34;); return 0; } if(n \u0026lt;= m) { for(int i = 1; i \u0026lt;= n; i++) scanf(\u0026#34;%s\u0026#34;, s[i]+1); } else { for(int i = 1; i \u0026lt;= n; i++) { char t[10]; scanf(\u0026#34;%s\u0026#34;, t+1); for(int j = 1; j \u0026lt;= m; j++) { s[j][i] = t[j]; } } swap(n, m); } // n \u0026lt;= m; mset(dp, 0x3f); int up = n == 2 ? 4 : 8; for(int i = 0; i \u0026lt; up; i++) { for(int j = 0; j \u0026lt; up; j++) { if(check(i, j)) dp[2][j] = min(dp[2][j], cost(1, i)+cost(2, j)); } } for(int i = 3; i \u0026lt;= m; i++) { for(int x = 0; x \u0026lt; up; x++) { for(int y = 0; y \u0026lt; up; y++) { if(check(x, y)) dp[i][y] = min(dp[i][y], dp[i-1][x]+cost(i, y)); } } } int res = inf; for(int i = 0; i \u0026lt; up; i++ ) { res = min(res, dp[m][i]); } printf(\u0026#34;%d\\n\u0026#34;, res); } E é¢˜æ„\nç»™ä¸€ä¸ªæ— å‘å›¾è¿é€šå›¾ï¼Œæœ‰$n$ä¸ªç‚¹ï¼Œæ±‚ä¸‹é¢ä»»æ„ä¸€ä¸ªï¼Œ\né•¿åº¦ä¸å°äº$\\lceil n \\rceil$ ä¸€ä¸ªä¸å°äº$\\lceil n \\rceil$çš„ç‚¹é›†ï¼Œä¸¤ä¸¤ç»„æˆpairï¼Œpairä¹‹é—´çš„ç”Ÿæˆå›¾è¾¹æ•°ä¸å¤§äº2 Solution\nè¿™æ˜¯ä¸ªæ„é€ é¢˜ è€ƒè™‘åœ¨å›¾ä¸Šè·‘dfsåå¾—åˆ°çš„æ ‘ å¯¹äºä¸€ä¸ªèŠ‚ç‚¹ï¼Œé™¤äº†æ ‘è¾¹ï¼Œä¸ä¼šå­˜åœ¨å‘æ—è¾¹è¿çš„è¾¹ï¼Œåªæœ‰è¿å‘ç¥–å…ˆçš„è¾¹ å¦‚æœå­˜åœ¨ä¸€ä¸ªæ·±åº¦ä¸å°äº$\\lceil n \\rceil$ï¼Œç­”æ¡ˆå°±å­˜åœ¨äº† å¦åˆ™ï¼Œå¯¹äºæ¯ä¸ªæ·±åº¦ä¸¤ä¸¤pairï¼Œå¯¹äºä»»æ„çš„pairçš„ç”Ÿæˆå›¾éƒ½æ˜¯æ»¡è¶³è¦æ±‚çš„ã€‚å¯¹äºæ¯ä¸€å±‚ï¼Œæœ€å¤šåªå‰©ä¸€ä¸ªï¼Œè€Œä¸”æœ€å¤šæœ‰$\\lfloor n\\rfloor$,å› æ­¤ç‚¹é›†çš„å¤§å°ä¸å°äº$n-\\lfloor n \\rfloor$ #include \u0026lt;cstdio\u0026gt; #include \u0026lt;stack\u0026gt; #include \u0026lt;set\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;map\u0026gt; #include \u0026lt;time.h\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; //#include \u0026lt;memory.h\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;iomanip\u0026gt; #include \u0026lt;cassert\u0026gt; // #include \u0026lt;unordered_map\u0026gt; #define P pair\u0026lt;int, int\u0026gt; #define LL long long #define LD long double #define PLL pair\u0026lt;LL, LL\u0026gt; #define mset(a, b) memset(a, b, sizeof(a)) #define rep(i, a, b) for (int i = a; i \u0026lt; b; i++) #define PI acos(-1.0) #define random(x) rand() % x #define debug(x) cout \u0026lt;\u0026lt; #x \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34; using namespace std; const int inf = 0x3f3f3f3f; const LL __64inf = 0x3f3f3f3f3f3f3f3f; #ifdef DEBUG const int MAX = 2e3 + 50; #else const int MAX = 2e6 + 50; #endif const int mod = 1e9+7; void file_read(){ #ifdef DEBUG freopen(\u0026#34;in\u0026#34;, \u0026#34;r\u0026#34;, stdin); #endif } vector\u0026lt;int\u0026gt; G[MAX]; bool vis[MAX]; int dep[MAX]; vector\u0026lt;int\u0026gt; dep_set[MAX]; int p[MAX]; int pr[MAX]; void dfs(int u, int parent, int d) { dep[u] = d; vis[u] = 1; p[u] = parent; for(auto v : G[u]) { if(vis[v]) continue; dfs(v, u, d+1); } } int main(){ file_read(); int T; scanf(\u0026#34;%d\u0026#34;, \u0026amp;T); while (T--) { int n, m; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); memset(vis, 0, sizeof(bool) * (n +50)); memset(dep, 0, sizeof(int) * (n+50)); memset(p, 0, sizeof(int) * (n+50)); for(int i = 1; i \u0026lt;= n; i++) G[i].clear(); for(int i = 1; i \u0026lt;= n; i++) dep_set[i].clear(); for(int i = 1; i \u0026lt;= m; i++) { int u, v; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;u, \u0026amp;v); G[u].push_back(v); G[v].push_back(u); } dfs(1, -1, 1); int Max = -1, id = -1; for(int i = 1; i \u0026lt;= n; i++) { if(dep[i] \u0026gt; Max) { Max = dep[i]; id = i; } } if(Max * 2 \u0026gt;= n) { puts(\u0026#34;PATH\u0026#34;); vector\u0026lt;int\u0026gt; ans; int u = id; while(u != -1) { ans.push_back(u); u = p[u]; } printf(\u0026#34;%d\\n\u0026#34;, ans.size()); for(auto x: ans) printf(\u0026#34;%d \u0026#34;, x); puts(\u0026#34;\u0026#34;); continue; } for(int i = 1; i \u0026lt;= n; i++) { dep_set[dep[i]].push_back(i); } puts(\u0026#34;PAIRING\u0026#34;); vector\u0026lt;P\u0026gt; ans; for(int k = 1; k \u0026lt;= Max; k++) { for(int i = 0; i+1 \u0026lt; dep_set[k].size(); i+=2) { ans.emplace_back(dep_set[k][i], dep_set[k][i+1]); } } printf(\u0026#34;%d\\n\u0026#34;, ans.size()); for(auto p : ans ) printf(\u0026#34;%d %d\\n\u0026#34;, p.first, p.second); } return 0; } A B A B\n","permalink":"https://Anlarry.github.io/posts/acm-icpc/codeforces-round-663/","summary":"Codeforces Round #663 http://codeforces.com/contest/1391\nC é¢˜æ„\nå¯¹äºä¸€ä¸ªæ’åˆ—${p_1, p_2, \\dots, p_n}$ï¼Œå¯¹äºæ¯ä¸ªæ•°å­—$p_i$ï¼Œå‘å‰æ‰¾ç¬¬ä¸€ä¸ªå¤§äº$p_i$çš„$p_j$ï¼Œ$i$å’Œ$j$è¿ä¸€æ¡è¾¹ï¼Œå‘ååŒç†ã€‚æ±‚å¤šå°‘ç§æ’åˆ—ç”Ÿæˆçš„å›¾æ˜¯æœ‰ç¯çš„\nSolution\nå¯¹äº$p_i$ï¼Œå¦‚æœå­˜åœ¨$p_j\u0026gt;p_i(j\u0026lt;i)$, $p_k\u0026gt;p_i(k\u0026gt;i)$ï¼Œé‚£ä¹ˆå°±æ˜¯å­˜åœ¨ç¯çš„ é‚£ä¹ˆå¯¹äº$\\forall i$éƒ½ä¸æˆç«‹æ—¶ï¼Œå°±æ²¡æœ‰ç¯ æ­¤æ—¶å°±æ˜¯åºåˆ—çš„ç‰¹ç‚¹å°±æ˜¯,æ•°å­—$n$å·¦è¾¹å’Œå³è¾¹å‘ä¸¤è¾¹é€’å‡ å› æ­¤æ’åˆ—æ•°å°±æ˜¯$n!-2^{n-1}$ #include \u0026lt;cstdio\u0026gt; #include \u0026lt;stack\u0026gt; #include \u0026lt;set\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;map\u0026gt; #include \u0026lt;time.h\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;iomanip\u0026gt; #include \u0026lt;cassert\u0026gt; #define P pair\u0026lt;int, int\u0026gt; #define LL long long #define LD long double #define PLL pair\u0026lt;LL, LL\u0026gt; #define mset(a, b) memset(a, b, sizeof(a)) #define rep(i, a, b) for (int i = a; i \u0026lt; b; i++) #define PI acos(-1.","title":"Codeforces Round #663"},{"content":"Codeforces Round #660 https://codeforces.com/contest/1388\nE é¢˜æ„\nå¹³é¢ä¸Šæœ‰ä¸€äº›çº¿æ®µï¼Œå°†ä»–ä»¬æŠ•å½±åˆ°$x$è½´ä¸Šï¼Œä½¿å¾—å½¼æ­¤ä¸æƒ³äº¤(ä½†æ˜¯å¯ä»¥æŒ¨ç€)ï¼Œè®¾æœ€å·¦è¾¹çš„ç‚¹å’Œæœ€å³è¾¹çš„ç‚¹çš„æ¨ªåæ ‡åˆ†åˆ«æ˜¯$x_l, x_r$ï¼Œ æ±‚$min{x_r-x_l}$\nSolution\né¦–å…ˆå¯¹äºä¸¤ä¸ªçº¿æ®µ$s_1, s_2$, å¹¶ä¸”$s_1.y \u0026lt; s_2.y$, äº¤å‰è¿æ¥ä»–ä»¬çš„å·¦å³ç«¯ç‚¹ï¼Œå¾—åˆ°ä¸€ä¸ªå‘é‡é›†åˆ$bound$ï¼Œå¯¹æŠ•å½±å‘é‡é™åˆ¶é™åˆ¶ã€‚ å› æ­¤å…ˆä¸¤ä¸¤æšä¸¾ï¼Œå¾—åˆ°æŠ•å½±å‘é‡çš„å¯è¡Œçš„å–å€¼ã€‚\nè€Œä¸”æœ€ä¼˜çš„æŠ•å½±å‘é‡ï¼Œæ˜¯é›†åˆ$bound$ä¸­çš„æŸä¸€é¡¹\nå› æ­¤ï¼Œå¯¹å‰©ä¸‹çš„å¯è¡Œçš„æŠ•å½±å‘é‡, å‡è®¾å½“å‰æšä¸¾çš„æ–¹å‘æ˜¯$k_i$ï¼Œè®¡ç®—\n$$ max{x_j+y_jKi}-min{x_j+y_jk_i} $$\nè®¡ç®—è¿™ä¸ªå¼å­å¯ä»¥ç”¨Convex hull trick, ç„¶åä¸æ–­æ›´æ–°ans\n#include \u0026lt;cstdio\u0026gt; #include \u0026lt;stack\u0026gt; #include \u0026lt;set\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;map\u0026gt; #include \u0026lt;time.h\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;memory.h\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;iomanip\u0026gt; #include \u0026lt;bitset\u0026gt; #include \u0026lt;unordered_map\u0026gt; #include \u0026lt;assert.h\u0026gt; #include \u0026lt;list\u0026gt; #define P pair\u0026lt;int, int\u0026gt; #define LL long long #define LD long double #define PLL pair\u0026lt;LL, LL\u0026gt; #define mset(a, b) memset(a, b, sizeof(a)) #define rep(i, a, b) for (int i = a; i \u0026lt; b; i++) #define PI acos(-1.0) #define random(x) rand() % x #define debug(x) cout \u0026lt;\u0026lt; #x \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34; using namespace std; const int inf = 0x3f3f3f3f; const LL __64inf = 0x3f3f3f3f3f3f3f3f; #ifdef DEBUG const int MAX = 1e3 + 50; #else const int MAX = 1e6 + 50; #endif const int mod = 998244353; void file_read(){ #ifdef DEBUG freopen64(\u0026#34;in\u0026#34;, \u0026#34;r\u0026#34;, stdin); #endif } struct Seg { double xl, xr, y; Seg(double xl, double xr, double y) : xl(xl), xr(xr), y(y) {} }; vector\u0026lt;Seg\u0026gt; seg; vector\u0026lt;pair\u0026lt;double, double\u0026gt;\u0026gt; bd; void bound() { for(int i = 0; i \u0026lt; seg.size(); i++) { for(int j = i+1; j \u0026lt; seg.size(); j++) { if(seg[i].y == seg[j].y) continue; auto s1 = seg[i]; auto s2 = seg[j]; if(s1.y \u0026gt; s2.y) swap(s1, s2); double beta1 = (s1.xr - s2.xl) / (s2.y - s1.y); double beta2 = (s1.xl - s2.xr) / (s2.y - s1.y); bd.emplace_back(beta2, beta1); } } } void filter(vector\u0026lt;double\u0026gt; \u0026amp;theta) { double cur = -__64inf; for(auto x : bd) { if(x.first \u0026gt;= cur) { theta.push_back(x.first); if(cur \u0026gt; -__64inf) theta.push_back(cur); } cur = max(cur, x.second); } theta.push_back(cur); } double cross(pair\u0026lt;double, double\u0026gt; A, pair\u0026lt;double, double\u0026gt; B) { return (A.first - B.first) / (B.second - A.second); } template\u0026lt;typename Cmp_1, typename Cmp_2\u0026gt; struct Convex { int top; vector\u0026lt;pair\u0026lt;double, double\u0026gt;\u0026gt; pts; vector\u0026lt;double\u0026gt; X; pair\u0026lt;double, double\u0026gt; stk[3000]; Cmp_1 cmp_1; Cmp_2 cmp_2; Convex(vector\u0026lt;Seg\u0026gt; \u0026amp;seg) : cmp_1(Cmp_1()), cmp_2(Cmp_2()) { for(auto s : seg) { pts.emplace_back(s.xl, s.y); pts.emplace_back(s.xr, s.y); } sort(pts.begin(), pts.end(), [this](const pair\u0026lt;double, double\u0026gt; \u0026amp;A, const pair\u0026lt;double, double\u0026gt; \u0026amp;B){ if(abs(A.second - B.second) \u0026lt; 1e-8 ) return this-\u0026gt;cmp_1(A.first, B.first);//return A.first \u0026lt; B.first; // return A.second \u0026gt; B.second; return this-\u0026gt;cmp_2(A.second, B.second); }); int i = 0; top = 0; stk[top++] = pts[0]; while(i \u0026lt; pts.size() and abs(pts[i].second-pts[0].second) \u0026lt; 1e-8) i++; if(i == pts.size()) { X.push_back(-__64inf); return ; } stk[top++] = pts[i++]; while(i \u0026lt; pts.size()) { int j = i; while(j \u0026lt; pts.size() and abs(pts[j].second-pts[i].second) \u0026lt; 1e-8) j++; if(j == pts.size()) break; auto cur = pts[j]; while(top \u0026gt;= 2) { double cross_x = cross(stk[top-1], stk[top-2]); double cross_cur = cross(cur, stk[top-2]); if(cross_cur \u0026lt; cross_x) top--; else break; } stk[top++] = cur; i = j+1; } X.push_back(-__64inf); for(int i = 1; i \u0026lt; top; i++) { X.push_back(cross(stk[i-1], stk[i])); } } double query(double a) { int idx = lower_bound(X.begin(), X.end(), a)- X.begin(); idx--; return stk[idx].first + stk[idx].second * a; } }; struct Less { bool operator () (double A, double B) { return A \u0026lt; B; } }; struct Great { bool operator () (double A, double B) { return A \u0026gt; B; } }; int main(){ #ifdef DEBUG freopen64(\u0026#34;in\u0026#34;, \u0026#34;r\u0026#34;, stdin); #endif int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); set\u0026lt;double\u0026gt; Y; for(int i = 0; i \u0026lt; n; i++) { double xl, xr, y; scanf(\u0026#34;%lf%lf%lf\u0026#34;, \u0026amp;xl, \u0026amp;xr, \u0026amp;y) ; seg.emplace_back(xl, xr, y); Y.insert(y); } if(Y.size() == 1) { double Min = __64inf, Max = -__64inf; for(auto s : seg) { Min = min(s.xl, Min); Max = max(Max, s.xr); } printf(\u0026#34;%.10f\\n\u0026#34;, Max-Min); return 0; } bound(); vector\u0026lt;double\u0026gt; theta; sort(bd.begin(), bd.end()); filter(theta); #ifdef DEBUG for(auto t : theta) printf(\u0026#34;%.2f \u0026#34;, t); puts(\u0026#34;\u0026#34;); #endif double ans = __64inf; Convex\u0026lt;Less, Great\u0026gt; left(seg); Convex\u0026lt;Great, Less\u0026gt; right(seg); for(auto x : theta) { double l = left.query(x); double r = right.query(x); ans = min(ans, r-l); } printf(\u0026#34;%.10f\\n\u0026#34;, ans); } A B C D A B C D\n","permalink":"https://Anlarry.github.io/posts/acm-icpc/codeforces-round-660/","summary":"Codeforces Round #660 https://codeforces.com/contest/1388\nE é¢˜æ„\nå¹³é¢ä¸Šæœ‰ä¸€äº›çº¿æ®µï¼Œå°†ä»–ä»¬æŠ•å½±åˆ°$x$è½´ä¸Šï¼Œä½¿å¾—å½¼æ­¤ä¸æƒ³äº¤(ä½†æ˜¯å¯ä»¥æŒ¨ç€)ï¼Œè®¾æœ€å·¦è¾¹çš„ç‚¹å’Œæœ€å³è¾¹çš„ç‚¹çš„æ¨ªåæ ‡åˆ†åˆ«æ˜¯$x_l, x_r$ï¼Œ æ±‚$min{x_r-x_l}$\nSolution\né¦–å…ˆå¯¹äºä¸¤ä¸ªçº¿æ®µ$s_1, s_2$, å¹¶ä¸”$s_1.y \u0026lt; s_2.y$, äº¤å‰è¿æ¥ä»–ä»¬çš„å·¦å³ç«¯ç‚¹ï¼Œå¾—åˆ°ä¸€ä¸ªå‘é‡é›†åˆ$bound$ï¼Œå¯¹æŠ•å½±å‘é‡é™åˆ¶é™åˆ¶ã€‚ å› æ­¤å…ˆä¸¤ä¸¤æšä¸¾ï¼Œå¾—åˆ°æŠ•å½±å‘é‡çš„å¯è¡Œçš„å–å€¼ã€‚\nè€Œä¸”æœ€ä¼˜çš„æŠ•å½±å‘é‡ï¼Œæ˜¯é›†åˆ$bound$ä¸­çš„æŸä¸€é¡¹\nå› æ­¤ï¼Œå¯¹å‰©ä¸‹çš„å¯è¡Œçš„æŠ•å½±å‘é‡, å‡è®¾å½“å‰æšä¸¾çš„æ–¹å‘æ˜¯$k_i$ï¼Œè®¡ç®—\n$$ max{x_j+y_jKi}-min{x_j+y_jk_i} $$\nè®¡ç®—è¿™ä¸ªå¼å­å¯ä»¥ç”¨Convex hull trick, ç„¶åä¸æ–­æ›´æ–°ans\n#include \u0026lt;cstdio\u0026gt; #include \u0026lt;stack\u0026gt; #include \u0026lt;set\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;map\u0026gt; #include \u0026lt;time.h\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;memory.h\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;iomanip\u0026gt; #include \u0026lt;bitset\u0026gt; #include \u0026lt;unordered_map\u0026gt; #include \u0026lt;assert.h\u0026gt; #include \u0026lt;list\u0026gt; #define P pair\u0026lt;int, int\u0026gt; #define LL long long #define LD long double #define PLL pair\u0026lt;LL, LL\u0026gt; #define mset(a, b) memset(a, b, sizeof(a)) #define rep(i, a, b) for (int i = a; i \u0026lt; b; i++) #define PI acos(-1.","title":"Codeforces Round #660"},{"content":"nowcoder 2020 å¤šæ ¡ ç¬¬ä¸‰åœº E Two Matchings é¢˜æ„\nå¯ä»¥ç®€åŒ–é¢˜æ„ä¸ºï¼Œæ¯ä¸ªç‚¹æœ‰ä¸ªæƒé‡$w$ï¼Œä¸¤ä¸ªç‚¹$i,j$ç›¸è¿çš„ä»£ä»·$abs(w_i-w_j)$,æ‰¾ä¸¤ä¸ªæ²¡æœ‰é‡å çš„åŒ¹é…ä½¿å¾—ä»£ä»·æœ€å°\nSolution\nå…¶å®å°±æ˜¯åœ¨å°†æ•°å­—ç”¨é•¿åº¦ä¸ºå¶æ•°çš„ç¯è¿èµ·æ¥ï¼Œæ±‚æœ€å°ä»£ä»·ã€‚è¿›ä¸€æ­¥å¯ä»¥å‘ç°ï¼Œç¯ç”¨é•¿åº¦ä¸º4æˆ–6ï¼Œé•¿åº¦æ›´é•¿çš„ç¯å¯ä»¥è¢«åˆ†è§£è¾¾åˆ°æ›´å°çš„ä»£ä»·\nLL n; LL a[MAX]; LL dp[MAX][2]; LL four(const vector\u0026lt;LL\u0026gt; \u0026amp;a){ return 2LL * (a[3]-a[0]); } LL six(const vector\u0026lt;LL\u0026gt; \u0026amp;a){ return 2LL * (a[5]-a[0]); } int main(){ #ifdef DEBUG freopen(\u0026#34;in\u0026#34;, \u0026#34;r\u0026#34;, stdin); #endif int T; scanf(\u0026#34;%d\u0026#34;, \u0026amp;T); while (T--) { cin \u0026gt;\u0026gt; n; for(int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; a[i]; sort(a, a+n); for(LL i = 0; i \u0026lt;= n; i++ ) dp[i][0] = dp[i][1] = __64inf; dp[3][0] = 2LL * (a[3]-a[0]); dp[5][0] = 2LL * (a[5]-a[0]); dp[7][0] = 2LL * (a[7]-a[4] + a[3] - a[0]); for(LL i = 9; i \u0026lt; n; i+=2){ dp[i][0] = min(dp[i-4][0], dp[i-4][1]) + four(vector\u0026lt;LL\u0026gt;({a[i-3], a[i-2], a[i-1], a[i]})); dp[i][1] = min(dp[i-6][0], dp[i-6][1]) + six(vector\u0026lt;LL\u0026gt;({a[i-5], a[i-4], a[i-3], a[i-2], a[i-1], a[i]})); } printf(\u0026#34;%d\\n\u0026#34;, min(dp[n-1][0], dp[n-1][1])); } } F Fraction Construction Problem é¢˜æ„\né—®æœ‰æ²¡æœ‰æ»¡è¶³$\\displaystyle\\frac{c}{d}-\\frac{e}{f}=\\frac{a}{b}$çš„$c,d,e,f$\nSolution\næ„Ÿè§‰æ˜¯åˆ†ç±»è®¨è®ºï¼Œç„¶åæ„é€ è§£\nvoid ex_gcd(LL a, LL b, LL \u0026amp;x, LL \u0026amp;y){ if(b == 0){ x = 1; y = 0; return; } ex_gcd(b, a % b, x, y); LL tmp = x; x = y; y = tmp - (a / b) * y; } LL p[MAX]; LL cnt[MAX]; vector\u0026lt;LL\u0026gt; prime; bool isprime[MAX]; void init(){ mset(isprime, 1); isprime[0] = isprime[1] = 0; for(int i = 2; i \u0026lt; MAX; i++){ if(isprime[i]) { prime.push_back(i); cnt[i] = 1; p[i] = i; } for(int j = 0; j \u0026lt; prime.size() and i * prime[j] \u0026lt; MAX; j++){ isprime[i * prime[j]] = 0; cnt[i * prime[j]] = i % prime[j] == 0 ? cnt[i] : cnt[i] + 1; p[i * prime[j]] = prime[j]; } } } int main(){ #ifdef DEBUG #else ios::sync_with_stdio(0); cin.tie(0); #endif init(); int T; cin \u0026gt;\u0026gt; T; while (T--) { LL a, b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; LL g = __gcd(a, b); if(g \u0026gt; 1){ LL bb = b / g, aa = a / g; cout \u0026lt;\u0026lt; aa + 1 \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; bb \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; 1 \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; bb \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; continue; } LL tmp = b; if(cnt[b] \u0026lt;= 1) { cout \u0026lt;\u0026lt; \u0026#34;-1 -1 -1 -1\\n\u0026#34;; continue; } LL d = 1; tmp = b; while(tmp % p[b] == 0) { tmp /= p[b]; d *= p[b]; } LL f = b / d; LL c, e; ex_gcd(f, d, c, e); if(c \u0026lt; 0) { LL t = - (c -d + 1) / d; c += t * d; e -= t * f; } e = -e; e *= a; c *= a; cout \u0026lt;\u0026lt; c \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; d \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; e \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; f \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } } G Operating on a Graph é¢˜æ„\nç»™ä¸€ä¸ªå›¾ï¼Œä¸€å¼€å§‹æ¯ä¸ªç‚¹$i$,å±äº$i$ç±»ï¼Œæ¯æ¬¡æ“ä½œä¼šå§æŸä¸ªç±»$x$çš„ç›¸é‚»çš„ç±»å½’ä¸º$x$,æ±‚æœ€åæ¯ä¸ªç‚¹å±äºé‚£ä¸ªç±»\nSolution\nå¹¶æŸ¥é›†æ¨¡æ‹Ÿ\nlist\u0026lt;int\u0026gt; lk[MAX]; vector\u0026lt;int\u0026gt; G[MAX]; int fa[MAX]; int Find(int x) { return fa[x] == x ? x : fa[x] = Find(fa[x]); } int main(){ #ifdef DEBUG freopen64(\u0026#34;in\u0026#34;, \u0026#34;r\u0026#34;, stdin); #endif int T; scanf(\u0026#34;%d\u0026#34;, \u0026amp;T); while (T--) { int n, m; scanf(\u0026#34;%d%d\u0026#34;,\u0026amp;n, \u0026amp;m); for(int i = 1; i \u0026lt;= n; i++){ G[i].clear(); fa[i] = i; lk[i].clear(); lk[i].push_back(i); } for(int i = 0; i \u0026lt; m; i++) { int u, v; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;u, \u0026amp;v); u++, v++; G[u].push_back(v); G[v].push_back(u); } int q; scanf(\u0026#34;%d\u0026#34;,\u0026amp;q); while (q--) { int o; scanf(\u0026#34;%d\u0026#34;, \u0026amp;o); o++; int siz = lk[o].size(); if(Find(o) != o) continue; for(int i = 0; i \u0026lt; siz; i++) { int cur = lk[o].front(); lk[o].pop_front(); for(int j = 0; j \u0026lt; G[cur].size(); j++) { int v = G[cur][j]; int pv = Find(v); if(pv != o) { fa[pv] = o; lk[o].splice(lk[o].end(), lk[pv]); } } } } for(int i = 1; i \u0026lt;= n; i++) printf(\u0026#34;%d \u0026#34;, Find(i)-1); puts(\u0026#34;\u0026#34;); } return 0; } ","permalink":"https://Anlarry.github.io/posts/acm-icpc/nowcoder-2020-%E5%A4%9A%E6%A0%A1-%E7%AC%AC%E4%B8%89%E5%9C%BA/","summary":"nowcoder 2020 å¤šæ ¡ ç¬¬ä¸‰åœº E Two Matchings é¢˜æ„\nå¯ä»¥ç®€åŒ–é¢˜æ„ä¸ºï¼Œæ¯ä¸ªç‚¹æœ‰ä¸ªæƒé‡$w$ï¼Œä¸¤ä¸ªç‚¹$i,j$ç›¸è¿çš„ä»£ä»·$abs(w_i-w_j)$,æ‰¾ä¸¤ä¸ªæ²¡æœ‰é‡å çš„åŒ¹é…ä½¿å¾—ä»£ä»·æœ€å°\nSolution\nå…¶å®å°±æ˜¯åœ¨å°†æ•°å­—ç”¨é•¿åº¦ä¸ºå¶æ•°çš„ç¯è¿èµ·æ¥ï¼Œæ±‚æœ€å°ä»£ä»·ã€‚è¿›ä¸€æ­¥å¯ä»¥å‘ç°ï¼Œç¯ç”¨é•¿åº¦ä¸º4æˆ–6ï¼Œé•¿åº¦æ›´é•¿çš„ç¯å¯ä»¥è¢«åˆ†è§£è¾¾åˆ°æ›´å°çš„ä»£ä»·\nLL n; LL a[MAX]; LL dp[MAX][2]; LL four(const vector\u0026lt;LL\u0026gt; \u0026amp;a){ return 2LL * (a[3]-a[0]); } LL six(const vector\u0026lt;LL\u0026gt; \u0026amp;a){ return 2LL * (a[5]-a[0]); } int main(){ #ifdef DEBUG freopen(\u0026#34;in\u0026#34;, \u0026#34;r\u0026#34;, stdin); #endif int T; scanf(\u0026#34;%d\u0026#34;, \u0026amp;T); while (T--) { cin \u0026gt;\u0026gt; n; for(int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; a[i]; sort(a, a+n); for(LL i = 0; i \u0026lt;= n; i++ ) dp[i][0] = dp[i][1] = __64inf; dp[3][0] = 2LL * (a[3]-a[0]); dp[5][0] = 2LL * (a[5]-a[0]); dp[7][0] = 2LL * (a[7]-a[4] + a[3] - a[0]); for(LL i = 9; i \u0026lt; n; i+=2){ dp[i][0] = min(dp[i-4][0], dp[i-4][1]) + four(vector\u0026lt;LL\u0026gt;({a[i-3], a[i-2], a[i-1], a[i]})); dp[i][1] = min(dp[i-6][0], dp[i-6][1]) + six(vector\u0026lt;LL\u0026gt;({a[i-5], a[i-4], a[i-3], a[i-2], a[i-1], a[i]})); } printf(\u0026#34;%d\\n\u0026#34;, min(dp[n-1][0], dp[n-1][1])); } } F Fraction Construction Problem é¢˜æ„","title":"nowcoder 2020 å¤šæ ¡ ç¬¬ä¸‰åœº"},{"content":"nowcoder 2020 å¤šæ ¡ ç¬¬äº”åœº https://ac.nowcoder.com/acm/contest/5670\nB Graph tireæ ‘ï¼Œæœ€å°ç”Ÿæˆæ ‘\né¢˜æ„ï¼š\nç»™ä¸€ä¸ªå¸¦æœ‰è¾¹æƒçš„æ ‘ï¼Œå¯ä»¥åˆ é™¤æˆ–æ·»åŠ è¾¹ï¼Œä½†è¦ä¿è¯ï¼š\nå›¾è”é€š ç¯ä¸Šè¾¹æƒå¼‚æˆ–ä¸º0 Solution\nä¸ç®¡æ€ä¹ˆæ“ä½œï¼Œä¸¤ç‚¹è·¯å¾„ä¸Šè¾¹æƒçš„å¼‚æˆ–å€¼æ˜¯å›ºå®šçš„ï¼Œäºæ˜¯é—®é¢˜å°±è½¬åŒ–æˆä¸€ä¸ªæœ€å°ç”Ÿæˆæ ‘é—®é¢˜ã€‚æ¯æ¬¡é€‰å‡ºä¸è”é€šçš„ç‚¹é›†$S_1$, $S_2$, å°†ä»–ä»¬è”é€šçš„ä»£ä»·æ˜¯\n$$ \\min\\limits_{u\\in S_1 v\\in S_2} {\\mathord{dis}(u,v)} $$\nå¯ä»¥é€šè¿‡tireæ ‘å®ç°è¿™ä¸ªè¿‡ç¨‹ï¼Œå°±æ˜¯tireæ ‘åˆå¹¶å­èŠ‚ç‚¹ï¼Œå¤æ‚åº¦ä¸º$O(n\\log n)$\n#include \u0026lt;cstdio\u0026gt; #include \u0026lt;stack\u0026gt; #include \u0026lt;set\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;map\u0026gt; #include \u0026lt;time.h\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;memory.h\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;iomanip\u0026gt; #include \u0026lt;bitset\u0026gt; #include \u0026lt;unordered_map\u0026gt; #include \u0026lt;assert.h\u0026gt; #define P pair\u0026lt;int, int\u0026gt; #define LL long long #define LD long double #define PLL pair\u0026lt;LL, LL\u0026gt; #define mset(a, b) memset(a, b, sizeof(a)) #define rep(i, a, b) for (int i = a; i \u0026lt; b; i++) #define PI acos(-1.0) #define random(x) rand() % x #define debug(x) cout \u0026lt;\u0026lt; #x \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34; using namespace std; const int inf = 0x3f3f3f3f; const LL __64inf = 0x3f3f3f3f3f3f3f3f; #ifdef DEBUG const int MAX = 1e3 + 50; #else const int MAX = 3e6 + 50; #endif const int mod = 10007; LL pow2[100]; vector\u0026lt;P\u0026gt; G[MAX]; int dis[MAX]; struct Tire{ int nex[MAX][2]; int siz[MAX]; int tot ; LL ans; void init(){ ans = 0; siz[0] = 0; mset(nex[0], 0); tot = 1; } void add(int x, int d) { int rt = 0; for(int i = d; i \u0026gt;= 0; i--){ int e = x \u0026amp; pow2[i] ? 1 : 0; if(!nex[rt][e]) { mset(nex[tot], 0); siz[tot] = 0; nex[rt][e] = tot ++; } rt = nex[rt][e]; siz[rt] ++; } } LL query(int val, int u, int d) { int rt = u; LL res = val; for(int i = d; i \u0026gt;= 0; i--){ if(res \u0026amp; pow2[i]) { if(nex[rt][1]) { res ^= pow2[i]; rt = nex[rt][1]; } else rt = nex[rt][0]; } else { if(nex[rt][0]) { rt = nex[rt][0]; } else { res ^= pow2[i]; rt = nex[rt][1]; } } } return res; } LL merge(int l, int r, int val, int d, int row_d){ if(!nex[l][0] and !nex[l][1]) { return query(val, r, row_d); } LL res = inf; if(nex[l][0]) res = min(res, merge(nex[l][0], r, val, d-1, row_d)); if(nex[l][1]) res = min(res, merge(nex[l][1], r, val^pow2[d], d-1, row_d)); return res; } void dfs(int u, int val, int d) { if(nex[u][0]) dfs(nex[u][0], val, d-1); if(nex[u][1]) dfs(nex[u][1], val ^ pow2[d], d-1); if(!nex[u][0] or !nex[u][1]) return; int l = nex[u][0], r = nex[u][1]; if(siz[l] \u0026gt; siz[r]) swap(l, r); ans += 1LL * merge(l, r, 0, d-1, d-1) + pow2[d]; } }tire; void dfs(int u, int p, int d){ dis[u] = d; for(int i = 0; i \u0026lt; G[u].size(); i++){ int v = G[u][i].first; if(v == p) continue; dfs(v, u, d^G[u][i].second); } } int main(){ #ifdef DEBUG freopen64(\u0026#34;in\u0026#34;, \u0026#34;r\u0026#34;, stdin); #endif pow2[0] = 1; for(int i = 1; i \u0026lt; 32; i++) pow2[i] = pow2[i-1] \u0026lt;\u0026lt; 1; int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for(int i = 1; i \u0026lt; n; i++) { int u, v, c; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;u, \u0026amp;v, \u0026amp;c); u++, v++; G[u].emplace_back(v, c); G[v].emplace_back(u, c); } dfs(1, -1, 0); tire.init(); for(int i = 1; i \u0026lt;= n; i++) tire.add(dis[i], 29); tire.dfs(0, 0, 29); printf(\u0026#34;%lld\\n\u0026#34;, tire.ans); return 0; } D Drop Voicing æœ€é•¿ä¸Šå‡å­åºåˆ—\né¢˜æ„\nç»™ä¸€ä¸ªåºåˆ—$p_1\\dots p_n$ï¼Œå¯ä»¥è¿›è¡Œä¸¤ç§æ“ä½œï¼Œè¿›è¡Œè¿ç»­çš„ç¬¬ä¸€ä¸ªæ“ä½œè€—è´¹ä¸€ä¸ªä»£ä»·\næŠŠ$p_{n-1}$æ”¾åˆ°æœ€å‰é¢ $p_1$æ”¾åˆ°æœ€åé¢ æ±‚æŠŠåºåˆ—å˜æˆå‡åºçš„æœ€å°ä»£ä»·\nSolution\nç»“åˆä¸¤ç§æ“ä½œå…¶å®å°±æ˜¯æŠŠä¸€ä¸ªå…ƒç´ $p_i$ç§»åˆ°ä¸€ä¸ªä½ç½®ï¼Œéœ€è¦ä¸€ä¸ªä»£ä»·ã€‚äºæ˜¯å˜æˆæ±‚LIS\nint n; int a[MAX]; int b[MAX]; int solve(){ mset(b, 0); int ans = 0; for(int i = 1; i \u0026lt;= n; i++) { int idx = lower_bound(b, b+ans, a[i]) - b; b[idx] = a[i]; if(idx == ans) ans ++; } // cout \u0026lt;\u0026lt; n - ans \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; return ans; } int main(){ #ifdef DEBUG freopen64(\u0026#34;in\u0026#34;, \u0026#34;r\u0026#34;, stdin); #else ios::sync_with_stdio(0); cin.tie(0); #endif cin \u0026gt;\u0026gt; n; for(int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; a[i]; int ans = 0; for(int i = 0; i \u0026lt; n; i++) { rotate(a+1, a+2, a+n+1); ans = max(ans, solve()); } cout \u0026lt;\u0026lt; n - ans \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; return 0; } E Bogo Sort é¢˜æ„\nç»™ä¸€ä¸ªç½®æ¢ï¼Œæ±‚æœ‰å¤šå°‘ç§æ’åˆ—å¯ä»¥é€šè¿‡è¿™ä¸ªç½®æ¢å˜æˆå‡åº\nfrom math import gcd def lcm(a:int, b:int) -\u0026gt;int: return a * b // gcd(a, b) n = int(input()) a = [0] + list(map(int, input().split())) vis = [False for i in range(len(a))] ans = 1 for i in range(1, n+1): x = a[i] if vis[x] : continue cur = 0 while not vis[x] : vis[x] = True cur += 1 x = a[x] ans = lcm(ans, cur) print(ans) ","permalink":"https://Anlarry.github.io/posts/acm-icpc/nowcoder-2020-%E5%A4%9A%E6%A0%A1-%E7%AC%AC%E4%BA%94%E5%9C%BA/","summary":"nowcoder 2020 å¤šæ ¡ ç¬¬äº”åœº https://ac.nowcoder.com/acm/contest/5670\nB Graph tireæ ‘ï¼Œæœ€å°ç”Ÿæˆæ ‘\né¢˜æ„ï¼š\nç»™ä¸€ä¸ªå¸¦æœ‰è¾¹æƒçš„æ ‘ï¼Œå¯ä»¥åˆ é™¤æˆ–æ·»åŠ è¾¹ï¼Œä½†è¦ä¿è¯ï¼š\nå›¾è”é€š ç¯ä¸Šè¾¹æƒå¼‚æˆ–ä¸º0 Solution\nä¸ç®¡æ€ä¹ˆæ“ä½œï¼Œä¸¤ç‚¹è·¯å¾„ä¸Šè¾¹æƒçš„å¼‚æˆ–å€¼æ˜¯å›ºå®šçš„ï¼Œäºæ˜¯é—®é¢˜å°±è½¬åŒ–æˆä¸€ä¸ªæœ€å°ç”Ÿæˆæ ‘é—®é¢˜ã€‚æ¯æ¬¡é€‰å‡ºä¸è”é€šçš„ç‚¹é›†$S_1$, $S_2$, å°†ä»–ä»¬è”é€šçš„ä»£ä»·æ˜¯\n$$ \\min\\limits_{u\\in S_1 v\\in S_2} {\\mathord{dis}(u,v)} $$\nå¯ä»¥é€šè¿‡tireæ ‘å®ç°è¿™ä¸ªè¿‡ç¨‹ï¼Œå°±æ˜¯tireæ ‘åˆå¹¶å­èŠ‚ç‚¹ï¼Œå¤æ‚åº¦ä¸º$O(n\\log n)$\n#include \u0026lt;cstdio\u0026gt; #include \u0026lt;stack\u0026gt; #include \u0026lt;set\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;map\u0026gt; #include \u0026lt;time.h\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;memory.h\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;iomanip\u0026gt; #include \u0026lt;bitset\u0026gt; #include \u0026lt;unordered_map\u0026gt; #include \u0026lt;assert.h\u0026gt; #define P pair\u0026lt;int, int\u0026gt; #define LL long long #define LD long double #define PLL pair\u0026lt;LL, LL\u0026gt; #define mset(a, b) memset(a, b, sizeof(a)) #define rep(i, a, b) for (int i = a; i \u0026lt; b; i++) #define PI acos(-1.","title":"nowcoder 2020 å¤šæ ¡ ç¬¬äº”åœº"},{"content":"POJ 3376 tire + manacher\né¢˜æ„ http://poj.org/problem?id=3376 ç»™$n$ä¸ªä¸²ï¼Œä¸¤ä¸¤è¿æ¥ï¼Œä¸€å…±$n^2$ç§ï¼Œæ±‚å…¶ä¸­æœ‰å¤šå°‘æ˜¯å›æ–‡ï¼Œ å­—ç¬¦ä¸²çš„é•¿åº¦å’Œå°äº$2e6$\nSolution åœ¨è€ƒè™‘ç¬¬$i$ä¸ªä¸²$t$å’Œå¤šå°‘ä¸ªä¸²$s$æ‹¼æ¥æ˜¯å›æ–‡æ—¶ï¼Œè®¡ç®—$s+t$æ˜¯å›æ–‡çš„æ•°é‡ï¼Œå°†æ‰€æœ‰æ•°é‡ç´¯åŠ å°±æ˜¯æœ€ç»ˆçš„å›æ–‡æ•°ã€‚\né¦–å…ˆè€ƒè™‘ä»€ä¹ˆæƒ…å†µä¸‹ï¼Œä¸¤ä¸ªä¸²æ‹¼æ¥ä¼šæ˜¯ä¸€ä¸ªå›æ–‡ä¸²ã€‚\ncase 1ï¼š s=reverse(t)\n$$ \\begin{cases} s = a_0\\dots a_{n-1} \\newline t = a_{n-1}\\dots a_0 \\end{cases} $$\ncase 2\n$$ \\begin{cases} \\begin{matrix} \u0026amp;\\mathrm{palindrome} \\newline s = a_0\\dots a_i \u0026amp;\\overbrace{a_{i+1}\\dots a_{n-1}} \\end{matrix} \\newline \\newline t = a_i\\dots a_0 \\end{cases} $$ ä»¥åŠå¯¹ç§°çš„æƒ…å†µ $$ \\begin{cases} s = a_{n-1}\\dots a_i \\newline \\begin{matrix} \\ \\ \\ \\ \\ \\mathrm{palindrome} \u0026amp;\\newline t = \\overbrace{a_0\\dots a_{i-1}} \u0026amp;a_i\\dots a_{n-1} \\end{matrix} \\end{cases} $$\nå› æ­¤å¯ä»¥å¯¹æ¯ä¸ªä¸²ï¼Œæ±‚å‡ºå‰ç¼€å’Œåç¼€æ˜¯å¦æ˜¯å›æ–‡ã€‚æŠŠæ‰€æœ‰çš„ä¸²æ”¾åˆ°tireæ ‘ä¸Šï¼Œç»Ÿè®¡ç­”æ¡ˆã€‚\nç”¨stlå¯èƒ½ä¼šTLE\n#include \u0026lt;cstdio\u0026gt; #include \u0026lt;stack\u0026gt; #include \u0026lt;set\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;map\u0026gt; #include \u0026lt;time.h\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; //#include \u0026lt;memory.h\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;iomanip\u0026gt; #include \u0026lt;cassert\u0026gt; // #include \u0026lt;unordered_map\u0026gt; #define P pair\u0026lt;int, int\u0026gt; #define LL long long #define LD long double #define PLL pair\u0026lt;LL, LL\u0026gt; #define mset(a, b) memset(a, b, sizeof(a)) #define rep(i, a, b) for (int i = a; i \u0026lt; b; i++) #define PI acos(-1.0) #define random(x) rand() % x #define debug(x) cout \u0026lt;\u0026lt; #x \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34; using namespace std; const int inf = 0x3f3f3f3f; const LL __64inf = 0x3f3f3f3f3f3f3f3f; #ifdef DEBUG const int MAX = 2e6 + 50; #else const int MAX = 2e6 + 50; #endif const int mod = 998244353; int str_len[MAX]; char str[MAX\u0026lt;\u0026lt;1]; char* str_p[MAX]; int sufix_palin[MAX]; int prefix_parlin[MAX]; int *sufix_palin_p[MAX]; int *prefix_parlin_p[MAX]; int radius[MAX]; int n; int zero; int palin; struct Tire { int tot; int nex[MAX][26]; int siz[MAX]; int _siz[MAX]; int rest_palin[MAX]; void init(){ tot = 1; mset(nex[0], 0); siz[0] = 0; _siz[0] = 0; rest_palin[0] = 0; } void add(const int idx, char *s){ int last = 0; int rt = 0; for(int i = 0; i \u0026lt; str_len[idx]; i++){ int c = s[i] - \u0026#39;a\u0026#39;; if(!nex[rt][c] ){ mset(nex[tot], 0); siz[tot] = 0; _siz[tot] = 0; rest_palin[tot] = 0; nex[rt][c] = tot ++; } last = rt; rt = nex[rt][c]; if(i + 2 == str_len[idx]) _siz[rt]++; if(sufix_palin_p[idx][i]){ rest_palin[last]++; } } siz[rt]++; } int* operator [] (int idx){ return nex[idx]; } }tire; string manacherStr(int len, char *s){ string res = \u0026#34;#\u0026#34;; for(int i = 0; i \u0026lt; len; i++){ res += s[i]; res += \u0026#39;#\u0026#39;; } return res; } void solve(const int idx, char *s){ if(str_len[idx] == 0) return ; int R = -1; int C = -1; int Max = -1; string str = manacherStr(str_len[idx], s); for(int i = 0; i \u0026lt; str.size(); i++){ radius[i] = R \u0026gt; i ? min(radius[2*C-i], R-i+1) : 1; while(i + radius[i] \u0026lt; str.size() and i - radius[i] \u0026gt; -1) { if(str[i-radius[i]] == str[i+radius[i]]) radius[i]++; else break; } if(i + radius[i] \u0026gt; R) { R = i + radius[i]-1; C = i; } Max = max(Max, radius[i]); } if(Max - 1 == str_len[idx]) palin++; for(int i = 1; i+1 \u0026lt; str.size(); i++){ if(str[i] == \u0026#39;#\u0026#39;) { int len = radius[i]-1; int r = len / 2; int start_idx = (i-2) / 2 - r + 1; if(start_idx + len - 1 == str_len[idx]-1) sufix_palin_p[idx][start_idx] = 1; if(start_idx == 0) prefix_parlin_p[idx][start_idx+len-1] = 1; } else { int len = radius[i]-1; int r = len / 2; int start_idx = (i-1)/2 - r; if(start_idx + len - 1 == str_len[idx]-1) sufix_palin_p[idx][start_idx] = 1; if(start_idx == 0) prefix_parlin_p[idx][start_idx+len-1] = 1; } } } LL calcu(const int idx, char* s){ int rt = 0; LL res = 0; for(int i = str_len[idx]-1; i \u0026gt;= 0; i--){ int c = s[i] - \u0026#39;a\u0026#39;; rt = tire[rt][c] ; if(!rt) break; if(i == 0){ res += (LL)tire.siz[rt]; res += (LL)tire.rest_palin[rt]; } else if(i \u0026gt;= 1 and prefix_parlin_p[idx][i-1]){ res += (LL)tire.siz[rt]; } } return res; } int main(){ #ifdef DEBUG freopen(\u0026#34;in\u0026#34;, \u0026#34;r\u0026#34;, stdin); #endif tire.init(); scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); int cur = 0; for(int i = 0; i \u0026lt; n; i++) { int x; scanf(\u0026#34;%d%s\u0026#34;, \u0026amp;x, \u0026amp;str[cur]); zero += x == 0; str_p[i] = str+cur; str_len[i] = x; prefix_parlin_p[i] = prefix_parlin+cur; sufix_palin_p[i] = sufix_palin +cur; cur += x; } for(int i = 0; i \u0026lt; n; i++){ solve(i, str_p[i]); } for(int i = 0; i \u0026lt; n; i++) tire.add(i, str_p[i]); LL ans = 0; tire.rest_palin[0] = tire.siz[0] = 0; for(int i = 0; i \u0026lt; n; i++){ #ifdef DEBUG printf(\u0026#34;debug i:%d calcu:%d\\n\u0026#34;, i, calcu(i, str_p[i])); #endif ans += 1LL * calcu(i, str_p[i]); } ans += 1LL * zero * zero; ans += 1LL * zero * palin * 2; #ifdef DEBUG for(int i = 0; i \u0026lt; n; i++){ for(int j = 0; j \u0026lt; str_len[i]; j++) cout \u0026lt;\u0026lt; prefix_parlin_p[i][j] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; puts(\u0026#34;\u0026#34;); for(int j = 0; j \u0026lt; str_len[i]; j++) cout \u0026lt;\u0026lt; sufix_palin_p[i][j] \u0026lt;\u0026lt; \u0026#34; \u0026#34; ; puts(\u0026#34;\\n\u0026#34;); } #endif printf(\u0026#34;%lld\\n\u0026#34;, ans); return 0; } ","permalink":"https://Anlarry.github.io/posts/acm-icpc/poj-3376/","summary":"POJ 3376 tire + manacher\né¢˜æ„ http://poj.org/problem?id=3376 ç»™$n$ä¸ªä¸²ï¼Œä¸¤ä¸¤è¿æ¥ï¼Œä¸€å…±$n^2$ç§ï¼Œæ±‚å…¶ä¸­æœ‰å¤šå°‘æ˜¯å›æ–‡ï¼Œ å­—ç¬¦ä¸²çš„é•¿åº¦å’Œå°äº$2e6$\nSolution åœ¨è€ƒè™‘ç¬¬$i$ä¸ªä¸²$t$å’Œå¤šå°‘ä¸ªä¸²$s$æ‹¼æ¥æ˜¯å›æ–‡æ—¶ï¼Œè®¡ç®—$s+t$æ˜¯å›æ–‡çš„æ•°é‡ï¼Œå°†æ‰€æœ‰æ•°é‡ç´¯åŠ å°±æ˜¯æœ€ç»ˆçš„å›æ–‡æ•°ã€‚\né¦–å…ˆè€ƒè™‘ä»€ä¹ˆæƒ…å†µä¸‹ï¼Œä¸¤ä¸ªä¸²æ‹¼æ¥ä¼šæ˜¯ä¸€ä¸ªå›æ–‡ä¸²ã€‚\ncase 1ï¼š s=reverse(t)\n$$ \\begin{cases} s = a_0\\dots a_{n-1} \\newline t = a_{n-1}\\dots a_0 \\end{cases} $$\ncase 2\n$$ \\begin{cases} \\begin{matrix} \u0026amp;\\mathrm{palindrome} \\newline s = a_0\\dots a_i \u0026amp;\\overbrace{a_{i+1}\\dots a_{n-1}} \\end{matrix} \\newline \\newline t = a_i\\dots a_0 \\end{cases} $$ ä»¥åŠå¯¹ç§°çš„æƒ…å†µ $$ \\begin{cases} s = a_{n-1}\\dots a_i \\newline \\begin{matrix} \\ \\ \\ \\ \\ \\mathrm{palindrome} \u0026amp;\\newline t = \\overbrace{a_0\\dots a_{i-1}} \u0026amp;a_i\\dots a_{n-1} \\end{matrix} \\end{cases} $$","title":"POJ 3376"},{"content":"nowcoder 2020 å¤šæ ¡ ç¬¬äºŒåœº https://ac.nowcoder.com/acm/contest/5667\nA All with Pairs é¢˜æ„\nç»™$n$ä¸ªä¸²ï¼Œå®šä¹‰$f(s,t)$ä¸º$s$å‰ç¼€å’Œ$t$åç¼€æœ€é•¿çš„é•¿åº¦ï¼Œæ±‚$\\sum_i\\sum_j f(s_i, s_j)^2$\nSolution\nå…ˆæŠŠæ¯ä¸ªä¸²çš„åç¼€hashçš„å€¼å­˜ä¸‹æ¥ï¼Œå¯¹æ¯ä¸ªä¸²$s_i$,æ±‚$\\sum_j f(s_i, s_j)^2$ã€‚å¯¹äº$s_i$çš„æ¯ä¸ªå‰ç¼€éƒ½å¯ä»¥æŸ¥è¯¢hashæ±‚å‡º å¯¹åº”å¤šå°‘åç¼€ï¼Œä½†æ˜¯æœ‰å¯èƒ½ä¸€å¯¹$s_i, s_j$ä¼šæœ‰å¤šä¸ªè´¡çŒ®ï¼Œå› æ­¤è¦ç”¨nextæ•°ç»„å»é‡\nconst unsigned long long base = 131; // vector\u0026lt;string\u0026gt; str; string str[MAX]; unordered_map\u0026lt;unsigned long long, int\u0026gt; mp; int nex[MAX]; int cnt[MAX]; void get_hash(const string \u0026amp;s){ unsigned long long res = 0; unsigned long long p = 1; for(int i = s.size()-1; i \u0026gt;= 0; i--){ // unsigned long long x = s[i] - \u0026#39;a\u0026#39;+1; res += (s[i]-\u0026#39;a\u0026#39;+1) * p; p *= base; mp[res]++; } } void get_next(const string \u0026amp;t){ nex[0] = -1; int k = -1; for(int i = 1; i \u0026lt; t.size(); i++){ while(k \u0026gt; -1 and t[k+1] != t[i]) k = nex[k]; if(t[k+1] == t[i]) k++; nex[i] = k; } } int main(){ #ifdef DEBUG freopen(\u0026#34;in\u0026#34;, \u0026#34;r\u0026#34;, stdin); #endif int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); // cin \u0026gt;\u0026gt; n; for(int i = 0; i \u0026lt; n; i++){ // string s; cin \u0026gt;\u0026gt; str[i]; // str.push_back(s); get_hash(str[i]); } LL ans = 0; for(int i = 0; i \u0026lt; n; i++){ unsigned long long cur_has = 0 ; for(int j = 0; j \u0026lt; str[i].size(); j++){ cur_has = cur_has * base + (str[i][j] - \u0026#39;a\u0026#39; + 1); // cnt[j] = mp[cur_has]; auto it = mp.find(cur_has); if(it != mp.end()) cnt[j] = it-\u0026gt;second; else cnt[j] = 0; } get_next(str[i]); for(int j = 1; j \u0026lt; str[i].size(); j++){ if(nex[j] \u0026gt;= 0) cnt[nex[j]] -= cnt[j]; } for(LL j = 0; j \u0026lt; str[i].size(); j++){ ans = (ans + 1LL * cnt[j] * (j+1LL) % mod * (j+1LL) % mod) % mod; } } printf(\u0026#34;%lld\\n\u0026#34;, ans); // cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } B Boundary é¢˜æ„\nåœ†æ˜¯è¿‡åŸç‚¹çš„ï¼Œé€‰ä¸€ä¸ªèƒ½ç»è¿‡æœ€å¤šç‚¹çš„åœ†\nP pts[5000]; // map\u0026lt;tuple\u0026lt;LL, LL, LL, LL\u0026gt;, int\u0026gt; cnt; vector\u0026lt;pair\u0026lt;double, double\u0026gt;\u0026gt; p; void update(LL x1, LL y1, LL x2, LL y2){ LL cir_x1 = (x1*x1 + y1*y1) * y2 - (x2*x2 + y2*y2) * y1; LL cir_x2 = 2 * (x1 * y2 - x2 * y1); LL cir_y1 = (x2*x2 + y2*y2) * x1 - (x1*x1 + y1*y1) * x2; LL cir_y2 = 2 * (x1 * y2 - x2 * y1); if(cir_x2 == 0) return ; p.push_back(make_pair(1.0 * cir_x1 / cir_x2, 1.0 * cir_y1 / cir_y2)); } int main(){ #ifdef DEBUG freopen(\u0026#34;in\u0026#34;, \u0026#34;r\u0026#34;, stdin); #endif int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for(int i = 1; i \u0026lt;= n; i++){ scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;pts[i].first, \u0026amp;pts[i].second); } if(n \u0026lt;= 2) { printf(\u0026#34;%d\\n\u0026#34;, n); return 0; } for(int i = 1; i \u0026lt;= n; i++){ for(int j = 1; j \u0026lt; i; j++){ update(pts[i].first, pts[i].second, pts[j].first, pts[j].second); } } sort(p.begin(), p.end()); if(p.size() == 0){ printf(\u0026#34;%d\\n\u0026#34;, 1); return 0; } pair\u0026lt;double, double\u0026gt; cur = p[0]; int ans = 0, tmp = 0; for(int i = 0; i \u0026lt; p.size(); i++){ if(p[i] == cur) {tmp++; ans = max(ans, tmp);} else { cur = p[i]; tmp = 1; ans = max(ans, tmp); } } ans *= 2; int res ; for(int i = 1; i \u0026lt;= n; i++){ int cur = i; if(cur * (cur-1) == ans) { res = cur; break; } } printf(\u0026#34;%d\\n\u0026#34;, res); } F Fake Maxpooling é¢˜æ„\nç»™ä¸€ä¸ªçŸ©é˜µï¼Œ$A_{i,j}=lcm(i,j)$ï¼Œåœ¨æ¯ä¸ª$k\\times k$å­çŸ©é˜µä¸­é€‰å‡ºæœ€å¤§çš„å…ƒç´ æ±‚å’Œ\nSolution\nç»´æŠ¤æ¨ªç«–çš„å•è°ƒé˜Ÿåˆ—ï¼Œæˆ–è€…æš´åŠ›\nint k; struct stk { P stack[5050]; int lenth; int start_idx; int front; stk() : lenth(0), start_idx(0), front(0) {} void push(int x, int idx){ while(!empty() and top() \u0026lt; x) { pop(); } stack[lenth++] = {x, idx}; start_idx = idx; } int max(){ while(!empty() and stack[front].second \u0026lt; start_idx - k + 1) front ++; return stack[front].first; } int top(){ return stack[lenth-1].first; } void pop(){ lenth--; } bool empty(){ return lenth == front; } void clear(){ lenth = 0; front = 0; start_idx = 0; } }; inline int A(int x, int y){ return x * y / __gcd(x, y); } stk col_stk[5050]; stk row_stk; int main(){ #ifdef DEBUG freopen64(\u0026#34;in\u0026#34;, \u0026#34;r\u0026#34;, stdin); #endif int n, m; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;n, \u0026amp;m, \u0026amp;k); for(int i = 1; i \u0026lt;= m; i++){ for(int j = 1; j \u0026lt; k; j++){ col_stk[i].push(A(i, j), j); } } LL ans = 0; for(int i = 1; i \u0026lt;= n-k+1; i++){ for(int j = 1; j \u0026lt;= m; j++){ col_stk[j].push(A(i+k-1,j), i+k-1); } for(int j = 1; j \u0026lt; k; j++){ row_stk.push(col_stk[j].max(), j); } for(int j = k; j \u0026lt;= m; j++){ row_stk.push(col_stk[j].max(), j); ans += (LL) row_stk.max(); } row_stk.clear(); } printf(\u0026#34;%lld\\n\u0026#34;, ans); return 0; } G Greater and Greater é¢˜æ„\nç»™ä¸€ä¸ªé•¿åº¦ä¸º$n$çš„åºåˆ—A, å’Œä¸€ä¸ªé•¿åº¦ä½$m$çš„åºåˆ—Bï¼Œæ±‚Aæœ‰å¤šå°‘ä½ç½®å¯¹åº”å…ƒç´ éƒ½å¤§äºB\nSolution\nè€ƒè™‘bitsetï¼Œ$f(i, j)$è¡¨ç¤ºåºåˆ—Aä½ç½®$i$,åºåˆ—Bä½ç½®$j$ï¼Œåé¢çš„å…ƒç´ Aå¯¹åº”å¤§äºBï¼Œè¦æ±‚çš„å°±æ˜¯$\\sum f(i, 1)$\nA : 1 4 2 8 5 7 B : 2 3 3 æ¯”å¦‚$f(3, 1)$å¯ä»¥é€šè¿‡$f(4, 2)$è½¬ç§»è¿‡æ¥ï¼Œ$f(3, 2)$å¯ä»¥ç”¨$f(4, 3)$è½¬ç§»è¿‡æ¥ï¼Œ$f(3, 3)$ç›´æ¥æ¯”è¾ƒA[3],B[3]ï¼Œå¯ä»¥å‘ç°è¿™äº›è½¬ç§»éƒ½è¦æ¯”è¾ƒA[3],B[i]\næ‰€ä»¥å¯¹æ¯ä¸ªA[i]æ±‚ä¸€ä¸ªæ–°çš„bitset\\ Sï¼ŒA[i]å¤§äºB[j]ç¬¬$j$ä½å°±ä¸º1\nè½¬ç§»å°±æ˜¯ $f_i=(f_{i+1}\u0026raquo;1 | I_m) \u0026amp; S_i$\nint a[MAX], b[MAX]; P A[MAX], B[MAX]; vector\u0026lt;bitset\u0026lt;N\u0026gt;\u0026gt; bits; int idx[MAX]; int main(){ #ifdef DEBUG freopen64(\u0026#34;in\u0026#34;, \u0026#34;r\u0026#34;, stdin); #endif int n, m; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); for(int i = 1; i \u0026lt;= n; i++) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i]); A[i] = make_pair(a[i], i); } for(int i = 1; i \u0026lt;= m; i++){ scanf(\u0026#34;%d\u0026#34;, \u0026amp;b[i]); B[i] = make_pair(b[i], i); } sort(A+1, A+1+n); sort(B+1, B+1+m); int i = 1, j = 0; bitset\u0026lt;N\u0026gt; cur; bits.push_back(cur); while(i \u0026lt;= n){ bool new_bit = 0; while(j \u0026lt; m \u0026amp;\u0026amp; A[i].first \u0026gt;= B[j+1].first){ new_bit = 1; cur[B[j+1].second] = 1; j++; } if(new_bit) { bits.push_back(cur); } idx[A[i].second] = bits.size()-1; i++; } bitset\u0026lt;N\u0026gt; f; int ans = 0; for(int i = n; i \u0026gt;= 1; i--){ f \u0026gt;\u0026gt;= 1; f[m] = 1; f \u0026amp;= bits[idx[i]]; ans += f[1]; } printf(\u0026#34;%d\\n\u0026#34;, ans); } J Just Shuffle é¢˜æ„\nè¦æ±‚ä¸€ä¸ªç½®æ¢$P$ï¼Œä½¿å¾—${1,2,\\dots,n}$åœ¨$P$ç½®æ¢$k$æ¬¡åæˆä¸ºæ’åˆ—$A$\nkæ˜¯ç´ æ•°\nSolution\nå°±æ˜¯è¯´$A=P^k$,å·²çŸ¥$A,k$ï¼Œæ±‚$P$ã€‚æŠŠ$A$åˆ†è§£æˆ$(cir_1)(cir_2)\\dots$ï¼Œå¯¹æ¯ä¸ªå¾ªç¯$cir$,æˆ‘ä»¬çŸ¥é“$P^k(cir_i)=cir_{i+1}$ã€‚\næˆ‘ä»¬æƒ³è®©$cir_i$ç½®æ¢$sk$æ¬¡ï¼Œè®©$sk\\ mod\\ len(cir)=1$ï¼Œå°±å¯ä»¥æ±‚å‡º$P(cir_i)$\nint a[MAX]; int ans[MAX]; bool vis[MAX]; void extend_Euclid(int a, int b, int \u0026amp;x, int \u0026amp;y) { if(b == 0){ x = 1; y = 0; return; } extend_Euclid(b, a % b, x, y); int tmp = x; x = y; y = tmp - (a / b) * y; } int main(){ #ifdef DEBUG freopen(\u0026#34;in\u0026#34;, \u0026#34;r\u0026#34;,stdin); #endif int n, k; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;k); for(int i = 1; i \u0026lt;= n; i++){ scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i]); } for(int i = 1; i \u0026lt;= n; i++){ if(vis[i]) continue; vector\u0026lt;int\u0026gt; cir; int x = i; while(!vis[x]) { cir.push_back(x); vis[x] = 1; x = a[x]; } int s = k % cir.size(); int y = 1; int w, m; extend_Euclid(s, cir.size(), w, m); if(w \u0026lt; 0) { int ww = -w; int tmp = (ww + cir.size() -1) / cir.size(); w += tmp * cir.size(); } y = w; // while(s * y % cir.size() != 1){ // y ++; // // printf(\u0026#34;%d\u0026#34;, s * y % cir.size()); // } for(int j = 0; j \u0026lt; cir.size(); j++){ ans[cir[j]] = cir[(j+y)%cir.size()]; } } for(int i = 1; i \u0026lt;= n; i++) printf(\u0026#34;%d \u0026#34;, ans[i]); puts(\u0026#34;\u0026#34;); return 0; } ","permalink":"https://Anlarry.github.io/posts/acm-icpc/nowcoder-2020-%E5%A4%9A%E6%A0%A1-%E7%AC%AC%E4%BA%8C%E5%9C%BA/","summary":"nowcoder 2020 å¤šæ ¡ ç¬¬äºŒåœº https://ac.nowcoder.com/acm/contest/5667\nA All with Pairs é¢˜æ„\nç»™$n$ä¸ªä¸²ï¼Œå®šä¹‰$f(s,t)$ä¸º$s$å‰ç¼€å’Œ$t$åç¼€æœ€é•¿çš„é•¿åº¦ï¼Œæ±‚$\\sum_i\\sum_j f(s_i, s_j)^2$\nSolution\nå…ˆæŠŠæ¯ä¸ªä¸²çš„åç¼€hashçš„å€¼å­˜ä¸‹æ¥ï¼Œå¯¹æ¯ä¸ªä¸²$s_i$,æ±‚$\\sum_j f(s_i, s_j)^2$ã€‚å¯¹äº$s_i$çš„æ¯ä¸ªå‰ç¼€éƒ½å¯ä»¥æŸ¥è¯¢hashæ±‚å‡º å¯¹åº”å¤šå°‘åç¼€ï¼Œä½†æ˜¯æœ‰å¯èƒ½ä¸€å¯¹$s_i, s_j$ä¼šæœ‰å¤šä¸ªè´¡çŒ®ï¼Œå› æ­¤è¦ç”¨nextæ•°ç»„å»é‡\nconst unsigned long long base = 131; // vector\u0026lt;string\u0026gt; str; string str[MAX]; unordered_map\u0026lt;unsigned long long, int\u0026gt; mp; int nex[MAX]; int cnt[MAX]; void get_hash(const string \u0026amp;s){ unsigned long long res = 0; unsigned long long p = 1; for(int i = s.size()-1; i \u0026gt;= 0; i--){ // unsigned long long x = s[i] - \u0026#39;a\u0026#39;+1; res += (s[i]-\u0026#39;a\u0026#39;+1) * p; p *= base; mp[res]++; } } void get_next(const string \u0026amp;t){ nex[0] = -1; int k = -1; for(int i = 1; i \u0026lt; t.","title":"nowcoder 2020 å¤šæ ¡ ç¬¬äºŒåœº"},{"content":"AtCoder-Sum of gcd of Tuples (Hard) é¢˜æ„ https://atcoder.jp/contests/abc162/tasks/abc162_e\næ±‚$\\sum\\gcd(a_1,a_2,\\cdots,a_n)$,å…¶ä¸­$a_i\\in[1,K]$\nSolution ç›´æ¥è®¡ç®—è‚¯å®šæ˜¯ä¸å¥½è®¡ç®—çš„ï¼Œå¯ä»¥è€ƒè™‘æŒ‰$gcd$çš„å€¼è¿›è¡Œåˆ†ç±»ï¼Œé—®é¢˜å°±è½¬åŒ–ä¸ºä¸€ä¸ªè®¡æ•°é—®é¢˜\n$\\displaystyle \\gcd(a,b)=d\\Rightarrow\\gcd(\\frac{a}{d},\\frac{b}{d})=1$\n$\\displaystyle {\\gcd(a_1,\\cdots, a_n)=dçš„æ•°é‡}={\\gcd(\\frac{a_1}{d},\\cdots,\\frac{a_n}{d})=1çš„æ•°é‡}$\né‚£ä¹ˆï¼Œ\n$$ Ans=\\sum_{d=1}^{K}dF(\\lfloor\\frac{K}{d}\\rfloor, N) $$\nå…¶ä¸­$F(K,N)$è¡¨ç¤º$\\gcd(a_1,\\cdots,a_N)=1$çš„ä¸ªæ•°ï¼Œ$a_i\\in[1,K]$\nå¯ä»¥ç”¨å®¹æ–¥ç®—å‡º$\\displaystyle F(K,N)=K^N-\\sum_{i=1}^{K}F(\\lfloor\\frac{K}{i}\\rfloor)$\n#include \u0026lt;cstdio\u0026gt; #include \u0026lt;stack\u0026gt; #include \u0026lt;set\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;map\u0026gt; #include \u0026lt;time.h\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;memory.h\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;iomanip\u0026gt; // #include \u0026lt;unordered_map\u0026gt; #define P pair\u0026lt;int, int\u0026gt; #define LL long long #define LD long double #define PLL pair\u0026lt;LL, LL\u0026gt; #define mset(a, b) memset(a, b, sizeof(a)) #define rep(i, a, b) for (int i = a; i \u0026lt; b; i++) #define PI acos(-1.0) #define random(x) rand() % x #define debug(x) cout \u0026lt;\u0026lt; #x \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34; using namespace std; const int inf = 0x3f3f3f3f; const LL __64inf = 0x3f3f3f3f3f3f3f3f; #ifdef DEBUG const int MAX = 1e6 + 50; #else const int MAX = 1e6 + 50; #endif const int mod = 1e9 + 7; LL N,K; LL f[MAX]; LL fact[MAX]; inline LL add(LL x, LL y){ LL res = x + y; return res \u0026gt;= mod ? res - mod : res; } inline LL qpow(LL x, LL n){ LL res = 1; while (n) { if(n \u0026amp;1) res = res * x % mod; x = x * x % mod; n \u0026gt;\u0026gt;= 1; } return res; } LL F(LL K, LL N){ if(f[K]) return f[K]; LL \u0026amp;res =f[K]; if(K==1){ return res = 1; } // res = qpow(K, N); res = fact[K]; for(LL i = 2, j; i \u0026lt;= K; i=j+1){ j = K/(K/i); // res = add(res, mod-F(K/i, N)); LL tmp = (j-i+1LL) * F(K/i, N) % mod; res = add(res, mod-tmp); } return res; } int main(){ #ifdef DEBUG freopen(\u0026#34;in\u0026#34;, \u0026#34;r\u0026#34;, stdin); #endif scanf(\u0026#34;%lld%lld\u0026#34;, \u0026amp;N, \u0026amp;K); for(LL i = 1; i \u0026lt;= K; i++) fact[i] = qpow(i, N); LL ans = 0; f[1] = 1LL; for(LL k= 1; k \u0026lt;= K; k++){ F(k, N); } for(LL i = 1, j; i \u0026lt;= K; i++){ ans += f[K/i] % mod * i % mod; if(ans \u0026gt;= mod) ans -= mod; } printf(\u0026#34;%lld\\n\u0026#34;, ans); } ","permalink":"https://Anlarry.github.io/posts/acm-icpc/atcoder-sum-of-gcd-of-tuples/","summary":"AtCoder-Sum of gcd of Tuples (Hard) é¢˜æ„ https://atcoder.jp/contests/abc162/tasks/abc162_e\næ±‚$\\sum\\gcd(a_1,a_2,\\cdots,a_n)$,å…¶ä¸­$a_i\\in[1,K]$\nSolution ç›´æ¥è®¡ç®—è‚¯å®šæ˜¯ä¸å¥½è®¡ç®—çš„ï¼Œå¯ä»¥è€ƒè™‘æŒ‰$gcd$çš„å€¼è¿›è¡Œåˆ†ç±»ï¼Œé—®é¢˜å°±è½¬åŒ–ä¸ºä¸€ä¸ªè®¡æ•°é—®é¢˜\n$\\displaystyle \\gcd(a,b)=d\\Rightarrow\\gcd(\\frac{a}{d},\\frac{b}{d})=1$\n$\\displaystyle {\\gcd(a_1,\\cdots, a_n)=dçš„æ•°é‡}={\\gcd(\\frac{a_1}{d},\\cdots,\\frac{a_n}{d})=1çš„æ•°é‡}$\né‚£ä¹ˆï¼Œ\n$$ Ans=\\sum_{d=1}^{K}dF(\\lfloor\\frac{K}{d}\\rfloor, N) $$\nå…¶ä¸­$F(K,N)$è¡¨ç¤º$\\gcd(a_1,\\cdots,a_N)=1$çš„ä¸ªæ•°ï¼Œ$a_i\\in[1,K]$\nå¯ä»¥ç”¨å®¹æ–¥ç®—å‡º$\\displaystyle F(K,N)=K^N-\\sum_{i=1}^{K}F(\\lfloor\\frac{K}{i}\\rfloor)$\n#include \u0026lt;cstdio\u0026gt; #include \u0026lt;stack\u0026gt; #include \u0026lt;set\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;map\u0026gt; #include \u0026lt;time.h\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;memory.h\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;iomanip\u0026gt; // #include \u0026lt;unordered_map\u0026gt; #define P pair\u0026lt;int, int\u0026gt; #define LL long long #define LD long double #define PLL pair\u0026lt;LL, LL\u0026gt; #define mset(a, b) memset(a, b, sizeof(a)) #define rep(i, a, b) for (int i = a; i \u0026lt; b; i++) #define PI acos(-1.","title":"AtCoder-Sum of gcd of Tuples"},{"content":"arch lab Download archlab-handout\nå®‰è£…æ¨¡æ‹Ÿå™¨ è§£å†³undefined reference to â€™matherrâ€˜\nå‚è€ƒ Y86-64æ¨¡æ‹Ÿå™¨çš„å®‰è£…ä¸å‡ºç°å¯¹\u0026rsquo;matherr\u0026rsquo;æœªå®šä¹‰å¼•ç”¨é—®é¢˜çš„è§£å†³\nPart A åœ¨è¿™éƒ¨åˆ†è¦åœ¨sim/miscä¸­å®Œæˆï¼Œæˆ‘ä»¬è¦ç¼–å†™å’Œæ¨¡æ‹Ÿä¸‰ä¸ªY86-64ç¨‹åº\nsum.ysï¼š éå†é“¾è¡¨æ±‚å’Œ\n# begin at 0 .pos 0 irmovq stack,%rsp call main halt .align 8 ele1: .quad 0x00a .quad ele2 ele2: .quad 0x0b0 .quad ele3 ele3: .quad 0xc00 .quad 0 main: irmovq ele1,%rdi call rsum ret rsum: xorq %rax,%rax andq %rdi,%rdi je L1 pushq %rbx mrmovq (%rdi),%rbx mrmovq 8(%rdi),%rdi call rsum addq %rbx,%rax popq %rbx L1: ret .pos 0x200 stack: ç”¨YASç¼–è¯‘åï¼Œå†ç”¨YISè¿è¡Œ\nlinux\u0026gt; make *.yo inux\u0026gt; ../misc/yis *.yo rsum.ys: ç”¨é€’å½’çš„æ–¹å¼æ±‚å’Œ\n# begin at 0 .pos 0 irmovq stack,%rsp call main halt .align 8 ele1: .quad 0x00a .quad ele2 ele2: .quad 0x0b0 .quad ele3 ele3: .quad 0xc00 .quad 0 main: irmovq ele1,%rdi call rsum ret rsum: xorq %rax,%rax andq %rdi,%rdi je L1 pushq %rbx mrmovq (%rdi),%rbx mrmovq 8(%rdi),%rdi call rsum addq %rbx,%rax popq %rbx L1: ret .pos 0x200 stack: copy.ys: å°†srcå¤åˆ¶åˆ°dst\n# begin at 0 .pos 0 irmovq stack,%rsp call main halt .align 8 src: .quad 0x00a .quad 0x0b0 .quad 0xc00 # Destination block dest: .quad 0x111 .quad 0x222 .quad 0x333 main: irmovq src,%rdi irmovq dest,%rsi irmovq $3,%rdx call copy_block ret copy_block: xorq %rax, %rax irmovq $1,%r14 irmovq $8,%r13 pushq %rbx andq %rdx,%rdx jmp test loop: mrmovq (%rdi),%rbx addq %r13,%rdi rmmovq %rbx,(%rsi) addq %r13,%rsi xorq %rbx,%rax subq %r14,%rdx test: jne loop popq %rbx ret .pos 0x200 stack: Part B è¿™éƒ¨åˆ†åœ¨sim/seqå®Œæˆï¼Œæˆ‘ä»¬éœ€è¦ä¿®æ”¹seq-full.hclï¼Œ ç»™SEQæ·»åŠ iaddqæŒ‡ä»¤\nseq-full.hcl\nç„¶åæ ¹æ®æ–‡æ¡£æµ‹è¯•\n./ssim -t ../y86-code/asumi.yo (cd ../y86-code; make testssim) (cd ../ptest; make SIM=../seq/ssim) (cd ../ptest; make SIM=../seq/ssim TFLAGS=-i) æµ‹è¯•å‡æˆåŠŸ\nPart C è¿™éƒ¨åˆ†è¦åœ¨sim/pipeä¸­å®Œæˆ\næˆ‘ä»¬çš„ç›®çš„æ˜¯ä¼˜åŒ–ncopyï¼Œç„¶ä»–æ›´å¿«å®Œæˆï¼Œä¼šæ ¹æ®CPEç»™å‡ºä¸€ä¸ªåˆ†æ•°\nStep1\næ·»åŠ iaddqï¼ˆç±»ä¼¼äºPartBï¼‰ï¼Œç„¶åæµ‹è¯•\nunix\u0026gt; make psim VERSION=full unix\u0026gt; ./psim -t sdriver.yo unix\u0026gt; ./psim -t ldriver.yo unix\u0026gt; ./correctness.pl unix\u0026gt; ./benchmark.pl ç„¶è€Œç«Ÿç„¶è¿˜æ˜¯0.0/60.0ï¼Œæ­¤æ—¶CPEå¤§æ¦‚å¯ä»¥è¾¾åˆ°11å·¦å³ï¼Œå¯æ˜¯ä»10.5æ‰å¼€å§‹è®°åˆ†\nStep2\nè€ƒè™‘å¾ªç¯å±•å¼€ï¼Œå°†å¾ªç¯å±•å¼€8æ¬¡ï¼Œåˆ†æ•°å¤§æ¦‚å¯ä»¥æé«˜åˆ°40å¤š\nå¾ªç¯å±•å¼€åï¼Œå°±å¯ä»¥æ”¹å˜æŒ‡ä»¤æ‰§è¡Œçš„é¡ºåºï¼Œé¿å…æ•°æ®å†’é™©\nmrmovq (%rdi),%r8 rmmovq %r8,(%rsi) è¿™æ ·ä¼šæœ‰ä¸€ä¸ªæ°”æ³¡ï¼Œå¦‚æœå…ˆæŠŠ8ä¸ªæ•°æ®éƒ½æ”¾åˆ°å¯„å­˜å™¨ï¼Œåœ¨æ”¾åˆ°ç›®æ ‡åœ°å€å°±å¯ä»¥æ¶ˆé™¤æ°”æ³¡ï¼Œé™ä½æ‰§è¡Œçš„å‘¨æœŸæ•°\nStep3\nç„¶è€Œè¿˜æœ‰å‰©ä¸‹çš„ä½™æ•°æ²¡æœ‰å¤„ç†ï¼Œå¯ä»¥è€ƒè™‘å°†å‰©ä¸‹çš„ä½™æ•°å†å¾ªç¯å±•å¼€ä¸€æ¬¡ï¼Œæ­¤æ—¶å·²ç»æœ‰50å¤šåˆ†äº†\nStep4\nå°†å¾ªç¯å±•å¼€çš„æ¬¡æ•°æé«˜åˆ°10æ¬¡ï¼Œé‚£ä¹ˆæ€§èƒ½ä¼šæé«˜ä¸€ç‚¹ï¼Œä½†ä¸æ˜¯å¾ˆæ˜æ˜¾\nä¼˜åŒ–ä½™æ•°çš„å¤„ç†æ–¹æ³•ï¼Œæœ€ç»ˆå¯ä»¥å°†åˆ†æ•°æé«˜åˆ°56.1,å¹³å‡CPE=7.69, ncopy length= 847 bytes\nåº”è¯¥è¿˜å¯ä»¥ä¼˜åŒ–pipe-full.hclï¼Œncopy.yså› è¯¥ä¹Ÿè¿˜æœ‰æé«˜çš„ç©ºé—´ï¼Œä»¥ååœ¨è¡¥ä¸Šã€‚ã€‚ã€‚\nncopy.ys\nncopy: xorq %rax,%rax\t# count = 0 iaddq $-10,%rdx # jl L2\t# if so, goto Done: ## if so, goto Loop Loop:\tmrmovq (%rdi), %r8 mrmovq 0x8(%rdi), %r9 mrmovq 0x10(%rdi), %r10 mrmovq 0x18(%rdi), %r11 mrmovq 0x20(%rdi), %r12 mrmovq 0x28(%rdi), %r13 mrmovq 0x30(%rdi), %r14 mrmovq 0x38(%rdi), %rcx mrmovq 0x40(%rdi), %rbx mrmovq 0x48(%rdi), %rbp andq %r8,%r8 rmmovq %r8, (%rsi) rmmovq %r9, 8(%rsi) rmmovq %rbx, 0x40(%rsi) rmmovq %rbp, 0x48(%rsi) jle L1_2 iaddq $1, %rax L1_2: andq %r9,%r9 jle L1_3 iaddq $1, %rax L1_3: andq %r10,%r10 rmmovq %r10, 0x10(%rsi) rmmovq %r11, 0x18(%rsi) jle L1_4 iaddq $1, %rax L1_4: andq %r11,%r11 jle L1_5 iaddq $1, %rax L1_5: andq %r12,%r12 rmmovq %r12, 0x20(%rsi) rmmovq %r13, 0x28(%rsi) jle L1_6 iaddq $1, %rax L1_6: andq %r13,%r13 jle L1_7 iaddq $1, %rax L1_7: andq %r14,%r14 rmmovq %r14, 0x30(%rsi) rmmovq %rcx, 0x38(%rsi) jle L1_8 iaddq $1, %rax L1_8: andq %rcx,%rcx jle L1_9 iaddq $1, %rax L1_9: andq %rbx, %rbx jle L1_10 iaddq $1, %rax L1_10: andq %rbp, %rbp jle L1_11 iaddq $1, %rax L1_11: iaddq $0x50, %rdi iaddq $0x50, %rsi iaddq $-10, %rdx jge Loop L2: iaddq $9, %rdx jg Loop2 jl L2_Done mrmovq (%rdi),%r8 rmmovq %r8, (%rsi) andq %r8, %r8 jle Done iaddq $1, %rax L2_Done: ret Loop2: mrmovq (%rdi), %r8 mrmovq 8(%rdi), %r9 iaddq $-2, %rdx jg L2_0 je D3 # last 3 rmmovq %r8, (%rsi) rmmovq %r9, 8(%rsi) andq %r8,%r8 jle D2_1 iaddq $1, %rax D2_1: andq %r9, %r9 jle Done iaddq $1, %rax ret D3: mrmovq 0x10(%rdi), %r10 rmmovq %r8, (%rsi) rmmovq %r9, 8(%rsi) rmmovq %r10, 0x10(%rsi) andq %r8, %r8 jle D3_1 iaddq $1, %rax D3_1: andq %r9, %r9 jle D3_2 iaddq $1, %rax D3_2: andq %r10, %r10 jle Done iaddq $1, %rax ret L2_0: rmmovq %r8, (%rsi) rmmovq %r9, 8(%rsi) andq %r8,%r8 jle L2_1 iaddq $1, %rax L2_1: andq %r9, %r9 jle L2_2 iaddq $1, %rax L2_2: iaddq $0x10, %rdi iaddq $0x10, %rsi jmp Loop2 Done: ret End: Step5 å¾…æ›´\nã€‚ã€‚ã€‚\n","permalink":"https://Anlarry.github.io/posts/csapp/csapp-arch-lab/","summary":"arch lab Download archlab-handout\nå®‰è£…æ¨¡æ‹Ÿå™¨ è§£å†³undefined reference to â€™matherrâ€˜\nå‚è€ƒ Y86-64æ¨¡æ‹Ÿå™¨çš„å®‰è£…ä¸å‡ºç°å¯¹\u0026rsquo;matherr\u0026rsquo;æœªå®šä¹‰å¼•ç”¨é—®é¢˜çš„è§£å†³\nPart A åœ¨è¿™éƒ¨åˆ†è¦åœ¨sim/miscä¸­å®Œæˆï¼Œæˆ‘ä»¬è¦ç¼–å†™å’Œæ¨¡æ‹Ÿä¸‰ä¸ªY86-64ç¨‹åº\nsum.ysï¼š éå†é“¾è¡¨æ±‚å’Œ\n# begin at 0 .pos 0 irmovq stack,%rsp call main halt .align 8 ele1: .quad 0x00a .quad ele2 ele2: .quad 0x0b0 .quad ele3 ele3: .quad 0xc00 .quad 0 main: irmovq ele1,%rdi call rsum ret rsum: xorq %rax,%rax andq %rdi,%rdi je L1 pushq %rbx mrmovq (%rdi),%rbx mrmovq 8(%rdi),%rdi call rsum addq %rbx,%rax popq %rbx L1: ret .","title":"CSAPP arch lab"},{"content":"Prime Distance On Tree é¢˜æ„ Prime Distance On Tree\nç»™ä¸ªæ ‘ï¼Œä»æ ‘ä¸Šéšæœºé€‰å–ä¸€å¯¹ç‚¹$u,v$,æ±‚$\\delta(u,v)$æ˜¯ç´ æ•°çš„æ¦‚ç‡\nSolution å¯ä»¥ä»ç”Ÿæˆå‡½æ•°çš„è§’åº¦è€ƒè™‘\nå‡è®¾rtæ˜¯ä¸€ä¸ªæ ‘çš„æ ‘æ ¹ï¼Œè€Œä¸”rtçš„æ·±åº¦æ˜¯dï¼Œå°†æ ‘ä¸­èŠ‚ç‚¹çš„æ·±åº¦ç»Ÿè®¡å‡ºæ¥ï¼Œè®°ä¸º$f_{rtï¼Œd}$ï¼Œå¦‚æœ$u,v\u0026hellip;$æ˜¯rtçš„å­èŠ‚ç‚¹ï¼Œé‚£ä¹ˆrtå¯¹ç­”æ¡ˆçš„è´¡çŒ®å°±æ˜¯ç”Ÿæˆå‡½æ•°ä¸­ç´ æ•°é¡¹çš„ç³»æ•°ï¼Œé‚£ä¹ˆé—®é¢˜å°±æ˜¯æ€ä¹ˆè®¡ç®—ç”Ÿæˆå‡½æ•°äº†\n$$ \\sum_{u,v \\in son(rt)} f_{u,1} * f_{v, 1} $$\nè¿™ä¸ªå¼å­ä¸­çš„ç´ æ•°é¡¹ç³»æ•°å’Œä¸ä¸‹å¼æ˜¯ç›¸ç­‰çš„,è®¡ç®—$f$æ˜¯å¾ˆç®€å•çš„\n$$ \\Big(f_{rt,0}^2 - \\sum_{u \\in son(rt) }f_{u,1}^2\\Big) / 2 $$\nä¸ºäº†ç¡®ä¿å¤æ‚åº¦ä¸ä¼šå¤ªé«˜ï¼Œéœ€è¦ç”¨ç‚¹åˆ†æ²»\n#include \u0026lt;cstdio\u0026gt; #include \u0026lt;stack\u0026gt; #include \u0026lt;set\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;map\u0026gt; #include \u0026lt;time.h\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;memory.h\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;iomanip\u0026gt; // #include \u0026lt;unordered_map\u0026gt; #define P pair\u0026lt;int, int\u0026gt; #define LL long long #define LD long double #define PLL pair\u0026lt;LL, LL\u0026gt; #define mset(a, b) memset(a, b, sizeof(a)) #define rep(i, a, b) for (int i = a; i \u0026lt; b; i++) #define PI acos(-1.0) #define random(x) rand() % x #define debug(x) cout \u0026lt;\u0026lt; #x \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34; using namespace std; const int inf = 0x3f3f3f3f; const LL __64inf = 0x3f3f3f3f3f3f3f3f; #ifdef DEBUG const int MAX = 2e3 + 50; #else const int MAX = 1e5 + 50; #endif const int mod = 1e9 + 7; #include \u0026lt;complex\u0026gt; namespace Prime { vector\u0026lt;int\u0026gt; prime; bool isprime[MAX\u0026lt;\u0026lt;1]; void init(int n){ mset(isprime, 1); isprime[0] = isprime[1] = 0; for(int i = 2; i \u0026lt; n; i++){ if(isprime[i]){ prime.push_back(i); } for(int j = 0; j \u0026lt; prime.size() and prime[j] * i \u0026lt; n; j++){ isprime[i * prime[j]] = 0; if(i * prime[j] == 0) break; } } } } // namespace namePrimPrime namespace FFT { complex\u0026lt;double\u0026gt; a[MAX\u0026lt;\u0026lt;2], b[MAX\u0026lt;\u0026lt;2]; int rev[MAX]; void fft(complex\u0026lt;double\u0026gt; *a, int n, int inv){ int bit = 0; while((1\u0026lt;\u0026lt;bit) \u0026lt; n) bit++; for(int i = 0; i \u0026lt; n; i++){ rev[i] = (rev[i\u0026gt;\u0026gt;1]\u0026gt;\u0026gt;1) | ((i \u0026amp; 1) \u0026lt;\u0026lt; (bit-1)); if(i \u0026lt; rev[i]) swap(a[i], a[rev[i]]); } for(int mid = 1; mid \u0026lt; n; mid \u0026lt;\u0026lt;= 1){ complex\u0026lt;double\u0026gt; wn(cos(PI/mid), inv*sin(PI/mid)); for(int i = 0; i \u0026lt; n; i += (mid\u0026lt;\u0026lt;1)){ complex\u0026lt;double\u0026gt; w(1, 0); for(int j = 0; j \u0026lt; mid; j++, w *= wn){ complex\u0026lt;double\u0026gt; u = a[i+j], t = w * a[i+j+mid]; a[i+j] = u + t, a[i+j+mid] = u - t; } } } } void product(int n){ fft(a, n, 1); fft(b, n, 1); for(int i = 0; i \u0026lt;= n; i++) a[i] *= b[i]; fft(a, n, -1); } } // namespace nameFFTFFT vector\u0026lt;int\u0026gt; E[MAX]; bool vis[MAX]; // LL dep[MAX]; LL dep[MAX], dep_num[MAX]; int cnt; int siz[MAX]; int dfsG(int u, int p, int\u0026amp; Min, int \u0026amp;rt, int n){ siz[u] = 1; int Max = -1; for(int i = 0; i \u0026lt; E[u].size(); i++){ int v = E[u][i]; if(vis[v] or v == p) continue; siz[u] += dfsG(v, u, Min, rt, n); Max = max(Max, siz[v]); } Max = max(Max, n - siz[u]); if(Max \u0026lt; Min){ Min = Max, rt = u; } return siz[u]; } int dfsN(int u, int p){ int res = 1; for(int i = 0; i \u0026lt; E[u].size(); i++){ int v = E[u][i]; if(vis[v] or v == p) continue; res += dfsN(v, u); } return res; } int find_rt(int u){ int Min = inf; int rt = -1; int n = dfsN(u, -1); dfsG(u, -1, Min, rt, n); return rt; } LL dfs(int u, int p, int d){ // return max_dep dep[cnt++] = d; LL max_dep = d; for(int i = 0; i \u0026lt; E[u].size(); i++){ int v = E[u][i]; if(v == p or vis[v]) continue; max_dep = max(max_dep, dfs(v, u, d+1)); } return max_dep; } LL calcu(int u, int d){ // mset(dep, 0); cnt = 0; dfs(u, -1, d); LL Max = 0; for(int i = 0; i \u0026lt; cnt; i++){ dep_num[dep[i]]++; Max = max(Max, dep[i]); } LL res = 0; int N = 1; while(N \u0026lt;= Max * 2) N \u0026lt;\u0026lt;= 1; for(int i = 0; i \u0026lt; N; i++){ if(i \u0026lt;= Max) FFT::a[i] = FFT::b[i] = complex\u0026lt;double\u0026gt;(dep_num[i], 0); else FFT::a[i] = FFT::b[i] = complex\u0026lt;double\u0026gt;(0, 0); } FFT::product(N); for(int i = 0; i \u0026lt; Prime::prime.size() and Prime::prime[i] \u0026lt;= 2*Max; i++){ res += (LL)(FFT::a[Prime::prime[i]].real() / N + 0.5); } for(int i = 0; i \u0026lt; cnt; i++) dep_num[dep[i]]--; return res; } LL solve(int u){ // vis[u] = 1; int rt = find_rt(u); vis[rt] = 1; LL res = calcu(rt, 0); for(int i = 0; i \u0026lt; E[rt].size(); i++){ if(vis[E[rt][i]]) continue; res -= calcu(E[rt][i], 1); res += solve(E[rt][i]); } // for(int i = 0; i \u0026lt; E[rt].size(); i++){ // if(vis[E[rt][i]]) continue; // res += solve(E[rt][i]); // } return res; } int main(){ #ifdef DEBUG freopen(\u0026#34;in\u0026#34;, \u0026#34;r\u0026#34;, stdin); #endif int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); Prime::init(MAX \u0026lt;\u0026lt; 1); for(int i = 1; i \u0026lt; n; i++){ int u, v; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;u, \u0026amp;v); E[u].push_back(v); E[v].push_back(u); } LL up = solve(1); LL down = (LL)n * (n-1); printf(\u0026#34;%.7lf\\n\u0026#34;, 1.0 * up / down); return 0; } ","permalink":"https://Anlarry.github.io/posts/acm-icpc/codechef-primedst/","summary":"Prime Distance On Tree é¢˜æ„ Prime Distance On Tree\nç»™ä¸ªæ ‘ï¼Œä»æ ‘ä¸Šéšæœºé€‰å–ä¸€å¯¹ç‚¹$u,v$,æ±‚$\\delta(u,v)$æ˜¯ç´ æ•°çš„æ¦‚ç‡\nSolution å¯ä»¥ä»ç”Ÿæˆå‡½æ•°çš„è§’åº¦è€ƒè™‘\nå‡è®¾rtæ˜¯ä¸€ä¸ªæ ‘çš„æ ‘æ ¹ï¼Œè€Œä¸”rtçš„æ·±åº¦æ˜¯dï¼Œå°†æ ‘ä¸­èŠ‚ç‚¹çš„æ·±åº¦ç»Ÿè®¡å‡ºæ¥ï¼Œè®°ä¸º$f_{rtï¼Œd}$ï¼Œå¦‚æœ$u,v\u0026hellip;$æ˜¯rtçš„å­èŠ‚ç‚¹ï¼Œé‚£ä¹ˆrtå¯¹ç­”æ¡ˆçš„è´¡çŒ®å°±æ˜¯ç”Ÿæˆå‡½æ•°ä¸­ç´ æ•°é¡¹çš„ç³»æ•°ï¼Œé‚£ä¹ˆé—®é¢˜å°±æ˜¯æ€ä¹ˆè®¡ç®—ç”Ÿæˆå‡½æ•°äº†\n$$ \\sum_{u,v \\in son(rt)} f_{u,1} * f_{v, 1} $$\nè¿™ä¸ªå¼å­ä¸­çš„ç´ æ•°é¡¹ç³»æ•°å’Œä¸ä¸‹å¼æ˜¯ç›¸ç­‰çš„,è®¡ç®—$f$æ˜¯å¾ˆç®€å•çš„\n$$ \\Big(f_{rt,0}^2 - \\sum_{u \\in son(rt) }f_{u,1}^2\\Big) / 2 $$\nä¸ºäº†ç¡®ä¿å¤æ‚åº¦ä¸ä¼šå¤ªé«˜ï¼Œéœ€è¦ç”¨ç‚¹åˆ†æ²»\n#include \u0026lt;cstdio\u0026gt; #include \u0026lt;stack\u0026gt; #include \u0026lt;set\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;map\u0026gt; #include \u0026lt;time.h\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;memory.h\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;iomanip\u0026gt; // #include \u0026lt;unordered_map\u0026gt; #define P pair\u0026lt;int, int\u0026gt; #define LL long long #define LD long double #define PLL pair\u0026lt;LL, LL\u0026gt; #define mset(a, b) memset(a, b, sizeof(a)) #define rep(i, a, b) for (int i = a; i \u0026lt; b; i++) #define PI acos(-1.","title":"CodeChef - PRIMEDST"},{"content":"Polyaè®¡æ•° å°†æ³¢åˆ©äºšè®¡æ•°å®šç†æ•´ç†åœ¨è¿™é‡Œï¼Œä½œä¸ºä¸€ä¸ªæ€»ç»“å’Œä»‹ç»ï¼Œä¹Ÿæ–¹ä¾¿ä»¥åå¤ä¹ \nä¸ºä»€ä¹ˆå­¦ä¹ Polyaè®¡æ•°å®šç†\né€šè¿‡Polyaè®¡æ•°å®šç†ï¼Œæˆ‘ä»¬å¯ä»¥è®¡ç®—ç­‰ä»·ç±»çš„æ•°é‡ï¼Œæ¯”å¦‚ä¸‹é¢è¿™ä¸ªé—®é¢˜ï¼š\nç”¨$m$ç§é¢œè‰²ç»™ä¸€ä¸ªæ­£æ–¹å½¢æŸ“è‰²ï¼Œå¦‚æœæ­£æ–¹å½¢å¯ä»¥è‡ªç”±è½¬åŠ¨ï¼Œæ±‚æŸ“è‰²æ–¹æ¡ˆæ•°\nè®©æˆ‘ä»¬ä»ä¸€äº›æ¦‚å¿µå¼€å§‹\n1 ç­‰ä»·å…³ç³» 1.1 ç­‰ä»·å…³ç³»çš„å®šä¹‰ å‡è®¾$V$æ˜¯ä¸€ä¸ªé›†åˆï¼Œ$S$æ˜¯å®šä¹‰åœ¨$V$ä¸Šçš„ä¸€ä¸ªå…³ç³»ï¼Œè‹¥$S$æœ‰å¦‚ä¸‹æ€§è´¨ï¼š\nè‡ªåæ€§ ä¼ é€’æ€§ å¯¹ç§°æ€§ é‚£ä¹ˆï¼Œ $S$å°±æ˜¯ä¸€ä¸ªç­‰ä»·å…³ç³»\n$a$å’Œ$b$æœ‰å…³ç³»$S$,å¯ä»¥è®°ä¸º$aSb$\nå‡è®¾å®šä¹‰å…³ç³»$S$ï¼Œå›¾å½¢$a$å¯ä»¥æ—‹è½¬å¾—åˆ°$b$ $\\Leftrightarrow$ $aSb$\nä¾‹å¦‚å›¾ä¸­çš„$æ–¹å—_1$å’Œ$æ–¹å—_2$å…·æœ‰å…³ç³»$S$ï¼Œå³ä»–ä»¬å¯ä»¥é€šè¿‡æ—‹è½¬å¾—åˆ°å½¼æ­¤ï¼Œè€Œ$æ–¹å—_1$å’Œ$æ–¹å—_2$åˆ™æ²¡æœ‰å…³ç³»$S$\n1.2 ç­‰ä»·ç±» é€šè¿‡ä¸Šå›¾ï¼Œå¯ä»¥çœ‹å‡ºæ¥ï¼š$æ–¹å—_1$å’Œ$æ–¹å—_2$æ˜¯åŒä¸€ç±»çš„ï¼Œè€Œ$æ–¹å—_1$å’Œ$æ–¹å—_2$åˆ™æ˜¯å¦å¤–ä¸¤ç±»ï¼Œäºæ˜¯å¯ä»¥æƒ³åˆ°é›†åˆ$V$ä¸Šçš„ç­‰ä»·å…³ç³»$S$å°†é›†åˆçš„å…ƒç´ åˆ’åˆ†åˆ°ä¸åŒçš„ç±»ä¸­ï¼Œæˆ‘ä»¬æŠŠå®ƒç§°ä¸ºç­‰ä»·ç±»\nè€ŒåŒ…å«å…ƒç´ $a$çš„ç­‰ä»·ç±»åˆ™æ˜¯ç”±æ»¡è¶³$aSb$çš„æ‰€æœ‰å…ƒç´ $b$ç»„æˆçš„(å½“ç„¶ä¹ŸåŒ…å«å…ƒç´ $a$),å³$C(a)={b\\in V | \\ aSb}$\nä»”ç»†æƒ³ä¸€æƒ³ï¼Œä¸éš¾å‘ç°ä¸¤ä¸ªä¸åŒç­‰ä»·ç±»æ˜¯ä¸ç›¸äº¤çš„\n2 ç½®æ¢ç¾¤ 2.1 ç½®æ¢ç¾¤çš„å®šä¹‰ å‡è®¾$A={1,2,\\dotsc, n}$ï¼Œé€šè¿‡ç½®æ¢ï¼Œå°†$A$ä¸­çš„å…ƒç´ é‡æ–°æ’åˆ—ï¼Œå¾—åˆ°å¦ä¸€ä¸ªæ’åˆ—$a_1, a_2, \\dotsc, a_n$ï¼Œå¯ä»¥æŠŠè¿™ä¸ªè¿‡ç¨‹å†™æˆ\n$$ \\left ( \\begin{matrix} 1 \u0026amp; 2 \u0026amp; \\dotsc \u0026amp; n \\newline a_1 \u0026amp; a_2 \u0026amp; \\dotsc \u0026amp; a_n \\end{matrix} \\right ) $$\næ‰€ä»¥ï¼Œå¯ä»¥å°†ç½®æ¢çœ‹æˆä¸€ä¸ªåŒå°„å‡½æ•°$f:{1,2,\\dotsc, n} \\rightarrow {1,2,\\dotsc, n}$\nç½®æ¢ä¹‹é—´ä¹Ÿå¯è¿›è¡Œåˆæˆè¿ç®—\n$$ \\pi_1 = \\left ( \\begin{matrix} 1 \u0026amp; 2 \u0026amp; 3 \u0026amp; 4 \\newline 4 \u0026amp; 2 \u0026amp; 1 \u0026amp; 3 \\end{matrix} \\right ) \\ \\ \\pi_2 = \\left ( \\begin{matrix} 1 \u0026amp; 2 \u0026amp; 3 \u0026amp; 4 \\newline 2 \u0026amp; 1 \u0026amp; 4 \u0026amp; 3 \\end{matrix} \\right ) $$\n$$ \\pi_1 \\circ \\pi_2 =\\left ( \\begin{matrix} 1 \u0026amp; 2 \u0026amp; 3 \u0026amp; 4 \\newline 2 \u0026amp; 4 \u0026amp; 3 \u0026amp; 1 \\end{matrix} \\right ) $$ $\\pi_1 \\circ \\pi_2 (1) = \\pi_1(\\pi_2(1))=2$\nè€Œåœ¨ç½®æ¢é›†åˆ$X$ä¸Šå®šä¹‰çš„ç¾¤åˆ™ç§°ä¸ºç½®æ¢ç¾¤ï¼Œç½®æ¢ç¾¤ä¹Ÿæ˜¯ç¾¤ä¹Ÿè¦æ»¡è¶³ç¾¤çš„æ€§ è´¨\nè¿ç®—å°é—­ $\\pi_1 \\in X, \\pi_2 \\in X \\Rightarrow \\pi_1 \\circ \\pi_2 \\in X$ æ»¡è¶³ç»“åˆå¾‹ æœ‰å•ä½å…ƒï¼Œç½®æ¢$I(a)=a$ æœ‰é€†å…ƒï¼Œ$\\pi \\circ \\pi^{-1} = I$ ä½†æ˜¯ç½®æ¢ä¸è®¡ç®—ä¸åŒæŸ“è‰²æ¨¡å¼æ•°é‡æœ‰ä»€ä¹ˆå…³ç³»ï¼Ÿå›¾å½¢çš„æ—‹è½¬ç­‰å˜æ¢éƒ½å¯ä»¥ç”¨ä¸€ä¸ªåªç½®æ¢æ¥è¡¨ç¤º\næˆ‘ä»¬æŠŠ1-4æŒ‰é¡ºæ—¶é’ˆæ”¾åˆ°æ­£æ–¹å½¢çš„å››ä¸ªæ–¹å—ä¸­\n$\\pi_1=\\left(\\begin{matrix} 1 \u0026amp; 2 \u0026amp; 3 \u0026amp; 4 \\newline 1 \u0026amp; 2 \u0026amp; 3 \u0026amp; 4 \\end{matrix}\\right)$\næ—‹è½¬$90^\\circ$\n$\\pi_2=\\left(\\begin{matrix} 1 \u0026amp; 2 \u0026amp; 3 \u0026amp; 4 \\newline 4 \u0026amp; 1 \u0026amp; 2 \u0026amp; 3 \\end{matrix}\\right)$\n2.2 ç½®æ¢ç¾¤è¡ç”Ÿçš„ç­‰ä»·å…³ç³» å‡è®¾$G=(X,\\circ)$ï¼Œé€šè¿‡ç½®æ¢$\\pi\\in X$ï¼Œå…ƒç´ $a$å¯ä»¥è¢«ç½®æ¢ä¸ºå…¶ä»–å…ƒç´ $\\pi(a)=b$ï¼Œå¯ä»¥å‘ç°è¿™é‡Œä¹Ÿå­˜åœ¨ä¸€ç§ç­‰ä»·å…³ç³»ï¼Œ å¯ä»¥å®šä¹‰ç­‰ä»·å…³ç³»$S$:\n$$ aSb \\Leftrightarrow \\exist \\pi \\in G, \\pi(a)=b $$\n$\\pi \\in G ä¹Ÿå¯ä»¥æ¥è¡¨ç¤º \\pi \\in X$\nè€ŒåŒ…å«$a$çš„ç­‰ä»·ç±»$C(a)$æ˜¯ç”±æ‰€æœ‰æ»¡è¶³$aSb$çš„å…ƒç´ $b$ç»„æˆçš„ï¼Œå› æ­¤æˆ‘ä»¬ä¹Ÿå¯ä»¥è¯´ $$ C(a)={\\pi(a) \\ | \\ \\pi \\in G} $$\nå¦‚æœ$A={1,2,3}$\n$\\pi_1=\\left(\\begin{matrix} 1 \u0026amp; 2 \u0026amp; 3 \\newline 1 \u0026amp; 2 \u0026amp; 3 \\end{matrix}\\right)$\n$\\pi_2=\\left(\\begin{matrix} 1 \u0026amp; 2 \u0026amp; 3 \\newline 3 \u0026amp; 2 \u0026amp; 1 \\end{matrix}\\right)$\n$X={\\pi_1, \\pi_2}$,å¯ä»¥éªŒè¯$G={X,\\circ}$æ˜¯ä¸€ä¸ªç½®æ¢ç¾¤ï¼Œ${1,3}$æ˜¯ä¸€ä¸ªç­‰ä»·ç±»ï¼Œ${2}$æ˜¯ä¸€ä¸ªç­‰ä»·ç±»\nå¯ä»¥è¯æ˜è‡ªåã€å¯¹ç§°ã€ä¼ é€’æ˜¯æ»¡è¶³çš„\n3 ä¼¯æ©èµ›å¾·å¼•ç† è¿™ä¸ªå®šç†å°†ç»™å‡ºç½®æ¢ç¾¤è¡ç”Ÿå‡ºçš„ç­‰ä»·å…³ç³»çš„ï¼ˆä¸åŒï¼‰ç­‰ä»·å…³ç³»æ•°é‡çš„è®¡æ•°æ–¹æ³•\n3.1 ä¼¯æ©èµ›å¾·å¼•ç† å‡è®¾$G$æ˜¯ä¸€ä¸ªç½®æ¢ç¾¤ï¼Œ$a$æ˜¯$A$ä¸­çš„å…ƒç´ ï¼Œå¦‚æœ$\\pi(a)=a$ï¼Œåˆ™ç§°$A$ä¸­çš„å…ƒç´ $a$åœ¨ç½®æ¢$\\pi$ä¸‹æ˜¯ä¸å˜çš„(Invariant)ï¼Œ$Inv(\\pi)$è¡¨ç¤ºä¸å˜å…ƒç´ çš„æ•°é‡\nå®šç† å‡è®¾$G$æ˜¯ä¸€ä¸ªé›†åˆ$A$çš„ç½®æ¢ç¾¤ï¼Œè®¾$S$æ˜¯$G$ä¸Šè¡ç”Ÿå‡ºæ¥çš„ç­‰ä»·å…³ç³»ï¼Œé‚£ä¹ˆ$S$ä¸­çš„ç­‰ä»·ç±»çš„æ•°é‡ç”±ä¸‹å¼ç»™å‡º:\n$$ \\frac{1}{|G|} \\sum_{\\pi\\in G}Inv(\\pi) $$\n$|G|$æ˜¯ç½®æ¢ç¾¤ä¸­ç½®æ¢çš„æ•°é‡ï¼Œè®©æˆ‘ä»¬æ¥ç”¨ä¸€ä¸‹è¿™ä¸ªå®šç†ï¼Œå‡è®¾$G$ä¸‹é¢çš„ç½®æ¢ç»„æˆ\n$$ \\pi_1=\\left(\\begin{matrix} 1 \u0026amp; 2 \u0026amp; 3 \u0026amp; 4\\newline 1 \u0026amp; 2 \u0026amp; 3 \u0026amp; 4 \\end{matrix}\\right) , \\pi_2=\\left(\\begin{matrix} 1 \u0026amp; 2 \u0026amp; 3 \u0026amp; 4 \\newline 2 \u0026amp; 1 \u0026amp; 3 \u0026amp; 4 \\end{matrix}\\right) , $$\n$$ \\pi_3=\\left(\\begin{matrix} 1 \u0026amp; 2 \u0026amp; 3 \u0026amp; 4\\newline 1 \u0026amp; 2 \u0026amp; 4 \u0026amp; 3 \\end{matrix}\\right) , \\pi_4=\\left(\\begin{matrix} 1 \u0026amp; 2 \u0026amp; 3 \u0026amp; 4 \\newline 2 \u0026amp; 1 \u0026amp; 4 \u0026amp; 3 \\end{matrix}\\right) , $$\nå¯ä»¥çœ‹å‡ºæ¥ï¼Œæœ‰ä¸¤ä¸ªç­‰ä»·ç±»åˆ†åˆ«æ˜¯${1,2}$ï¼Œ${3, 4}$ï¼Œç­‰ä»·ç±»çš„æ•°é‡ä¸º$2$\nå¯ä»¥éªŒè¯$Inv(\\pi_1)=4,Inv(\\pi_2)=2,Inv(\\pi_3)=2,Inv(\\pi_4)=0$\n$$ ç­‰ä»·ç±»çš„æ•°é‡=\\frac{1}{4}(4+2+2+0)=2 $$\n3.2 ä¼¯æ©èµ›å¾·å¼•ç†çš„è¯æ˜ Part 1 è¿™ä¸ªè¯æ˜å¯ä»¥è·³è¿‡ï¼Œå¯¹åé¢é˜…è¯»æ²¡æœ‰ä»€ä¹ˆå½±å“\nå¯¹äº$A$ä¸­çš„å…ƒç´ $a$ï¼Œæˆ‘ä»¬å¯ä»¥å®šä¹‰ç¨³å®šç®—å­(Stabilizer)çš„æ¦‚å¿µï¼Œ$St(a)$æ˜¯ä¿æŒå…ƒç´ $a$ä¸å˜çš„ç½®æ¢çš„é›†åˆï¼Œ$St(a)={\\pi \\in G | \\pi(a) = a}$ï¼Œ\n$$ \\pi_1=\\left(\\begin{matrix} 1 \u0026amp; 2 \u0026amp; 3 \\newline 1 \u0026amp; 2 \u0026amp; 3 \\end{matrix}\\right) , \\pi_2=\\left(\\begin{matrix} 1 \u0026amp; 2 \u0026amp; 3 \\newline 2 \u0026amp; 3 \u0026amp; 1 \\end{matrix}\\right) , \\pi_3=\\left(\\begin{matrix} 1 \u0026amp; 2 \u0026amp; 3 \\newline 3 \u0026amp; 1 \u0026amp; 2 \\end{matrix}\\right) , $$ $St(2) = {\\pi_1}$ï¼Œ\nåŒ…å«$2$çš„ç­‰ä»·ç±»$C(2)={\\pi_1(2),\\pi_2(2),\\pi_3(2)}={1, 2, 3}$\nå¯ä»¥å‘ç°$|St(2)| \\times |C(2)| = |G| = 3$ï¼Œè¿™ä¸æ˜¯å·§åˆ\nå¼•ç† å‡è®¾$G$æ˜¯ä¸€ä¸ªç½®æ¢ç¾¤ï¼Œè€Œä¸”$a \\in A$ï¼Œé‚£ä¹ˆï¼Œ $$ |St(a)| \\times |C(a)| = |G| $$\nè®©æˆ‘ä»¬æ¥ç®€å•è¯æ˜è¿™ä¸ªå®šç†\nå‡è®¾$C(a)={b_1,b_2,\\dotsb, b_r}$ï¼Œé‚£ä¹ˆå­˜åœ¨ä¸€ä¸ª$\\pi_1$ï¼Œæ»¡è¶³$\\pi_1(a)=b_1$ï¼ŒåŒæ ·å­˜åœ¨$\\pi_2(a)=b_2$,$\\dotsb$,è®¾$P={\\pi_1, \\pi_2, \\dotsc, \\pi_r}$ï¼Œè€Œä¸”$|P|=|C(a)|$ï¼Œäºæ˜¯è½¬åŒ–ä¸ºè¯æ˜$|St(a)|\\times |P|=|G|$\nä»$G$ä¸­é€‰ä¸€ä¸ªç½®æ¢$\\pi$, $\\pi$ä¸€å®šå°†$a$ç½®æ¢æˆä¸€ä¸ªå…ƒç´ ï¼Œè®¾è¯¥å…ƒç´ ä¸º$b_k$ï¼Œå³$\\pi(a)=b_k$ï¼Œ\nå¦ä¸€ä¸ªæ–¹é¢ï¼Œ$\\pi_k(a)=b_k$,å› æ­¤$\\pi^{-1}_k \\circ \\pi(a)=a$ï¼Œå³$\\pi^{-1}_k \\circ \\pi \\in St(a)$ï¼Œ\n$$ \\pi_k \\circ (\\pi_k^{-1} \\circ \\pi) = \\pi $$ è¿™è¯´æ˜$G$ä¸­çš„å…ƒç´ $\\pi$å¯ä»¥ç”±$St(a)$å’Œ$C(a)$ä¸­çš„å…ƒç´ åˆæˆå¾—åˆ°\nç„¶åæˆ‘ä»¬å†æ¥è¯´æ˜è¿™æ˜¯å”¯ä¸€çš„\nå‡è®¾$\\pi=\\pi_k\\circ \\gamma=\\pi_l \\circ \\delta$ ï¼Œ$\\gamma$å’Œ$\\delta$éƒ½åœ¨$St(a)$ä¸­ï¼Œå› æ­¤$\\pi_k \\circ \\gamma(a)=b_k=\\pi_l \\circ \\delta (a)=b_l$ï¼Œå› æ­¤$l=k$ï¼Œè¿™ç§ç»„åˆæ–¹å¼æ˜¯å”¯ä¸€çš„ï¼Œå› æ­¤$|St(a)| \\times |C(a)| = |G|$\nPart 2 è®©æˆ‘ä»¬ç»§ç»­è¯æ˜ä¼¯æ©èµ›å¾·å¼•ç†\nå‡è®¾$A={1,2,\\dotsc,n}$, $G={\\pi_1, \\pi_2, \\dotsc, \\pi_m}$ï¼Œè®©æˆ‘ä»¬çœ‹çœ‹ä¸‹é¢è¿™ä¸ªå¼å­çš„æ˜¯å¦æˆç«‹\n$$ |Inv(\\pi_1)|+|Inv(\\pi_2)|+\\dotsb+|Inv(\\pi_m)|=|St(1)|+|St(2)|+\\dotsb+|St(n)| $$\nå¯ä»¥å‘ç°éƒ½è®¡æ•°çš„æ˜¯æ»¡è¶³$\\pi(a)=a$åºå¯¹$\u0026lt;\\pi,a\u0026gt;$çš„ä¸ªæ•°ï¼Œå› æ­¤ç­‰å¼æ˜¯æˆç«‹çš„\nå°†ç­‰å¼ä¸¤è¾¹åŒæ—¶é™¤ä»¥|G|ï¼Œå·¦è¾¹å°±å¾—åˆ°äº†ä¼¯æ©èµ›å¾·å¼•ç†çš„å‹å¼ï¼Œè€Œå³è¾¹ï¼Œæ ¹æ®Part1ä¸­çš„å¼•ç†å¯ä»¥è½¬åŒ–ä¸º\n$$ \\frac{1}{C(1)}+\\frac{1}{C(2)}+\\dotsb+\\frac{1}{C(n)} \\ \\ \\ \\ (1) $$\nè€Œ$C(a)$æ˜¯ä¸€ä¸ªç­‰ä»·ç±»ï¼Œä¸¤ä¸ªç­‰ä»·ç±»çš„äº¤é›†è¦ä¹ˆæ˜¯å…¨é›†è¦ä¹ˆæ˜¯ç©ºé›†ï¼Œå‡è®¾$C(a)={b_1,b_2,\\dotsc, b_r}$,é‚£ä¹ˆï¼Œ\n$$ \\frac{1}{C(b_1)}+\\frac{1}{C(b_2)}+\\dotsb+\\frac{1}{C(b_r)}=\\frac{1}{r}+\\frac{1}{r}+\\dotsb+\\frac{1}{r}=1 $$\näºæ˜¯(1)å¼è®¡æ•°çš„å°±æ˜¯ç­‰ä»·ç±»çš„ä¸ªæ•°\n4 ç­‰ä»·ç€è‰² ä¼¯æ©èµ›å¾·å¼•ç†å’Œè®¡ç®—ç­‰ä»·ç€è‰²æ•°é‡æœ‰ä»€ä¹ˆå…³ç³»å‘¢?å…¶å®ä¼¯æ©èµ›å¾·å¼•ç†ä¸èƒ½ç›´æ¥å¸®åŠ©æˆ‘ä»¬è®¡ç®—ç­‰ä»·ç€è‰²çš„æ•°é‡ï¼Œä½†æ˜¯æˆ‘ä»¬å¯ä»¥é€‚å½“çš„å®šä¹‰ç­‰ä»·å…³ç³»ï¼Œç„¶åå†è®¡ç®—ç­‰ä»·ç€è‰²çš„æ•°é‡\nå‡è®¾$C(R,D)$ä½¿ç”¨$R$ä¸­çš„é¢œè‰²ï¼Œæ¥ç»™$D$ä¸­çš„å…ƒç´ æŸ“è‰²çš„ç€è‰²é›†åˆï¼Œ\nå‡è®¾$R$æ˜¯é»‘è‰²å’Œç™½è‰²ï¼Œ$D$æ˜¯å›¾ä¸­çš„èŠ‚ç‚¹ï¼Œé‚£ä¹ˆ$C(R,D)$æ˜¯ç»™å›¾ä¸­èŠ‚ç‚¹æŸ“è‰²çš„é›†åˆ $C(R,D)={C_1,C_2,\\dotsb, C_{16}}$\nå®šä¹‰åœ¨$C(R,D)$ä¸Šçš„ç½®æ¢$\\pi^*$ï¼Œå°†ä¸€ç§ç€è‰²å˜ä¸ºå¦ä¸€ç§ç€è‰²ï¼Œæ›´å½¢å¼ä¸€ç‚¹ï¼Œå‡å®š$f$æ˜¯ä¸€ä¸ªç€è‰²ï¼Œé‚£ä¹ˆæ–°ç€è‰²$\\pi^*f$å®šä¹‰ä¸º$(\\pi^*f)(a)$æ˜¯$f(\\pi(a))$\nåŒæ ·ï¼Œä¹Ÿå¯ä»¥å®šä¹‰$C(R,D)$ä¸Šçš„ç½®æ¢ç¾¤ï¼Œ$G^={\\pi^ \\ | \\ \\pi \\in G}$ï¼Œ$G$å’Œ$G^$çš„å…ƒç´ æ•°é‡ä¸€æ ·ï¼Œå› ä¸º$\\pi$å’Œ$\\pi^å¯¹åº”äºä¸€ç§ç›¸åŒæ—‹è½¬$ã€‚$G^$ä¹Ÿå¯ä»¥è¡ç”Ÿå‡ºç­‰ä»·å…³ç³»$S^$ï¼Œè€Œ$S^*$å°±æ˜¯æˆ‘ä»¬å…³æ³¨çš„ã€‚\nå‡è®¾$f,g$æ˜¯ä¸¤ä¸ªç€è‰²ï¼Œå¦‚æœæœ‰ä¸€ä¸ª$\\pi \\in G$($\\pi^\\in G^$)ï¼Œ$\\pi^*f=g$ï¼Œæˆ‘ä»¬å°±è®¤ä¸º$f,g$æ˜¯ç­‰ä»·çš„\næˆ‘ä»¬è¦æ±‚çš„$S^*$åˆ’åˆ†å‡ºæ¥çš„ç­‰ä»·ç±»çš„æ•°é‡\nä»ä¸Šå›¾å¯ä»¥çœ‹å‡ºæ¥$G^$çš„å¤§å°æ˜¯$3$ï¼Œè®¾$G^={\\pi_1^,\\pi_2^,\\pi_3^*}$ï¼Œåˆ†åˆ«å¯¹åº”é€†æ—¶é’ˆæ—‹è½¬$0^\\circ,120^\\circ, 240^\\circ$\n$$ \\pi_1^*=\\left(\\begin{matrix} C_1 \u0026amp; C_2 \u0026amp; C_3 \u0026amp; C_4 \u0026amp;C_5 \u0026amp; C_6 \u0026amp;C_7 \u0026amp; C_8 \u0026amp;C_9 \u0026amp; C_{10} \u0026amp; C_{11} \u0026amp; C_{12} \u0026amp; C_{13} \u0026amp; C_{14} \u0026amp; C_{15} \u0026amp; C_{16} \\newline C_1 \u0026amp; C_2 \u0026amp; C_3 \u0026amp; C_4 \u0026amp;C_5 \u0026amp; C_6 \u0026amp;C_7 \u0026amp; C_8 \u0026amp;C_9 \u0026amp; C_{10} \u0026amp; C_{11} \u0026amp; C_{12} \u0026amp; C_{13} \u0026amp; C_{14} \u0026amp; C_{15} \u0026amp; C_{16} \\end{matrix}\\right) $$\n$$ \\pi_2^*=\\left(\\begin{matrix} C_1 \u0026amp; C_2 \u0026amp; C_3 \u0026amp; C_4 \u0026amp;C_5 \u0026amp; C_6 \u0026amp;C_7 \u0026amp; C_8 \u0026amp;C_9 \u0026amp; C_{10} \u0026amp; C_{11} \u0026amp; C_{12} \u0026amp; C_{13} \u0026amp; C_{14} \u0026amp; C_{15} \u0026amp; C_{16} \\newline C_1 \u0026amp; C_3 \u0026amp; C_4 \u0026amp; C_2 \u0026amp;C_5 \u0026amp; C_8 \u0026amp;C_6 \u0026amp; C_7 \u0026amp;C_{10} \u0026amp; C_{11} \u0026amp; C_{9} \u0026amp; C_{13} \u0026amp; C_{14} \u0026amp; C_{12} \u0026amp; C_{15} \u0026amp; C_{16} \\end{matrix}\\right) $$\n$$ \\pi_3^*=\\left(\\begin{matrix} C_1 \u0026amp; C_2 \u0026amp; C_3 \u0026amp; C_4 \u0026amp;C_5 \u0026amp; C_6 \u0026amp;C_7 \u0026amp; C_8 \u0026amp;C_9 \u0026amp; C_{10} \u0026amp; C_{11} \u0026amp; C_{12} \u0026amp; C_{13} \u0026amp; C_{14} \u0026amp; C_{15} \u0026amp; C_{16} \\newline C_1 \u0026amp; C_4 \u0026amp; C_2 \u0026amp; C_3 \u0026amp;C_5 \u0026amp; C_7 \u0026amp;C_8 \u0026amp; C_6 \u0026amp;C_{11} \u0026amp; C_{9} \u0026amp; C_{10} \u0026amp; C_{14} \u0026amp; C_{12} \u0026amp; C_{13} \u0026amp; C_{15} \u0026amp; C_{16} \\end{matrix}\\right) $$\n$Inv(\\pi_1^)=16,Inv(\\pi_2^)=4,Inv(\\pi_2^*)=4$\næ ¹æ®ä¼¯æ©èµ›å¾·å¼•ç†ï¼Œ\n$$ ç­‰ä»·ç€è‰²çš„ä¸ªæ•°=\\frac{1}{3}(16+4+4)=8 $$ å¯ä»¥ä»ä¸Šå›¾ä¸­éªŒè¯è¿™ä¸ªç»“æœçš„æ­£ç¡®æ€§ï¼Œä¸ºäº†ä¸$S$ä¸­çš„ç­‰ä»·ç±»åŒºåˆ†ï¼Œæˆ‘ä»¬ç§°$S^*$ä¸­ç­‰ä»·ç±»ä¸ºæ¨¡å¼\né€šè¿‡æšä¸¾$C(R,D)$ä¸­çš„å…ƒç´ ï¼Œå†æšä¸¾$\\pi^$è®¡ç®—$Inv(\\pi^)$è¿‡äºéº»çƒ¦ï¼Œå¯ä»¥ç›´æ¥è®¡ç®—$Inv(\\pi^)$ï¼Œäºæ˜¯æœ‰äº†ä¸‹é¢çš„å®šç†*\n5 Polyaå®šç†çš„ç‰¹æ®Šæƒ…å†µ 5.1 å¾ªç¯åˆ†è§£ è®©æˆ‘ä»¬å†å›åˆ°ç½®æ¢ï¼Œè®¾ç½®æ¢$\\pi_1=\\left(\\begin{matrix} 1 \u0026amp; 2 \u0026amp; 3 \u0026amp; 4 \u0026amp; 5\\newline 2 \u0026amp; 3 \u0026amp; 4 \u0026amp; 5 \u0026amp; 1 \\end{matrix}\\right)$ è®©æˆ‘ä»¬ä¸æ–­åœ°é‡å¤è¿™ä¸ªç½®æ¢ï¼Œé‚£ä¹ˆå¯ä»¥æ‰¾åˆ°å¾ªç¯èŠ‚$1\\rightarrow 2 \\rightarrow 3 \\rightarrow 4 \\rightarrow 5 \\rightarrow 1$ï¼Œé‚£æˆ‘ä»¬å°±æŠŠ$\\pi$ç®€å†™$(12345)$\nå†æ¯”å¦‚$\\pi_2=\\left(\\begin{matrix} 1 \u0026amp; 2 \u0026amp; 3 \u0026amp; 4 \u0026amp; 5 \u0026amp; 6 \\newline 5 \u0026amp; 1 \u0026amp; 6 \u0026amp; 3 \u0026amp; 2 \u0026amp; 4 \\end{matrix}\\right)$ å¯ä»¥ç®€å†™æˆ$(152)(364)$ï¼Œè¿™ä¸€è¿‡ç¨‹è¢«ç§°ä¸ºå¾ªç¯åˆ†è§£\nå®šä¹‰$cyc(\\pi)$æ˜¯$\\pi$å¾ªç¯åˆ†è§£ä¸­å¾ªç¯èŠ‚çš„æ•°é‡ï¼Œæ¯”å¦‚$cyc(\\pi_1)=1ï¼Œcyc(\\pi_2)=2$\n5.2 Polya è®¡æ•°çš„ç‰¹æ®Šæƒ…å†µ å®šç† å‡è®¾$G$æ˜¯é›†åˆ$D$çš„ç½®æ¢ç¾¤ï¼Œä¸”$C(R,D)$æ˜¯ä½¿ç”¨$R$ä¸­é¢œè‰²ç»™$D$ä¸­å…ƒç´ æŸ“è‰²çš„é›†åˆï¼Œ$R$ä¸­é¢œè‰²çš„æ•°é‡çš„$m$,$C(R,D)$ä¸­ä¸åŒç€è‰²æ•°é‡($S^*$ä¸­ç­‰ä»·ç±»çš„æ•°é‡)ç”±ä¸‹å¼ç»™å‡ºï¼š\n$$ \\frac{1}{|G|} (m^{cyc(\\pi_1)}+m^{cyc(\\pi_2)}+\\dotsb+m^{cyc(\\pi_k)}) $$ å…¶ä¸­$G={\\pi_1, \\pi_2, \\dotsb, \\pi_k}$\nè®©æˆ‘ä»¬ç”¨è¿™ä¸ªå®šç†å†ç®—ä¸€æ¬¡ç­‰ä»·ç€è‰²çš„ä¸ªæ•°ï¼Œå‡å®šå°†ä¸­é—´çš„ç‚¹è®°ä¸º$1$å· $0^\\circæ—‹è½¬ï¼Œ\\pi_1=(1)(2)(3)(4)$\n$120^\\circï¼Œ \\pi_2=(1)(234)$\n$240^\\circï¼Œ \\pi_3=(1)(234)$\n$$ ç­‰ä»·ç€è‰²çš„ä¸ªæ•°=\\frac{1}{3}(2^4+2^2+2^2)=8 $$\n5.3 å¾ªç¯æŒ‡æ ‡$P_G$ å¦‚æœå¯ä»¥ç”¨ä¸€ä¸ªç”Ÿæˆå‡½æ•°æ¥æè¿°ä¸€ä¸ªç½®æ¢ç¾¤ï¼Œé‚£å°†å¾ˆæœ‰ç”¨ï¼Œè¿™å°†å¼•å‡ºæ›´ä¸€èˆ¬çš„æ³¢åˆ©äºšè®¡æ•°å®šç†ï¼Œå› æ­¤æœ‰äº†å¾ªç¯æŒ‡æ ‡$P_G$çš„æ¦‚å¿µ\nå‡è®¾$\\pi=(1)(23)(45)(6)(789)(10)$ï¼Œå¯ä»¥å°†ä»–ç¼–ç ä¸º$x_1^3x_2^2x_3$\nå¯ä»¥çœ‹å‡ºæ¥ç¼–ç æ–¹å¼ï¼Œ$x_i$ä»£è¡¨é•¿åº¦ä¸º$i$çš„å¾ªç¯èŠ‚ï¼Œ$x_i$çš„å¹‚æ¬¡$b$ä»£è¡¨æœ‰å¤šå°‘ä¸ªé•¿åº¦ä¸º$i$çš„å¾ªç¯èŠ‚\näºæ˜¯å¯ä»¥ç”¨æ¯ä¸ªç½®æ¢ç¼–ç çš„å’Œå†é™¤ä»¥$|G|$,\n$$ P_G(x_1,x_2,\\dotsc,x_k)=\\frac{1}{G}\\sum_{\\pi\\in G} x_1^{b_1}x_2^{b_2}\\dotsb x_k^{b_k} $$ æ¥ç¼–ç ä¸€ä¸ªç½®æ¢ç¾¤\nå¯¹5.2çš„ä¾‹å­ä¸­çš„ç½®æ¢ç¾¤è¿›è¡Œç¼–ç ï¼Œ$P_G=\\frac{1}{3}(x_1^4+x_1x_3+x_1x_3)$\nè€Œä¸”ï¼Œæ³¢åˆ©äºšè®¡æ•°çš„ç‰¹æ®Šæƒ…å†µå°±æ˜¯$P_G$ä¸­$x_1,x_2,\\dotsc,x_k$éƒ½å–$m$çš„æƒ…å†µ\n5.4 Polyaè®¡æ•°ç‰¹æ®Šæƒ…å†µçš„è¯æ˜ åŒæ ·å¯ä»¥è·³è¿‡è¿™ä¸€éƒ¨åˆ†\nå°†Polyaè®¡æ•°ç‰¹æ®Šæƒ…å†µçš„å…¬å¼ä¸ä¼¯æ©èµ›å¾·å¼•ç†å¯¹æ¯”ï¼Œå› æ­¤åªè¦è¯æ˜$m^{cyc(\\pi)}=Inv(\\pi^*)$\nè€ƒè™‘ä¸€ä¸ªå…·ä½“çš„æƒ…å†µï¼Œå‡å®š$\\pi=(1)(23)(456)(7)$ï¼Œç»è¿‡ç½®æ¢2ï¼Œ3çš„é¢œè‰²äº¤æ¢ï¼Œ$4,5,6$å°†é¢œè‰²ç»™ä¸‹ä¸€ä¸ªï¼Œè‹¥$f$æ˜¯ä¸€ä¸ªç€è‰²ï¼Œè¦è®©$\\pi^*(f)=f$ï¼Œé‚£ä¹ˆ$f$åœ¨æ¯ä¸ªå¾ªç¯èŠ‚ä¸­çš„æŸ“è‰²è¦ä¸€è‡´ï¼Œå› æ­¤ä¸€å…±æœ‰$m^{cyc(\\pi)}$è¿™ä¹ˆå¤š$f$\n6 Polyaè®¡æ•°å®šç† ä¸ºä»€ä¹ˆè¿˜æœ‰è¿™ä¸ªï¼Ÿ\nå¦‚æœè¦æ±‚å¿…é¡»è¦ç”¨é»‘è‰²$k$æ¬¡ï¼Œæˆ–è€…è‡³å°‘ä¸€æ¬¡é»‘è‰²ï¼Œä¸Šé¢çš„å®šç†å°±ä¸å¥½ç”¨äº†\n6.1 ç»™é¢œè‰²åŠ æƒ å‡è®¾ç€è‰²$f$ç»™$D$æŸ“è‰²ï¼Œä½¿ç”¨çº¢è‰²$t_1$æ¬¡ï¼Œç»¿è‰²$t_2$æ¬¡ï¼Œè“è‰²$t_3$æ¬¡\nå‡å®šçº¢è‰²çš„æƒå€¼$w$ä¸º$r$,ç»¿è‰²$g$,è“è‰²$b$ï¼Œ\né‚£ä¹ˆç€è‰²$f$çš„æƒ$W(f)=r^{t_1}g^{t_2}b^{t_3}$ï¼Œè€Œå¦‚æœæŸ“è‰²$f,g$æ˜¯ç­‰ä»·çš„ï¼Œé‚£ä¹ˆä»–ä»¬çš„æƒæ˜¯ç›¸ç­‰çš„\näºæ˜¯ï¼Œæˆ‘ä»¬ä¹Ÿå¯ä»¥å®šä¹‰ä¸€ä¸ªç€è‰²ç­‰ä»·ç±»(æ¨¡å¼)çš„æƒç­‰äºä¸åŒç­‰ä»·ç±»çš„æƒä¹‹å’Œï¼ŒæŠŠè¿™ä¸ªç§°ä¸ºç€è‰²ç­‰ä»·ç±»ï¼ˆæ¨¡å¼ï¼‰çš„æƒï¼Œæˆ–è€…æ¨¡å¼é›†åˆçš„ç›®å½•ï¼Œå› ä¸ºä»–æ¦‚æ‹¬äº†æ¨¡å¼çš„æŸ“è‰²æ–¹å¼\næˆ‘ä»¬å†æ¥è€ƒè™‘5.2ä¸­çš„ä¾‹å­ï¼Œæ¨¡å¼ç›®å½•æ˜¯\n$$ w^4+2w^3b+2w^2b^2+2wb^3+b^4 $$\næ‰€æœ‰ç³»æ•°ä¹‹å’Œç­‰äºä¸åŒç­‰ä»·ç±»çš„ä¸ªæ•°ï¼Œ\nå¦‚æœè¦æ±‚ç”¨äº†2ä¸ªç™½è‰²ä¸¤ä¸ªé»‘çš„ç€è‰²æ–¹æ¡ˆæ•°ï¼Œå¯é€šè¿‡$w^2b^2$å‰çš„ç³»æ•°å¾—çŸ¥æ˜¯2ç§\nä¸‹é¢çš„å®šç†å°†ç»™å‡ºè®¡ç®—æ¨¡å¼ç›®å½•çš„æ–¹æ³•\n6.2 Polyaå®šç†å†…å®¹ å®šç† å‡è®¾$G$æ˜¯é›†åˆ$D$ä¸Šçš„ç½®æ¢ç¾¤ï¼Œè€Œ$C(R,D)$æ˜¯ç”¨$R$ä¸­çš„é¢œè‰²ç»™$D$ç€è‰²çš„é›†åˆï¼Œ$w$æ˜¯é¢œè‰²çš„æƒå€¼ï¼Œé‚£ä¹ˆ$C(R,D)çš„ç€è‰²çš„æ¨¡å¼ç›®å½•ä¸º$ï¼š\n$$ P_G\\bigg(\\sum_{r\\in R}w(r),\\sum_{r\\in R}w^2(r),\\dotsb,\\sum_{r\\in R}w^k(r)\\bigg) $$ å…¶ä¸­$P_G(x_1,x_2,\\dotsb,x_k)$æ˜¯å¾ªç¯æŒ‡æ ‡\nå†å›åˆ°ä¹‹å‰çš„ä¾‹å­\næˆ‘ä»¬å·²ç»çŸ¥é“$P_G=\\frac{1}{3}(x_1^4+x_1x_3+x_1x_3)$\nå‡å®šæˆ‘ä»¬ç”¨ç™½ï¼Œé»‘æŸ“è‰²ï¼Œæƒå€¼åˆ†åˆ«ä¸º$w,b$\n$$ \\sum_{r\\in R}w(r)=w+b,\\sum_{r\\in R}w^3(r)=w^3+b^3 $$ å¸¦å…¥$P_G$ $$ \\frac{1}{3}[(w+b)^4+2(w+b)(w^3+b^3)] $$\né€šè¿‡å¯¹é¢œè‰²æƒå€¼çš„ç®€å•èµ‹å€¼å°±èƒ½çš„è¦ä¸€äº›æœ‰ç”¨çš„ç»“è®º\nå¦‚æœæƒ³çŸ¥é“ä»¥ç”¨æœ‰å¤šå°‘ç§æŸ“è‰²æ¨¡å¼ï¼Œé‚£ä¹ˆåªè¦æŠŠæ‰€æœ‰çš„æƒå€¼éƒ½è®¾ä¸º$1$ å¦‚æœä¸æƒ³ç”¨æŸä¸€é¢œè‰²ï¼Œå°±æŠŠé¢œè‰²è®¾ä¸º$0$ï¼Œå…¶ä»–é¢œè‰²è®¾ä¸º$1$ å¦‚æœæƒ³çŸ¥é“ç”¨æŸä¸ªé¢œè‰²$k$æ¬¡çš„æ¨¡å¼æ•°ï¼Œå°±æŠŠå…¶ä»–é¢œè‰²è®¾ä¸º$1$ï¼Œæ±‚æ”¹é¢œè‰²æƒå€¼å¹‚æ¬¡ä¸º$k$å‰çš„ç³»æ•° . . . QAQ, ç»ˆäºå†™å®Œäº†ã€‚ã€‚ã€‚\n","permalink":"https://Anlarry.github.io/posts/acm-icpc/%E6%B3%A2%E9%87%8C%E4%BA%9A%E8%AE%A1%E6%95%B0/","summary":"Polyaè®¡æ•° å°†æ³¢åˆ©äºšè®¡æ•°å®šç†æ•´ç†åœ¨è¿™é‡Œï¼Œä½œä¸ºä¸€ä¸ªæ€»ç»“å’Œä»‹ç»ï¼Œä¹Ÿæ–¹ä¾¿ä»¥åå¤ä¹ \nä¸ºä»€ä¹ˆå­¦ä¹ Polyaè®¡æ•°å®šç†\né€šè¿‡Polyaè®¡æ•°å®šç†ï¼Œæˆ‘ä»¬å¯ä»¥è®¡ç®—ç­‰ä»·ç±»çš„æ•°é‡ï¼Œæ¯”å¦‚ä¸‹é¢è¿™ä¸ªé—®é¢˜ï¼š\nç”¨$m$ç§é¢œè‰²ç»™ä¸€ä¸ªæ­£æ–¹å½¢æŸ“è‰²ï¼Œå¦‚æœæ­£æ–¹å½¢å¯ä»¥è‡ªç”±è½¬åŠ¨ï¼Œæ±‚æŸ“è‰²æ–¹æ¡ˆæ•°\nè®©æˆ‘ä»¬ä»ä¸€äº›æ¦‚å¿µå¼€å§‹\n1 ç­‰ä»·å…³ç³» 1.1 ç­‰ä»·å…³ç³»çš„å®šä¹‰ å‡è®¾$V$æ˜¯ä¸€ä¸ªé›†åˆï¼Œ$S$æ˜¯å®šä¹‰åœ¨$V$ä¸Šçš„ä¸€ä¸ªå…³ç³»ï¼Œè‹¥$S$æœ‰å¦‚ä¸‹æ€§è´¨ï¼š\nè‡ªåæ€§ ä¼ é€’æ€§ å¯¹ç§°æ€§ é‚£ä¹ˆï¼Œ $S$å°±æ˜¯ä¸€ä¸ªç­‰ä»·å…³ç³»\n$a$å’Œ$b$æœ‰å…³ç³»$S$,å¯ä»¥è®°ä¸º$aSb$\nå‡è®¾å®šä¹‰å…³ç³»$S$ï¼Œå›¾å½¢$a$å¯ä»¥æ—‹è½¬å¾—åˆ°$b$ $\\Leftrightarrow$ $aSb$\nä¾‹å¦‚å›¾ä¸­çš„$æ–¹å—_1$å’Œ$æ–¹å—_2$å…·æœ‰å…³ç³»$S$ï¼Œå³ä»–ä»¬å¯ä»¥é€šè¿‡æ—‹è½¬å¾—åˆ°å½¼æ­¤ï¼Œè€Œ$æ–¹å—_1$å’Œ$æ–¹å—_2$åˆ™æ²¡æœ‰å…³ç³»$S$\n1.2 ç­‰ä»·ç±» é€šè¿‡ä¸Šå›¾ï¼Œå¯ä»¥çœ‹å‡ºæ¥ï¼š$æ–¹å—_1$å’Œ$æ–¹å—_2$æ˜¯åŒä¸€ç±»çš„ï¼Œè€Œ$æ–¹å—_1$å’Œ$æ–¹å—_2$åˆ™æ˜¯å¦å¤–ä¸¤ç±»ï¼Œäºæ˜¯å¯ä»¥æƒ³åˆ°é›†åˆ$V$ä¸Šçš„ç­‰ä»·å…³ç³»$S$å°†é›†åˆçš„å…ƒç´ åˆ’åˆ†åˆ°ä¸åŒçš„ç±»ä¸­ï¼Œæˆ‘ä»¬æŠŠå®ƒç§°ä¸ºç­‰ä»·ç±»\nè€ŒåŒ…å«å…ƒç´ $a$çš„ç­‰ä»·ç±»åˆ™æ˜¯ç”±æ»¡è¶³$aSb$çš„æ‰€æœ‰å…ƒç´ $b$ç»„æˆçš„(å½“ç„¶ä¹ŸåŒ…å«å…ƒç´ $a$),å³$C(a)={b\\in V | \\ aSb}$\nä»”ç»†æƒ³ä¸€æƒ³ï¼Œä¸éš¾å‘ç°ä¸¤ä¸ªä¸åŒç­‰ä»·ç±»æ˜¯ä¸ç›¸äº¤çš„\n2 ç½®æ¢ç¾¤ 2.1 ç½®æ¢ç¾¤çš„å®šä¹‰ å‡è®¾$A={1,2,\\dotsc, n}$ï¼Œé€šè¿‡ç½®æ¢ï¼Œå°†$A$ä¸­çš„å…ƒç´ é‡æ–°æ’åˆ—ï¼Œå¾—åˆ°å¦ä¸€ä¸ªæ’åˆ—$a_1, a_2, \\dotsc, a_n$ï¼Œå¯ä»¥æŠŠè¿™ä¸ªè¿‡ç¨‹å†™æˆ\n$$ \\left ( \\begin{matrix} 1 \u0026amp; 2 \u0026amp; \\dotsc \u0026amp; n \\newline a_1 \u0026amp; a_2 \u0026amp; \\dotsc \u0026amp; a_n \\end{matrix} \\right ) $$\næ‰€ä»¥ï¼Œå¯ä»¥å°†ç½®æ¢çœ‹æˆä¸€ä¸ªåŒå°„å‡½æ•°$f:{1,2,\\dotsc, n} \\rightarrow {1,2,\\dotsc, n}$\nç½®æ¢ä¹‹é—´ä¹Ÿå¯è¿›è¡Œåˆæˆè¿ç®—\n$$ \\pi_1 = \\left ( \\begin{matrix} 1 \u0026amp; 2 \u0026amp; 3 \u0026amp; 4 \\newline 4 \u0026amp; 2 \u0026amp; 1 \u0026amp; 3 \\end{matrix} \\right ) \\ \\ \\pi_2 = \\left ( \\begin{matrix} 1 \u0026amp; 2 \u0026amp; 3 \u0026amp; 4 \\newline 2 \u0026amp; 1 \u0026amp; 4 \u0026amp; 3 \\end{matrix} \\right ) $$","title":"æ³¢é‡Œäºšè®¡æ•°"},{"content":"Rock Paper Scissors Lizard Spock é¢˜æ„ï¼š Rock Paper Scissors Lizard Spock\næœ‰äº”ç§æ‰‹åŠ¿ï¼Œç±»ä¼¼äºçŸ³å¤´å‰ªåˆ€å¸ƒï¼Œæœ‰ä¸¤ä¸ªä¸²$s, t$,ç”±è¿™äº”ç§æ‰‹åŠ¿ç»„æˆï¼Œä»æŸä¸ªä½ç½®å¼€å§‹åŒ¹é…ï¼Œå¦‚æœ$t_i$èƒ½èµ¢$s_j$å¾—ä¸€åˆ†ï¼Œæ±‚ä¸€ä¸ª$pos(0\\le pos \\le len(s)-len(t))$ï¼Œä½¿å¾—å¾—åˆ†æœ€å¤š\nSolutionï¼š å°†ä¸Šå›¾è®°ä¸º$G$ï¼Œå¦‚æœ$op_1$å¯ä»¥èµ¢$op_2$ï¼Œåˆ™$G(op_1, op_2)=1$,\næšä¸¾å¯ä»¥å¾—åˆ†çš„æ‰‹åŠ¿,å‡è®¾å½“å‰æ‰‹åŠ¿ä¸º$op$,\n$$ \\begin{aligned} t\u0026rsquo;_i \u0026amp;=(reverse\\ t_i == op ? 1 : 0) \\newline s\u0026rsquo;_i \u0026amp;= G[op][s_i] \\end{aligned} $$\nå°†$t\u0026rsquo;,s\u0026rsquo;$åšå·ç§¯ï¼Œç´¯åŠ æ¯æ¬¡çš„ç»“æœï¼Œå†éå†ä¸€éåŒ¹é…çš„èµ·å§‹ä½ç½®ï¼Œå–æœ€å¤§å€¼\n#include \u0026lt;cstdio\u0026gt; #include \u0026lt;stack\u0026gt; #include \u0026lt;set\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;map\u0026gt; #include \u0026lt;time.h\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;memory.h\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;iomanip\u0026gt; #include \u0026lt;unordered_map\u0026gt; #define P pair\u0026lt;int, int\u0026gt; #define LL long long #define LD long double #define PLL pair\u0026lt;LL, LL\u0026gt; #define mset(a, b) memset(a, b, sizeof(a)) #define rep(i, a, b) for (int i = a; i \u0026lt; b; i++) #define PI acos(-1.0) #define random(x) rand() % x #define debug(x) cout \u0026lt;\u0026lt; #x \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34; using namespace std; const int inf = 0x3f3f3f3f; const LL __64inf = 0x3f3f3f3f3f3f3f3f; #ifdef DEBUG const int MAX = 2e3 + 50; #else const int MAX = 1e6 + 50; #endif const int mod = 1e9 + 7; #include \u0026lt;complex\u0026gt; namespace FFT { int rev[MAX * 4]; int cnt[MAX * 4]; void fft(complex\u0026lt;double\u0026gt; *a, int n, int inv){ int bit = 0; while((1\u0026lt;\u0026lt;bit) \u0026lt; n) bit++; for(int i = 0; i \u0026lt; n; i++){ rev[i] = (rev[i\u0026gt;\u0026gt;1]\u0026gt;\u0026gt;1) | ((i \u0026amp; 1) \u0026lt;\u0026lt; (bit-1)); if(i \u0026lt; rev[i]) swap(a[i], a[rev[i]]); } for(int mid = 1; mid \u0026lt; n; mid \u0026lt;\u0026lt;= 1){ complex\u0026lt;double\u0026gt; wn(cos(PI/mid), inv*sin(PI/mid)); for(int i = 0; i \u0026lt; n; i += (mid\u0026lt;\u0026lt;1)){ complex\u0026lt;double\u0026gt; w(1, 0); for(int j = 0; j \u0026lt; mid; j++, w*=wn){ complex\u0026lt;double\u0026gt; u = a[i+j], t = w * a[i+j+mid]; a[i+j] = u + t, a[i+j+mid] = u-t; } } } } }; int N; char s[MAX], t[MAX], rev_t[MAX]; complex\u0026lt;double\u0026gt; a[MAX*4], b[MAX*4]; int mark[100][100]; void init(){ mark[\u0026#39;S\u0026#39;][\u0026#39;P\u0026#39;] = 1; mark[\u0026#39;P\u0026#39;][\u0026#39;R\u0026#39;] = 1; mark[\u0026#39;R\u0026#39;][\u0026#39;L\u0026#39;] = 1; mark[\u0026#39;L\u0026#39;][\u0026#39;K\u0026#39;] = 1; mark[\u0026#39;K\u0026#39;][\u0026#39;S\u0026#39;] = 1; mark[\u0026#39;S\u0026#39;][\u0026#39;L\u0026#39;] = 1; mark[\u0026#39;L\u0026#39;][\u0026#39;P\u0026#39;] = 1; mark[\u0026#39;P\u0026#39;][\u0026#39;K\u0026#39;] = 1; mark[\u0026#39;K\u0026#39;][\u0026#39;R\u0026#39;] = 1; mark[\u0026#39;R\u0026#39;][\u0026#39;S\u0026#39;] = 1; } void solve(char op, int n, int m){ for(int i = 0; i \u0026lt; n; i++) a[i] = complex\u0026lt;double\u0026gt;(mark[op][s[i]], 0); for(int i = n; i \u0026lt; N; i++) a[i] = complex\u0026lt;double\u0026gt;(0, 0); for(int i = 0; i \u0026lt; m; i++) b[i] = complex\u0026lt;double\u0026gt;(rev_t[i]==op?1:0, 0); for(int i = m; i \u0026lt; N; i++) b[i] = complex\u0026lt;double\u0026gt;(0, 0); ; FFT::fft(a, N, 1); FFT::fft(b, N, 1); for(int i = 0; i \u0026lt; N;i++) a[i] *= b[i]; FFT::fft(a, N, -1); for(int i = m-1; i \u0026lt;= n-1; i++) FFT::cnt[i] += (int)(a[i].real() / N + 0.5); return; } int main(){ #ifdef DEBUG freopen(\u0026#34;in\u0026#34;, \u0026#34;r\u0026#34;, stdin); #endif init(); scanf(\u0026#34;%s%s\u0026#34;, s, t); int n = strlen(s), m = strlen(t); N = 1; while(N \u0026lt;= n+m) N \u0026lt;\u0026lt;= 1; for(int i = 0; i \u0026lt; m; i++) rev_t[i] = t[m-i-1]; vector\u0026lt;char\u0026gt; ops({\u0026#39;R\u0026#39;,\u0026#39;P\u0026#39;, \u0026#39;S\u0026#39;, \u0026#39;K\u0026#39;, \u0026#39;L\u0026#39;}); for(auto op : ops){ solve(op, n, m); } int ans = 0; for(int i = m-1; i \u0026lt;= n-1; i++){ ans = max(ans, FFT::cnt[i]); // printf(\u0026#34;%d \u0026#34;, FFT::cnt[i]); } // puts(\u0026#34;\u0026#34;); printf(\u0026#34;%d\\n\u0026#34;, ans); return 0; } ","permalink":"https://Anlarry.github.io/posts/acm-icpc/rock-paper-scissors-lizard-spock/","summary":"Rock Paper Scissors Lizard Spock é¢˜æ„ï¼š Rock Paper Scissors Lizard Spock\næœ‰äº”ç§æ‰‹åŠ¿ï¼Œç±»ä¼¼äºçŸ³å¤´å‰ªåˆ€å¸ƒï¼Œæœ‰ä¸¤ä¸ªä¸²$s, t$,ç”±è¿™äº”ç§æ‰‹åŠ¿ç»„æˆï¼Œä»æŸä¸ªä½ç½®å¼€å§‹åŒ¹é…ï¼Œå¦‚æœ$t_i$èƒ½èµ¢$s_j$å¾—ä¸€åˆ†ï¼Œæ±‚ä¸€ä¸ª$pos(0\\le pos \\le len(s)-len(t))$ï¼Œä½¿å¾—å¾—åˆ†æœ€å¤š\nSolutionï¼š å°†ä¸Šå›¾è®°ä¸º$G$ï¼Œå¦‚æœ$op_1$å¯ä»¥èµ¢$op_2$ï¼Œåˆ™$G(op_1, op_2)=1$,\næšä¸¾å¯ä»¥å¾—åˆ†çš„æ‰‹åŠ¿,å‡è®¾å½“å‰æ‰‹åŠ¿ä¸º$op$,\n$$ \\begin{aligned} t\u0026rsquo;_i \u0026amp;=(reverse\\ t_i == op ? 1 : 0) \\newline s\u0026rsquo;_i \u0026amp;= G[op][s_i] \\end{aligned} $$\nå°†$t\u0026rsquo;,s\u0026rsquo;$åšå·ç§¯ï¼Œç´¯åŠ æ¯æ¬¡çš„ç»“æœï¼Œå†éå†ä¸€éåŒ¹é…çš„èµ·å§‹ä½ç½®ï¼Œå–æœ€å¤§å€¼\n#include \u0026lt;cstdio\u0026gt; #include \u0026lt;stack\u0026gt; #include \u0026lt;set\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;map\u0026gt; #include \u0026lt;time.h\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;memory.h\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;iomanip\u0026gt; #include \u0026lt;unordered_map\u0026gt; #define P pair\u0026lt;int, int\u0026gt; #define LL long long #define LD long double #define PLL pair\u0026lt;LL, LL\u0026gt; #define mset(a, b) memset(a, b, sizeof(a)) #define rep(i, a, b) for (int i = a; i \u0026lt; b; i++) #define PI acos(-1.","title":"Rock Paper Scissors Lizard Spock"},{"content":"URAL - 1996 é¢˜æ„ï¼š URAL - 1996 ç»™ä¸¤ä¸ªé•¿åº¦åˆ†åˆ«ä¸º$n, m$çš„å­—èŠ‚ä¸²$A,B$ï¼Œ$A$ä¸²çš„æœ€åä¸€ä½å¯ä»¥ä¿®æ”¹ï¼Œä»£ä»·ä¸º$1$ï¼Œæ±‚ä½¿å¾—$B$ä¸²ä¸º$A$ä¸²å­—ä¸²çš„æœ€å°ä»£ä»·\nSolution : å› ä¸º$A$ä¸²åªæœ‰æœ€åæœ€åä¸€ä½å¯ä»¥ä¿®æ”¹ï¼Œæ‰€ä»¥å¯ä»¥ç”¨KMPæ±‚å‡ºå¯èƒ½åŒ¹é…çš„ä½ç½®ï¼Œç„¶åè®¡ç®—æ¯ä¸ªä½ç½®çš„$cost$\nè®°$A$ä¸²æœ€åä¸€ä½æ„æˆçš„ä¸²ä¸º$a$ï¼Œ $B$ä¸²çš„ä¸º$b$, å‡è®¾$pos(0\\le pos \\le n-m)æ˜¯å¯èƒ½åŒ¹é…çš„ä½ç½®$ï¼Œå¦‚æœå°†$b$åè½¬å¾—åˆ°$b\u0026rsquo;$, åœ¨æ­¤å¤„çš„çš„ä»£ä»·ä¸º\n$$ \\sum_{i+j=pos+m-1} [a_i \\ne b\u0026rsquo;_j ] $$\nè€Œ\n$$ \\sum_{i+j=posm-1} a_j * b\u0026rsquo;_j $$\nå¯ä»¥ç®—å‡ºæ¥ç›¸ç­‰çš„$1$çš„ä¸ªæ•°$cnt_1$ï¼Œå†å°†$a,b$ä¸²å–åï¼Œå†åšä¸€æ¬¡å·ç§¯å°±å¯ä»¥ç®—å‡º$0$ç›¸ç­‰çš„ä¸ªæ•°$cnt_2$ï¼Œ$ans=m-cnt_1-cnt_2$\n#include \u0026lt;cstdio\u0026gt; #include \u0026lt;stack\u0026gt; #include \u0026lt;set\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;map\u0026gt; #include \u0026lt;time.h\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;memory.h\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;iomanip\u0026gt; #include \u0026lt;unordered_map\u0026gt; #define P pair\u0026lt;int, int\u0026gt; #define LL long long #define LD long double #define PLL pair\u0026lt;LL, LL\u0026gt; #define mset(a, b) memset(a, b, sizeof(a)) #define rep(i, a, b) for (int i = a; i \u0026lt; b; i++) #define PI acos(-1.0) #define random(x) rand() % x #define debug(x) cout \u0026lt;\u0026lt; #x \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34; using namespace std; const int inf = 0x3f3f3f3f; const LL __64inf = 0x3f3f3f3f3f3f3f3f; #ifdef DEBUG const int MAX = 2e3 + 50; #else const int MAX = 1e6 + 50; #endif const int mod = 1e9 + 7; #include \u0026lt;complex\u0026gt; namespace FFT { int rev[MAX]; int cnt[MAX]; void fft(complex\u0026lt;double\u0026gt; *a, int n, int inv){ int bit = 0; while((1 \u0026lt;\u0026lt; bit) \u0026lt; n) bit++; for(int i = 0; i \u0026lt; n; i++){ rev[i] = (rev[i\u0026gt;\u0026gt;1]\u0026gt;\u0026gt;1) | ((i \u0026amp; 1) \u0026lt;\u0026lt; (bit-1)); if(i \u0026lt; rev[i]) swap(a[i], a[rev[i]]); } for(int mid = 1; mid \u0026lt; n; mid \u0026lt;\u0026lt;= 1){ complex\u0026lt;double\u0026gt; wn(cos(PI/mid), inv*sin(PI/mid)); for(int i = 0; i \u0026lt; n; i += (mid\u0026lt;\u0026lt;1)){ complex\u0026lt;double\u0026gt; w(1, 0); for(int j = 0; j \u0026lt; mid; j++, w *= wn){ complex\u0026lt;double\u0026gt; u = a[i+j], t = w * a[i+j+mid]; a[i+j] = u+t, a[i+j+mid] = u-t; } } } } void work(complex\u0026lt;double\u0026gt; *ss, complex\u0026lt;double\u0026gt; *rev_t, int N, int n, int m){ FFT::fft(ss, N, 1); FFT::fft(rev_t, N, 1); for(int i = 0; i \u0026lt;= N; i++) { ss[i] *= rev_t[i]; } FFT::fft(ss, N, -1); for(int i = 0; i \u0026lt;= n-m; i++){ cnt[i] += (int)(ss[i+m-1].real() / N + 0.5); } } }; complex\u0026lt;double\u0026gt; a[MAX],b[MAX]; int x[MAX], y[MAX]; int s[MAX], t[MAX]; complex\u0026lt;double\u0026gt; ss[MAX], rev_t[MAX]; char ch[10]; void input(int *x, int *s, int n){ for(int i = 0; i \u0026lt; n; i++){ scanf(\u0026#34;%s\u0026#34;, ch); for(int j = 0; j \u0026lt; 6; j++) if(ch[j] == \u0026#39;1\u0026#39;) x[i] += 1 \u0026lt;\u0026lt; j; s[i] = (ch[7] == \u0026#39;1\u0026#39;); } } struct KMP { int next[MAX]; vector\u0026lt;int\u0026gt; pos; void init(int *x, int n){ next[0] = -1; int k = -1; for(int i = 1; i \u0026lt; n; i++){ while(k \u0026gt; -1 and x[k+1] != x[i]) k = next[k]; if(x[k+1] == x[i]) k++; next[i] = k; } } void work(int *x, int n, int *y, int m){ int k = -1; init(x, n); for(int i =0; i \u0026lt; m; i++){ while(k \u0026gt; -1 and x[k+1] != y[i]) k = next[k]; if(x[k+1] == y[i]) k++; if(k == n-1) { pos.push_back(i-n+1); k = next[k]; } } } }kmp; int main(){ #ifdef DEBUG freopen(\u0026#34;in\u0026#34;, \u0026#34;r\u0026#34;, stdin); #endif int n, m; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); input(x,s,n); input(y, t, m); kmp.init(y, m); kmp.work(y, m, x, n); if(kmp.pos.empty()){ puts(\u0026#34;No\u0026#34;); return 0; } int N = 1; while(N \u0026lt;= n+m) N\u0026lt;\u0026lt;=1; for(int i = 0; i \u0026lt; n; i++) ss[i] = complex\u0026lt;double\u0026gt;(s[i], 0); for(int i = 0; i \u0026lt; m; i++) rev_t[i] = complex\u0026lt;double\u0026gt;(t[m-1-i], 0); FFT::work(ss, rev_t, N, n, m); for(int i = 0; i \u0026lt; n; i++) s[i] ^= 1; for(int i = 0; i \u0026lt; m; i++) t[i] ^= 1; for(int i = 0; i \u0026lt; n; i++) ss[i] = complex\u0026lt;double\u0026gt;(s[i], 0); for(int i = n; i \u0026lt; N; i++) ss[i] = complex\u0026lt;double\u0026gt;(0, 0); for(int i = 0; i \u0026lt; m; i++) rev_t[i] = complex\u0026lt;double\u0026gt;(t[m-i-1], 0); for(int i = m; i \u0026lt; N; i++) rev_t[i] = complex\u0026lt;double\u0026gt;(0, 0); FFT::work(ss, rev_t, N, n, m); int res = inf, id = -1; for(int i = 0; i \u0026lt; kmp.pos.size(); i++){ int pos = kmp.pos[i]; // pos += m-1; int cost = m - FFT::cnt[pos]; if(cost \u0026lt; res){ res = cost, id = kmp.pos[i]; } } puts(\u0026#34;Yes\u0026#34;); printf(\u0026#34;%d %d\\n\u0026#34;, res, id+1); return 0; } ","permalink":"https://Anlarry.github.io/posts/acm-icpc/ural-1996/","summary":"URAL - 1996 é¢˜æ„ï¼š URAL - 1996 ç»™ä¸¤ä¸ªé•¿åº¦åˆ†åˆ«ä¸º$n, m$çš„å­—èŠ‚ä¸²$A,B$ï¼Œ$A$ä¸²çš„æœ€åä¸€ä½å¯ä»¥ä¿®æ”¹ï¼Œä»£ä»·ä¸º$1$ï¼Œæ±‚ä½¿å¾—$B$ä¸²ä¸º$A$ä¸²å­—ä¸²çš„æœ€å°ä»£ä»·\nSolution : å› ä¸º$A$ä¸²åªæœ‰æœ€åæœ€åä¸€ä½å¯ä»¥ä¿®æ”¹ï¼Œæ‰€ä»¥å¯ä»¥ç”¨KMPæ±‚å‡ºå¯èƒ½åŒ¹é…çš„ä½ç½®ï¼Œç„¶åè®¡ç®—æ¯ä¸ªä½ç½®çš„$cost$\nè®°$A$ä¸²æœ€åä¸€ä½æ„æˆçš„ä¸²ä¸º$a$ï¼Œ $B$ä¸²çš„ä¸º$b$, å‡è®¾$pos(0\\le pos \\le n-m)æ˜¯å¯èƒ½åŒ¹é…çš„ä½ç½®$ï¼Œå¦‚æœå°†$b$åè½¬å¾—åˆ°$b\u0026rsquo;$, åœ¨æ­¤å¤„çš„çš„ä»£ä»·ä¸º\n$$ \\sum_{i+j=pos+m-1} [a_i \\ne b\u0026rsquo;_j ] $$\nè€Œ\n$$ \\sum_{i+j=posm-1} a_j * b\u0026rsquo;_j $$\nå¯ä»¥ç®—å‡ºæ¥ç›¸ç­‰çš„$1$çš„ä¸ªæ•°$cnt_1$ï¼Œå†å°†$a,b$ä¸²å–åï¼Œå†åšä¸€æ¬¡å·ç§¯å°±å¯ä»¥ç®—å‡º$0$ç›¸ç­‰çš„ä¸ªæ•°$cnt_2$ï¼Œ$ans=m-cnt_1-cnt_2$\n#include \u0026lt;cstdio\u0026gt; #include \u0026lt;stack\u0026gt; #include \u0026lt;set\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;map\u0026gt; #include \u0026lt;time.h\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;memory.h\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;iomanip\u0026gt; #include \u0026lt;unordered_map\u0026gt; #define P pair\u0026lt;int, int\u0026gt; #define LL long long #define LD long double #define PLL pair\u0026lt;LL, LL\u0026gt; #define mset(a, b) memset(a, b, sizeof(a)) #define rep(i, a, b) for (int i = a; i \u0026lt; b; i++) #define PI acos(-1.","title":"URAL - 1996"},{"content":"ç¹èŠ± æç»˜ä¸Šæµ·20ä¸–çºª60å¹´ä»£è‡³90å¹´ä»£å¸‚æ°‘ç”Ÿæ´»ï¼Œå­—é‡Œè¡Œé—´æ´‹æº¢ç€ä¸Šæµ·è¯çš„é£æ ¼ã€‚\n","permalink":"https://Anlarry.github.io/book-reading/2023/","summary":"ç¹èŠ± æç»˜ä¸Šæµ·20ä¸–çºª60å¹´ä»£è‡³90å¹´ä»£å¸‚æ°‘ç”Ÿæ´»ï¼Œå­—é‡Œè¡Œé—´æ´‹æº¢ç€ä¸Šæµ·è¯çš„é£æ ¼ã€‚","title":"2023-Fabula"},{"content":" Fabula means story, which is a topic in A brief history of humankind\nç®€å²ä¸‰éƒ¨æ›² A brief history of humankind Homo Deusï¼šA Brief History of Tomorrow 21 Lessons for the 21st Century ä»å²å‰åˆ°æœªæ¥ï¼Œå†å›åˆ°21ä¸–çºªçš„æ—…è¡Œï¼Œæœ‰å„ç§å„æ ·çš„æ„ä¹‰ä¹‹ç½‘ã€‚\nTo Kill a Mocking Bird â€œä¾ç„¶æ˜¯å¤å¤©ï¼Œå­©å­ä»¬èµ°è¿‘äº†ã€‚ç”·å­©èº«åæ‹–ç€æ ¹é±¼ç«¿è¸¯èº…ä¸å‰ã€‚ä¸€ä¸ªç”·äººåŒæ‰‹å‰è…°ç«™åœ¨é‚£é‡Œç­‰ä»–ã€‚å¤å¤©ï¼Œä»–çš„å­©å­ä»¬åœ¨å‰é™¢å’Œæœ‹å‹ç©è€ï¼Œè‡ªç¼–è‡ªæ¼”ç€ä»–ä»¬å¤æ€ªçš„å°è¯å‰§ã€‚\nç§‹å¤©ï¼Œä»–çš„å­©å­ä»¬åœ¨æœåšæ–¯å¤ªå¤ªæˆ¿å‰çš„äººè¡Œé“ä¸Šæ‰“æ¶ã€‚ç”·å­©æ‰¶ç€ä»–å¦¹å¦¹ç«™èµ·æ¥ï¼Œè¿‡åä»–ä»¬ä¸€èµ·èµ°å›å®¶å»ã€‚ç§‹å¤©ï¼Œä»–çš„å­©å­ä»¬å°è·‘ç€æ¥å›ç»è¿‡é‚£ä¸ªè¡—è§’ï¼Œæ¯å¤©çš„è‹¦æ¼å’Œå¾—æ„éƒ½å†™åœ¨è„¸ä¸Šã€‚ä»–ä»¬åœ¨æ©¡æ ‘å‰åœä¸‹äº†ï¼Œè¡¨æƒ…åˆæ¬£å–œåˆå›°æƒ‘ï¼Œè¿˜å¸¦ç€å¿§è™‘ã€‚\nå†¬å¤©ï¼Œä»–çš„å­©å­ä»¬åœ¨é™¢é—¨å‰å“†å—¦ç€ï¼Œé»‘è‰²çš„å‰ªå½±è¡¬ç€ç†Šç†Šç‡ƒçƒ§çš„æˆ¿å±‹ã€‚å†¬å¤©ï¼Œé‚£ç”·äººèµ°ä¸Šè¡—å¤´ï¼Œæ‰”ä¸‹çœ¼é•œï¼Œå°„æ­»äº†ä¸€åªç–¯ç‹—ã€‚\nå¤å¤©ï¼Œä»–çœ¼çœ‹ç€ä»–çš„å­©å­ä»¬å¿ƒç¢äº†ã€‚åˆåˆ°äº†ç§‹å¤©ï¼Œæ€ªäººçš„å­©å­ä»¬éœ€è¦ä»–äº†ã€‚â€\nè¿›åŒ–å¿ƒç†å­¦ ä»äººç±»è¿›åŒ–ä»¥é€‚åº”ç”Ÿå­˜é—®é¢˜çš„è§’åº¦è§£é‡Šäººç±»çš„è¡Œä¸ºã€‚\né¥®é£Ÿçš„æ€è¿· ä»¥æ‘„å…¥çš„èƒ½é‡ç­‰æŒ‡æ ‡æ¥è¡¡é‡ä¹Ÿå¯èƒ½å¹¶ä¸åˆç†ï¼Œå³ä½¿æ˜¯ç›¸åŒçš„ä¸œè¥¿åœ¨ä¸åŒäººèº«ä¸Šä¹Ÿä¼šæœ‰ä¸åŒçš„æ•ˆæœã€‚æˆ‘ä»¬ä¸å¾—ä¸è€ƒè™‘å¾®ç”Ÿç‰©åœ¨è¿™ä¸€è¿‡ç¨‹ä¸­çš„ å½±å“ã€‚è™½ç„¶å¾ˆå¤šä¸œè¥¿è¿˜ä¸èƒ½å¾—ä»¥è§£é‡Šï¼Œä½†æ€»ä¹‹å¤šæ ·æ€§åº”è¯¥æ˜¯å¯¹çš„ã€‚\næƒè¡¡ æƒè¡¡å„æ–¹å› ç´ ï¼ŒåŒæ—¶ä¹ŸKeep Open Mindï¼\næˆ‘ä¸çˆ¶è¾ˆ å‘å±•ä¸­çš„åŸä¹¡å·®è·ä¹‹å¤§ï¼Œä¸æç»˜çš„å¹´ä»£ç›¸è¿‘çš„ã€Šç¹èŠ±ã€‹ä¸­çš„ä¸Šæµ·ï¼Œå¤©å£¤ä¹‹åˆ«å•Šã€‚\n","permalink":"https://Anlarry.github.io/book-reading/2022-fabula/","summary":"Fabula means story, which is a topic in A brief history of humankind\nç®€å²ä¸‰éƒ¨æ›² A brief history of humankind Homo Deusï¼šA Brief History of Tomorrow 21 Lessons for the 21st Century ä»å²å‰åˆ°æœªæ¥ï¼Œå†å›åˆ°21ä¸–çºªçš„æ—…è¡Œï¼Œæœ‰å„ç§å„æ ·çš„æ„ä¹‰ä¹‹ç½‘ã€‚\nTo Kill a Mocking Bird â€œä¾ç„¶æ˜¯å¤å¤©ï¼Œå­©å­ä»¬èµ°è¿‘äº†ã€‚ç”·å­©èº«åæ‹–ç€æ ¹é±¼ç«¿è¸¯èº…ä¸å‰ã€‚ä¸€ä¸ªç”·äººåŒæ‰‹å‰è…°ç«™åœ¨é‚£é‡Œç­‰ä»–ã€‚å¤å¤©ï¼Œä»–çš„å­©å­ä»¬åœ¨å‰é™¢å’Œæœ‹å‹ç©è€ï¼Œè‡ªç¼–è‡ªæ¼”ç€ä»–ä»¬å¤æ€ªçš„å°è¯å‰§ã€‚\nç§‹å¤©ï¼Œä»–çš„å­©å­ä»¬åœ¨æœåšæ–¯å¤ªå¤ªæˆ¿å‰çš„äººè¡Œé“ä¸Šæ‰“æ¶ã€‚ç”·å­©æ‰¶ç€ä»–å¦¹å¦¹ç«™èµ·æ¥ï¼Œè¿‡åä»–ä»¬ä¸€èµ·èµ°å›å®¶å»ã€‚ç§‹å¤©ï¼Œä»–çš„å­©å­ä»¬å°è·‘ç€æ¥å›ç»è¿‡é‚£ä¸ªè¡—è§’ï¼Œæ¯å¤©çš„è‹¦æ¼å’Œå¾—æ„éƒ½å†™åœ¨è„¸ä¸Šã€‚ä»–ä»¬åœ¨æ©¡æ ‘å‰åœä¸‹äº†ï¼Œè¡¨æƒ…åˆæ¬£å–œåˆå›°æƒ‘ï¼Œè¿˜å¸¦ç€å¿§è™‘ã€‚\nå†¬å¤©ï¼Œä»–çš„å­©å­ä»¬åœ¨é™¢é—¨å‰å“†å—¦ç€ï¼Œé»‘è‰²çš„å‰ªå½±è¡¬ç€ç†Šç†Šç‡ƒçƒ§çš„æˆ¿å±‹ã€‚å†¬å¤©ï¼Œé‚£ç”·äººèµ°ä¸Šè¡—å¤´ï¼Œæ‰”ä¸‹çœ¼é•œï¼Œå°„æ­»äº†ä¸€åªç–¯ç‹—ã€‚\nå¤å¤©ï¼Œä»–çœ¼çœ‹ç€ä»–çš„å­©å­ä»¬å¿ƒç¢äº†ã€‚åˆåˆ°äº†ç§‹å¤©ï¼Œæ€ªäººçš„å­©å­ä»¬éœ€è¦ä»–äº†ã€‚â€\nè¿›åŒ–å¿ƒç†å­¦ ä»äººç±»è¿›åŒ–ä»¥é€‚åº”ç”Ÿå­˜é—®é¢˜çš„è§’åº¦è§£é‡Šäººç±»çš„è¡Œä¸ºã€‚\né¥®é£Ÿçš„æ€è¿· ä»¥æ‘„å…¥çš„èƒ½é‡ç­‰æŒ‡æ ‡æ¥è¡¡é‡ä¹Ÿå¯èƒ½å¹¶ä¸åˆç†ï¼Œå³ä½¿æ˜¯ç›¸åŒçš„ä¸œè¥¿åœ¨ä¸åŒäººèº«ä¸Šä¹Ÿä¼šæœ‰ä¸åŒçš„æ•ˆæœã€‚æˆ‘ä»¬ä¸å¾—ä¸è€ƒè™‘å¾®ç”Ÿç‰©åœ¨è¿™ä¸€è¿‡ç¨‹ä¸­çš„ å½±å“ã€‚è™½ç„¶å¾ˆå¤šä¸œè¥¿è¿˜ä¸èƒ½å¾—ä»¥è§£é‡Šï¼Œä½†æ€»ä¹‹å¤šæ ·æ€§åº”è¯¥æ˜¯å¯¹çš„ã€‚\næƒè¡¡ æƒè¡¡å„æ–¹å› ç´ ï¼ŒåŒæ—¶ä¹ŸKeep Open Mindï¼\næˆ‘ä¸çˆ¶è¾ˆ å‘å±•ä¸­çš„åŸä¹¡å·®è·ä¹‹å¤§ï¼Œä¸æç»˜çš„å¹´ä»£ç›¸è¿‘çš„ã€Šç¹èŠ±ã€‹ä¸­çš„ä¸Šæµ·ï¼Œå¤©å£¤ä¹‹åˆ«å•Šã€‚","title":"2022-Fabula"},{"content":" Primus liber means the first book in latin, and means first commit here in some way.\n2021 Project Hail Mary\nè®²è¿°Graceå’Œå¤–æ˜ŸäººRockyä¸€èµ·â€œç”¨é­”æ³•å¯¹æŠ—é­”æ³•â€ï¼ˆAstrophagå’ŒTaumoebaï¼‰çš„æ˜Ÿé™…æ—…è¡Œæ•…äº‹ï¼ŒSave Earth \u0026amp; Save Eridã€‚\nRich Dad, Poor Dad\nä»ä¸€ä¸ªä¸ä¼—ä¸åŒçš„æ€è·¯ï¼Œè®²è¿°ç†è´¢çš„é‡è¦æ€§ï¼Œä»ä¸åŒçš„è§’åº¦å†æ€è€ƒè¿™ä¸ªé—®é¢˜ã€‚\n","permalink":"https://Anlarry.github.io/book-reading/2021-primusliber/","summary":"Primus liber means the first book in latin, and means first commit here in some way.\n2021 Project Hail Mary\nè®²è¿°Graceå’Œå¤–æ˜ŸäººRockyä¸€èµ·â€œç”¨é­”æ³•å¯¹æŠ—é­”æ³•â€ï¼ˆAstrophagå’ŒTaumoebaï¼‰çš„æ˜Ÿé™…æ—…è¡Œæ•…äº‹ï¼ŒSave Earth \u0026amp; Save Eridã€‚\nRich Dad, Poor Dad\nä»ä¸€ä¸ªä¸ä¼—ä¸åŒçš„æ€è·¯ï¼Œè®²è¿°ç†è´¢çš„é‡è¦æ€§ï¼Œä»ä¸åŒçš„è§’åº¦å†æ€è€ƒè¿™ä¸ªé—®é¢˜ã€‚","title":"2021-PrimusLiber"},{"content":"Friends ğŸ³ Wang Shuai, and his Github.\nğŸ³ SHEN Haiyang, and his Github.\nğŸ³ Peng Guanwen, and his Github.\nğŸ³ Yiming Chen, and his Github.\nğŸ³ Tao Wu, and his Github.\nğŸ³ yuanya, and his Github.\n","permalink":"https://Anlarry.github.io/links/","summary":"Friends ğŸ³ Wang Shuai, and his Github.\nğŸ³ SHEN Haiyang, and his Github.\nğŸ³ Peng Guanwen, and his Github.\nğŸ³ Yiming Chen, and his Github.\nğŸ³ Tao Wu, and his Github.\nğŸ³ yuanya, and his Github.","title":"Links"}]