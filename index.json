[{"content":"System Call Cost 应用程序通过System Call向kernel请求服务。一般应用程序发起系统调用后，从用户态进入内核态，最后从异常退出，返回用户态。\n但是这种同步的系统调用机制可能对应用的性能带来限制：\nDirect Cost: 在系统调用后，CPU会清空流水线。 Indirect Cost: 程序的局部性以及cache可以提升性能。但是在系统调用后，要在kernel空间执行代码，这就会影响cache性能。而且在kernel处理结束返回用户后，相比与原来的cache，cache受到了污染，带来间接性能损失。 可以看到在系统调用后，IPC(Instructions Per Cycle)降低。\nException-Less System Call exception-less系统调用，让系统调用异步完成。在user和kernel共享一些syscall pages，用这些syscall page记录当前请求的系统调用。用户发起系统调用后，在syscall pages中添加新的entry后就可以返回。同时，有一些特殊的kernel thread，syscall thread，在syscall pages中找到请求的系统调用，把返回值写在相应的条目。最后用户就通过可以检查syscall pages，拿到返回值。\n那这种将invoke和execute解耦的设计怎么做有什么好处呢？\n可以推迟执行，把syscall按batch执行，降低mode之间转化的代价，improve temporal locality。 对于多核系统，可以把syscall放在另一个核上执行，这样就可以降低间接代价，improved spatial locality。 Implementation 在实现时，作者添加两个新的系统调用，都采用同步的系统调用机制。\nflexsc_register，做一些syscall page的映射，并创建syscall thread，数量等于page中entry的数量。 flexsc_wait，因为这种异步机制，会出现用户需要停下来等待系统调用的完成。 syscall thread的调度，会影响exception-less syscall的性能。对于单核，调用flexsc_wait后，调度syscall thread处理page中每个entry，如果出现阻塞，就用新的syscall thread接着处理一下个entry。多核时，one syscall thread per application and core，这样就带来了并行处理的可能。\nFlexSC Threads 但是这样异步方式，可能会让使用变得复杂，而且随着多核的发展，作者就实现了FlexSC-Threads。利用dynamic loading，系统调用时，调用一个wrapper，这样就可以让应用得到free lunch。\n维护$M$个user-mod thread，对一个process，每个核上只有一个可以被kernel看见。发起系统调用的线程，在写好entry后，就会被切换执行一下thread。用完ready的user-mode thread，就看看syscall page上有没有完成的。如果还没有ready的，就需要调用下flexsc_wait。\n对于这种设计，需要提高并发，来提升性能。highly threaded workloads是FlexSC-Threads的理想环境。\nReference\n[1] Soares L, Stumm M. FlexSC: Flexible System Call Scheduling with Exception-Less System Calls[C]//Osdi. 2010, 10: 33-46.\n","permalink":"https://Anlarry.github.io/posts/paper-reading/flexsc/","summary":"System Call Cost 应用程序通过System Call向kernel请求服务。一般应用程序发起系统调用后，从用户态进入内核态，最后从异常退出，返回用户态。\n但是这种同步的系统调用机制可能对应用的性能带来限制：\nDirect Cost: 在系统调用后，CPU会清空流水线。 Indirect Cost: 程序的局部性以及cache可以提升性能。但是在系统调用后，要在kernel空间执行代码，这就会影响cache性能。而且在kernel处理结束返回用户后，相比与原来的cache，cache受到了污染，带来间接性能损失。 可以看到在系统调用后，IPC(Instructions Per Cycle)降低。\nException-Less System Call exception-less系统调用，让系统调用异步完成。在user和kernel共享一些syscall pages，用这些syscall page记录当前请求的系统调用。用户发起系统调用后，在syscall pages中添加新的entry后就可以返回。同时，有一些特殊的kernel thread，syscall thread，在syscall pages中找到请求的系统调用，把返回值写在相应的条目。最后用户就通过可以检查syscall pages，拿到返回值。\n那这种将invoke和execute解耦的设计怎么做有什么好处呢？\n可以推迟执行，把syscall按batch执行，降低mode之间转化的代价，improve temporal locality。 对于多核系统，可以把syscall放在另一个核上执行，这样就可以降低间接代价，improved spatial locality。 Implementation 在实现时，作者添加两个新的系统调用，都采用同步的系统调用机制。\nflexsc_register，做一些syscall page的映射，并创建syscall thread，数量等于page中entry的数量。 flexsc_wait，因为这种异步机制，会出现用户需要停下来等待系统调用的完成。 syscall thread的调度，会影响exception-less syscall的性能。对于单核，调用flexsc_wait后，调度syscall thread处理page中每个entry，如果出现阻塞，就用新的syscall thread接着处理一下个entry。多核时，one syscall thread per application and core，这样就带来了并行处理的可能。\nFlexSC Threads 但是这样异步方式，可能会让使用变得复杂，而且随着多核的发展，作者就实现了FlexSC-Threads。利用dynamic loading，系统调用时，调用一个wrapper，这样就可以让应用得到free lunch。\n维护$M$个user-mod thread，对一个process，每个核上只有一个可以被kernel看见。发起系统调用的线程，在写好entry后，就会被切换执行一下thread。用完ready的user-mode thread，就看看syscall page上有没有完成的。如果还没有ready的，就需要调用下flexsc_wait。\n对于这种设计，需要提高并发，来提升性能。highly threaded workloads是FlexSC-Threads的理想环境。\nReference\n[1] Soares L, Stumm M. FlexSC: Flexible System Call Scheduling with Exception-Less System Calls[C]//Osdi.","title":"FlexSC"},{"content":"Background 基本各种东西都可以用图来表示，也就促成了GNN的快速发展。然而很多图都有这样的特点，一些节点的度数很高然而大多数节点的度数很低。\n训练时要用邻居更新当前节点，不能将整个图全部拿来训练，因此一般采用graph sampling+mini batch，比如，给$n$个节点，每个节点对邻居采样后在进行训练。\n然而产生了新的问题，采样在整个训练过程中占了很多时间。\n因此，大家也会去想用GPU加速采样，但是naive的方法并不能很好的利用GPU。\n\u0026ldquo;Transit-Parallelism\u0026rdquo; 作者首先对采样进行了抽象，采样从一节点开始，扩展出新的节点加入sample，再从新的节点扩展$\\cdots$，每次遍历邻居扩展新节点的节点，作者把它叫做\u0026quot;transit vertices\u0026quot;\n将采样分成两类：\nIndividual Transit Sampling，这个是按节点来的，每个transit节点从邻居中采样一定数量的节点 Collective Transit Sampling，这个是按层来，每一层从所有transit节点的邻居中采样一定数量的节点 CUDA \u0026amp; GPU\n一个CUDA程序被划分给很多blocks of threads完成并行，而GPU又由很多StreamingMultiprocessors (SMs)构成，每个block被放到SM上执行\n一个block的线程数是有限的，但是相同的大小block可以被组织成grid，于是kernel(a c++ function)就可以用grid里面所有的线程。 $$ thread \\xrightarrow[]{array} block \\xrightarrow[]{array} grid $$ 众所周知，内存层次结构，GPU当然也有：\n前面已经提到了block会在SM上执行，在物理实现时会用到SIMT(Single-Instruction, Multiple-Thread)。multiprocessor用warp(a group of 32 threads)来管理线程。\nwarp中的线程都从相同的起点开始，但是每个线程都有自己的pc，寄存器状态也可能不一样。而且一个warp的thread执行的指令还是相同的。\n如果就是普通的没有控制流的代码，大家就一起执行。那遇到分支怎么办，每个线程可能有不同的路径。这时就会变成串行。warp去执行每个分支路径，不在路径上的thread就等着。这就可能会很影响并行，也就是Branch divergence。\nSample-Parallelism，对于Individual Transit Sampling可以将每一对sample和transit分配$m_i$个线程，每个sample放到一个block里。对于Collective Transit Sampling，需要先把所有的邻居存到global memory里，再采样。\n在采样时，邻居多的节点计算的时间就会更久。如果同一个warp里面的两个thread被分给两个邻居数量不同的transit，就会有divergence。而且，图得存在gobal memory，shared memory利用不充分。\n但是如果是按transit划分，局部性就会更好，按照工作量需求分配线程数量。是不是有点像倒排索引 :-)\n线程组中的线程，他们做的事情更相似，而且工作量也差不多。他们访问的邻居也是同一个transit的，能更好利用share memory。\nSampling Large Graphs NextDoor还可以去对超出GPU memory的图采样。方法有点像mini batch，把图分成不相交的子图，每次对一个子图和和其transit节点采样。\nReference\n[1] Jangda A, Polisetty S, Guha A, et al. Accelerating graph sampling for graph machine learning using gpus[C]//Proceedings of the Sixteenth European Conference on Computer Systems. 2021: 311-326.\n[2] Ward I R, Joyner J, Lickfold C, et al. A Practical Guide to Graph Neural Networks[J]. arXiv preprint arXiv:2010.05234, 2020.\n[3] CUDA C++ Programming Guide\n","permalink":"https://Anlarry.github.io/posts/paper-reading/nextdoor/","summary":"Background 基本各种东西都可以用图来表示，也就促成了GNN的快速发展。然而很多图都有这样的特点，一些节点的度数很高然而大多数节点的度数很低。\n训练时要用邻居更新当前节点，不能将整个图全部拿来训练，因此一般采用graph sampling+mini batch，比如，给$n$个节点，每个节点对邻居采样后在进行训练。\n然而产生了新的问题，采样在整个训练过程中占了很多时间。\n因此，大家也会去想用GPU加速采样，但是naive的方法并不能很好的利用GPU。\n\u0026ldquo;Transit-Parallelism\u0026rdquo; 作者首先对采样进行了抽象，采样从一节点开始，扩展出新的节点加入sample，再从新的节点扩展$\\cdots$，每次遍历邻居扩展新节点的节点，作者把它叫做\u0026quot;transit vertices\u0026quot;\n将采样分成两类：\nIndividual Transit Sampling，这个是按节点来的，每个transit节点从邻居中采样一定数量的节点 Collective Transit Sampling，这个是按层来，每一层从所有transit节点的邻居中采样一定数量的节点 CUDA \u0026amp; GPU\n一个CUDA程序被划分给很多blocks of threads完成并行，而GPU又由很多StreamingMultiprocessors (SMs)构成，每个block被放到SM上执行\n一个block的线程数是有限的，但是相同的大小block可以被组织成grid，于是kernel(a c++ function)就可以用grid里面所有的线程。 $$ thread \\xrightarrow[]{array} block \\xrightarrow[]{array} grid $$ 众所周知，内存层次结构，GPU当然也有：\n前面已经提到了block会在SM上执行，在物理实现时会用到SIMT(Single-Instruction, Multiple-Thread)。multiprocessor用warp(a group of 32 threads)来管理线程。\nwarp中的线程都从相同的起点开始，但是每个线程都有自己的pc，寄存器状态也可能不一样。而且一个warp的thread执行的指令还是相同的。\n如果就是普通的没有控制流的代码，大家就一起执行。那遇到分支怎么办，每个线程可能有不同的路径。这时就会变成串行。warp去执行每个分支路径，不在路径上的thread就等着。这就可能会很影响并行，也就是Branch divergence。\nSample-Parallelism，对于Individual Transit Sampling可以将每一对sample和transit分配$m_i$个线程，每个sample放到一个block里。对于Collective Transit Sampling，需要先把所有的邻居存到global memory里，再采样。\n在采样时，邻居多的节点计算的时间就会更久。如果同一个warp里面的两个thread被分给两个邻居数量不同的transit，就会有divergence。而且，图得存在gobal memory，shared memory利用不充分。\n但是如果是按transit划分，局部性就会更好，按照工作量需求分配线程数量。是不是有点像倒排索引 :-)\n线程组中的线程，他们做的事情更相似，而且工作量也差不多。他们访问的邻居也是同一个transit的，能更好利用share memory。\nSampling Large Graphs NextDoor还可以去对超出GPU memory的图采样。方法有点像mini batch，把图分成不相交的子图，每次对一个子图和和其transit节点采样。\nReference\n[1] Jangda A, Polisetty S, Guha A, et al.","title":"NextDoor"},{"content":" Intro \u0026amp; Background ML模型会因为训练和测试时的数据分布不同，导致很多预测错误。将ML模型优化database也面对这个问题。\nActive learning Active leraning 主动学习采用的方法是，可以在unlabled的数据中再选出一些数据，从orcale得到数据的lable，从新的知识中学习。\nAn illustrative example of pool-based active learning Execution cost prediction \u0026amp; Plan regression prediction ECP是一个回归任务，需要预测执行plan需要的时间。在优化查询中，可以用ECP来寻找最优的plan PRP是一个分类任务，给出两个plan，需要找到哪个plan代价更高 Architecture 在这里oracle可以用database的副本执行plan，获取plan的执行时间。因此不同的plan就有不同的cost。\n开始，用户指定budget，之后ADCP获取lable数据时会消耗budget。ADCP获取target data，选出unlabeled data给交给副本执行。获得新知识后retrain ML模型，再对target data数据进行预测，这时错误就会降低。\n但是新的环境就有新的问题。active learning需要选出要标注的数据，noise会带来一些问题。因此需要综合考虑cost、robust、以及active learning最不确定的unlabel数据。 $$ w_x=\\frac{u(x)}{c(x)} $$ $c(x)$表示cost，$u(x)$表示uncertainty，因此x的权重可以理解成“uncertainty per cost”。\n同时为了解决noise，转化为概率并加入Gumbel噪音\n$$ p(x)=\\frac{w_x}{\\sum_{x\u0026rsquo;}w_{x\u0026rsquo;}} \\newline {\\rm arg}\\ \\max\\limits_{x} \\log p(x)+G_x $$\n另外，还需要减少sample时的冗余。\nAlgo \u0026 Example Comparison \u0026amp; Why it works HAL相比于其他AL策略利用了各种不同的特点。感觉这是为什么HAL可以work的一个原因。在实验中，OPT(A crude baseline)直接用cost估计(for PRP)，Huber回归(for ECP)得到label不用retrain也不需要额外的label，比其它AL错误要高出很多。\nStrategy Properties 在同样的bugdet下，HAL选出了更多的label，也就是说平均每个label的cost更低(a)。但是，对cost超过平均值的数据，error也更低(b)。\n","permalink":"https://Anlarry.github.io/posts/paper-reading/active-learning-for-ml-enhanced-database-systems/","summary":"Intro \u0026amp; Background ML模型会因为训练和测试时的数据分布不同，导致很多预测错误。将ML模型优化database也面对这个问题。\nActive learning Active leraning 主动学习采用的方法是，可以在unlabled的数据中再选出一些数据，从orcale得到数据的lable，从新的知识中学习。\nAn illustrative example of pool-based active learning Execution cost prediction \u0026amp; Plan regression prediction ECP是一个回归任务，需要预测执行plan需要的时间。在优化查询中，可以用ECP来寻找最优的plan PRP是一个分类任务，给出两个plan，需要找到哪个plan代价更高 Architecture 在这里oracle可以用database的副本执行plan，获取plan的执行时间。因此不同的plan就有不同的cost。\n开始，用户指定budget，之后ADCP获取lable数据时会消耗budget。ADCP获取target data，选出unlabeled data给交给副本执行。获得新知识后retrain ML模型，再对target data数据进行预测，这时错误就会降低。\n但是新的环境就有新的问题。active learning需要选出要标注的数据，noise会带来一些问题。因此需要综合考虑cost、robust、以及active learning最不确定的unlabel数据。 $$ w_x=\\frac{u(x)}{c(x)} $$ $c(x)$表示cost，$u(x)$表示uncertainty，因此x的权重可以理解成“uncertainty per cost”。\n同时为了解决noise，转化为概率并加入Gumbel噪音\n$$ p(x)=\\frac{w_x}{\\sum_{x\u0026rsquo;}w_{x\u0026rsquo;}} \\newline {\\rm arg}\\ \\max\\limits_{x} \\log p(x)+G_x $$\n另外，还需要减少sample时的冗余。\nAlgo \u0026 Example Comparison \u0026amp; Why it works HAL相比于其他AL策略利用了各种不同的特点。感觉这是为什么HAL可以work的一个原因。在实验中，OPT(A crude baseline)直接用cost估计(for PRP)，Huber回归(for ECP)得到label不用retrain也不需要额外的label，比其它AL错误要高出很多。\nStrategy Properties 在同样的bugdet下，HAL选出了更多的label，也就是说平均每个label的cost更低(a)。但是，对cost超过平均值的数据，error也更低(b)。","title":"Active Learning for ML Enhanced Database Systems"},{"content":"Inter-Process Communication 微内核相比与宏内核，具有更好的扩展性、安全性，也能够更好地容忍错误。但是微内核只保留很基本的功能，很多服务都作为一个用户进程存在，进程之间大量使用IPC传递消息。\n另外在宏内核中也会经常使用IPC，如Android Binder。\nOptimize synchronous IPC 一般IPC过程需要经过内核，这个过程需要保存用户态状态，当退出内核时还需恢复用户状态。因为每个进程都在自己的虚拟地址空间中，IPC过程还需要切换虚拟地址空间。另外还有一些逻辑需要处理。这些都导致IPC有较高的延迟。\nseL4用fastpath降低IPC延迟，消息会被立即发送，让kernel直接切换到server进程避免了调度器，因此可以提升IPC性能。但是也无法避免kernel。\n另一方面当传递的消息较大时，IPC一般需要将消息复制到内核，再从内核复制到另一个进程。或者使用共享内存，减少一次复制。\n在seL4上测试负载，IPC占用的时间是很多的。\nSkyBridge 为了提高IPC性能，SkyBridge想法是IPC不经过kernel,sender可以直接调用receiver的procedure。不进过kernel如何调用receiver呢？似乎需要一个新的模块完成这个功能，SkyBridge利用Intel为虚拟化提供的硬件，EPT(extended page table) 切换，允许在用户态下切换EPT，这样就可以实现在用户态下切换虚拟地址空间。\n但是为了利用EPT切换，就需要在增加一个hypervisor。（有可能会影响性能）\n在虚拟机中运行的进程，如果要访问内存会经过\nGVA(Guest virtual address)➡GPA(Guest physical address)➡HPA(Host physical address)\n这样的两级地址转换，经过Guest页表得到GPA，再经过EPT得到HPA\n同时SkyBridge中的每个进程都在自己的虚拟空间中，彼此之间相互隔离。如果通过将进程放在同一个虚拟空间，然后用EPT将他们隔离，这样的话当进程数很多的时候就会比较复杂。\n从上图可以看到SkyBridge的两个kernel：RootKernel( a tiny hypervisor)和SubKernel(即microkernel)。\n首先server在kernel中注册。kernel会吧trapoline-related代码和数据映射到server的虚拟空间，并返回一个ID用来给client调用。client向kernel注册时提供1server ID,kernel同样将代码和数据映射到他的虚拟空间。\nSubkernel调用Rootkernel的借口让server和client在EPT level上绑定，kernel会为client和server配置EPT。配置server的EPT时，SkyBridge把client的页表映射到相应server的页表。client调用direct_server_call，切换至server的EPT后使用server的页表翻译后续的地址。trapoline代码安装server的stack,调用handler。\n在执行过程中，client的CR3(页表地址)不会发生改变，SkyBridge将client CR3的HPA映射为server C3的HPA，这样就相当于切换到了server的空间。\nsomething else RootKernel \u0026amp; 虚拟化开销，Rootkernel只提供最基本的功能，同时为了降低VM exit，Rootkernel允许像更改CR3的指令不触发VM exit、让外部中断直接到microkernel处理。为了解决EPT violation，Rootkernel用1GB的页，把大部分host物理内存映射到microkernel（除了Rootkernel保留的部分，大概100MB）。这样microkernel访问物理地址时，就不会有EPT iolation。这样不仅降低了处理TLB miss的时间，也降低了TLS miss的次数。\nillegal VMFUNC，可能会导致一些安全问题。SkyBrdige的方法是功能相同的指令替换之前的指令。\nXPC 但是SkyBridge需要工作在虚拟化环境中，而且当出现调用链的时候（e.g., A$\\rightarrow$B$\\rightarrow$C）这样出现消息被多次复制的情况。\nXPC从两个方面提高IPC性能，\n让IPC不经过kernel 不复制传递消息 和SkyBridge一样XPC也属于硬件优化IPC，SkyBridge通过VMFUNC, XPC则通过在新的硬件，XPC engine。XPC engine提供了IPC的基本功能，如capability检查、上下文切换、高效轻量级的消息传递机制(relay-seg)。\nXPC engine提供了两个硬件原语：User-level Cross Process Call，Lightweight Message Transfer\nCross Procss Call x-entry, 和其他进程的procedure绑定。每个进程可以创建多个x-entry,所有的x-entry都存在x-entry-table（x-entry-table-reg指向的一个全局内存空间）中。通过x-entry-table-size控制x-entry-table的大小。xcall-cap(XPC call capability)记录每个entry的capability。\nlink stack \u0026amp; linkage record, linkage record用来维护调用时的信息，存在link stack中。link stack是存在link-reg指向的进程内存中。可以考虑使用非阻塞的方法优化压栈，减少延迟。\nx-call, 用来调在用一个x-entry。XPC engine去检查caller的xcall-cap、加载x-entry并检查、在link stack中压入linkage record、加载新的页表指针。\nx-reg, 从link stack中弹出一个record,返回之前的进程。CPU会首先检查linkage record中的有效位，然后恢复caller。\nXPC Engine Cache, 可以用cache优化XPC engine取x-entry和capability。因为对单线程IPC具有高局部性、IPC是可预测的。\nRelay Segment relay-seg, 有四个字段，虚地址基址、物理地址基址、长度、权限。地址翻译时，seg-reg的比页表有更高的优先级。\nseg-mask, 虽然不能改变seg-reg的映射，但是可以通过seg-mask缩小relay-seg\nseg-list-reg, 存放seg-reg的列表，存放在进程内存。一个进程可以创建多个relay-seg。可以通过swapseg #reg切换seg-reg\n每个时刻每个relay-seg只能有一个线程所有，同一个时刻只能有一个核对relay-reg进行操作，不然有会导致TOCTTOC攻击。\n在x-ret时，seg-reg需要和调用时一样，因为有可能恶意的程序会去修改seg-reg。\nReference\n[1] Mi, Zeyu, et al. \u0026ldquo;Skybridge: Fast and secure inter-process communication for microkernels.\u0026rdquo; Proceedings of the Fourteenth EuroSys Conference 2019. 2019.\n[2] Du, Dong, et al. \u0026ldquo;Xpc: Architectural support for secure and efficient cross process call.\u0026rdquo; Proceedings of the 46th International Symposium on Computer Architecture. 2019.\n[3] KVM硬件辅助虚拟化之 EPT(Extended Page Table)\n","permalink":"https://Anlarry.github.io/posts/paper-reading/skybridge-xpc/","summary":"Inter-Process Communication 微内核相比与宏内核，具有更好的扩展性、安全性，也能够更好地容忍错误。但是微内核只保留很基本的功能，很多服务都作为一个用户进程存在，进程之间大量使用IPC传递消息。\n另外在宏内核中也会经常使用IPC，如Android Binder。\nOptimize synchronous IPC 一般IPC过程需要经过内核，这个过程需要保存用户态状态，当退出内核时还需恢复用户状态。因为每个进程都在自己的虚拟地址空间中，IPC过程还需要切换虚拟地址空间。另外还有一些逻辑需要处理。这些都导致IPC有较高的延迟。\nseL4用fastpath降低IPC延迟，消息会被立即发送，让kernel直接切换到server进程避免了调度器，因此可以提升IPC性能。但是也无法避免kernel。\n另一方面当传递的消息较大时，IPC一般需要将消息复制到内核，再从内核复制到另一个进程。或者使用共享内存，减少一次复制。\n在seL4上测试负载，IPC占用的时间是很多的。\nSkyBridge 为了提高IPC性能，SkyBridge想法是IPC不经过kernel,sender可以直接调用receiver的procedure。不进过kernel如何调用receiver呢？似乎需要一个新的模块完成这个功能，SkyBridge利用Intel为虚拟化提供的硬件，EPT(extended page table) 切换，允许在用户态下切换EPT，这样就可以实现在用户态下切换虚拟地址空间。\n但是为了利用EPT切换，就需要在增加一个hypervisor。（有可能会影响性能）\n在虚拟机中运行的进程，如果要访问内存会经过\nGVA(Guest virtual address)➡GPA(Guest physical address)➡HPA(Host physical address)\n这样的两级地址转换，经过Guest页表得到GPA，再经过EPT得到HPA\n同时SkyBridge中的每个进程都在自己的虚拟空间中，彼此之间相互隔离。如果通过将进程放在同一个虚拟空间，然后用EPT将他们隔离，这样的话当进程数很多的时候就会比较复杂。\n从上图可以看到SkyBridge的两个kernel：RootKernel( a tiny hypervisor)和SubKernel(即microkernel)。\n首先server在kernel中注册。kernel会吧trapoline-related代码和数据映射到server的虚拟空间，并返回一个ID用来给client调用。client向kernel注册时提供1server ID,kernel同样将代码和数据映射到他的虚拟空间。\nSubkernel调用Rootkernel的借口让server和client在EPT level上绑定，kernel会为client和server配置EPT。配置server的EPT时，SkyBridge把client的页表映射到相应server的页表。client调用direct_server_call，切换至server的EPT后使用server的页表翻译后续的地址。trapoline代码安装server的stack,调用handler。\n在执行过程中，client的CR3(页表地址)不会发生改变，SkyBridge将client CR3的HPA映射为server C3的HPA，这样就相当于切换到了server的空间。\nsomething else RootKernel \u0026amp; 虚拟化开销，Rootkernel只提供最基本的功能，同时为了降低VM exit，Rootkernel允许像更改CR3的指令不触发VM exit、让外部中断直接到microkernel处理。为了解决EPT violation，Rootkernel用1GB的页，把大部分host物理内存映射到microkernel（除了Rootkernel保留的部分，大概100MB）。这样microkernel访问物理地址时，就不会有EPT iolation。这样不仅降低了处理TLB miss的时间，也降低了TLS miss的次数。\nillegal VMFUNC，可能会导致一些安全问题。SkyBrdige的方法是功能相同的指令替换之前的指令。\nXPC 但是SkyBridge需要工作在虚拟化环境中，而且当出现调用链的时候（e.g., A$\\rightarrow$B$\\rightarrow$C）这样出现消息被多次复制的情况。\nXPC从两个方面提高IPC性能，\n让IPC不经过kernel 不复制传递消息 和SkyBridge一样XPC也属于硬件优化IPC，SkyBridge通过VMFUNC, XPC则通过在新的硬件，XPC engine。XPC engine提供了IPC的基本功能，如capability检查、上下文切换、高效轻量级的消息传递机制(relay-seg)。\nXPC engine提供了两个硬件原语：User-level Cross Process Call，Lightweight Message Transfer\nCross Procss Call x-entry, 和其他进程的procedure绑定。每个进程可以创建多个x-entry,所有的x-entry都存在x-entry-table（x-entry-table-reg指向的一个全局内存空间）中。通过x-entry-table-size控制x-entry-table的大小。xcall-cap(XPC call capability)记录每个entry的capability。","title":"SkyBridge \u0026 XPC"},{"content":"Codeforces Round #664 https://codeforces.com/contest/1395\nA 题意\n给四种颜色的球，可以把一个红色一个蓝色一个绿色染成白色，问能不能变成回文串\n#include \u0026lt;cstdio\u0026gt; #include \u0026lt;stack\u0026gt; #include \u0026lt;set\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;map\u0026gt; #include \u0026lt;time.h\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; //#include \u0026lt;memory.h\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;iomanip\u0026gt; #include \u0026lt;cassert\u0026gt; #include \u0026lt;unordered_map\u0026gt; #define P pair\u0026lt;int, int\u0026gt; #define LL long long #define LD long double #define PLL pair\u0026lt;LL, LL\u0026gt; #define mset(a, b) memset(a, b, sizeof(a)) #define rep(i, a, b) for (int i = a; i \u0026lt; b; i++) #define PI acos(-1.0) #define random(x) rand() % x #define debug(x) cout \u0026lt;\u0026lt; #x \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34; using namespace std; const int inf = 0x3f3f3f3f; const LL __64inf = 0x3f3f3f3f3f3f3f3f; #ifdef DEBUG const int MAX = 2e3 + 50; #else const int MAX = 2e6 + 500; #endif const int mod = 1e9 + 7; void file_read() { #ifdef DEBUG freopen(\u0026#34;in\u0026#34;, \u0026#34;r\u0026#34;, stdin); // freopen(\u0026#34;out\u0026#34;, \u0026#34;w\u0026#34;, stdout); #endif } int main() { file_read(); int T; LL a, b, c, d; scanf(\u0026#34;%d\u0026#34;, \u0026amp;T); while (T--) { cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b \u0026gt;\u0026gt; c \u0026gt;\u0026gt; d; LL tot = a + b + c + d; if(tot \u0026amp; 1) { int odd = (a \u0026amp; 1) + (b \u0026amp; 1) + (c \u0026amp; 1) + (d \u0026amp; 1); if(odd == 1) { puts(\u0026#34;Yes\u0026#34;); continue; } if(a \u0026gt; 0 and b \u0026gt; 0 and c \u0026gt; 0) { a--, b--, c--, d+=3; odd = (a \u0026amp; 1) + (b \u0026amp; 1) + (c \u0026amp; 1) + (d \u0026amp; 1); if(odd == 1) { puts(\u0026#34;Yes\u0026#34;); continue; } } puts(\u0026#34;No\u0026#34;); continue; }\telse { int odd = (a \u0026amp; 1) + (b \u0026amp; 1) + (c \u0026amp; 1) + (d \u0026amp; 1); if(odd == 0 ) { puts(\u0026#34;Yes\u0026#34;); continue; } if(a \u0026gt; 0 and b \u0026gt; 0 and c \u0026gt; 0 and d \u0026gt; 0) { a--, b--, c--, d += 3; odd = (a \u0026amp; 1) + (b \u0026amp; 1) + (c \u0026amp; 1) + (d \u0026amp; 1); if(odd == 0) { puts(\u0026#34;Yes\u0026#34;); continue; } }\tputs(\u0026#34;No\u0026#34;); } } return 0; } B 题意\n在棋盘上走，类似于车，求遍历所有格子一次的方案\n#include \u0026lt;cstdio\u0026gt; #include \u0026lt;stack\u0026gt; #include \u0026lt;set\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;map\u0026gt; #include \u0026lt;time.h\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; //#include \u0026lt;memory.h\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;iomanip\u0026gt; #include \u0026lt;cassert\u0026gt; #include \u0026lt;unordered_map\u0026gt; #define P pair\u0026lt;int, int\u0026gt; #define LL long long #define LD long double #define PLL pair\u0026lt;LL, LL\u0026gt; #define mset(a, b) memset(a, b, sizeof(a)) #define rep(i, a, b) for (int i = a; i \u0026lt; b; i++) #define PI acos(-1.0) #define random(x) rand() % x #define debug(x) cout \u0026lt;\u0026lt; #x \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34; using namespace std; const int inf = 0x3f3f3f3f; const LL __64inf = 0x3f3f3f3f3f3f3f3f; #ifdef DEBUG const int MAX = 2e3 + 50; #else const int MAX = 2e6 + 500; #endif const int mod = 1e9 + 7; void file_read() { #ifdef DEBUG freopen(\u0026#34;in\u0026#34;, \u0026#34;r\u0026#34;, stdin); // freopen(\u0026#34;out\u0026#34;, \u0026#34;w\u0026#34;, stdout); #endif } void print(int x, int y) { printf(\u0026#34;%d %d\\n\u0026#34;, x, y); } bool vis[105][105]; int main() { file_read(); int n, m, x, y; int X, Y; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y; X = x, Y = y; print(x, y--); while(y \u0026gt;= 1) { print(x, y--); } y = Y+1; while(y \u0026lt;= m) { print(x, y++); } y = m; for(int i = x-1; i \u0026gt;= 1; i--) { if(y == m){ for(; y \u0026gt;= 1; y--) print(i, y); y = 1; } else if(y == 1) { for(; y \u0026lt;= m; y++) print(i, y); y = m; } } for(int i = x+1; i \u0026lt;= n; i++) { if(y == m){ for(; y \u0026gt;= 1; y--) print(i, y); y = 1; } else if(y == 1) { for(; y \u0026lt;= m; y++) print(i, y); y = m; } } return 0; } C 题意\n给两个序列$a$,$b$, 对每个$a_i$可以选择一个$b_j$,$c_i=a_i \u0026amp; b_j$,求最小的$c_1|c_2|\\dots|c_n$\nSolution\n从高位到低位，使得每一位尽可能为0，维护对于每个$a_i$,可以用的$b_j$\n#include \u0026lt;cstdio\u0026gt; #include \u0026lt;stack\u0026gt; #include \u0026lt;set\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;map\u0026gt; #include \u0026lt;time.h\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; //#include \u0026lt;memory.h\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;iomanip\u0026gt; #include \u0026lt;cassert\u0026gt; #include \u0026lt;unordered_map\u0026gt; #define P pair\u0026lt;int, int\u0026gt; #define LL long long #define LD long double #define PLL pair\u0026lt;LL, LL\u0026gt; #define mset(a, b) memset(a, b, sizeof(a)) #define rep(i, a, b) for (int i = a; i \u0026lt; b; i++) #define PI acos(-1.0) #define random(x) rand() % x #define debug(x) cout \u0026lt;\u0026lt; #x \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34; using namespace std; const int inf = 0x3f3f3f3f; const LL __64inf = 0x3f3f3f3f3f3f3f3f; #ifdef DEBUG const int MAX = 2e3 + 50; #else const int MAX = 2e6 + 500; #endif const int mod = 1e9 + 7; void file_read() { #ifdef DEBUG freopen(\u0026#34;in\u0026#34;, \u0026#34;r\u0026#34;, stdin); // freopen(\u0026#34;out\u0026#34;, \u0026#34;w\u0026#34;, stdout); #endif } int n, m; LL a[MAX], b[MAX]; bool ok[205][205]; bool check(LL x) { bool res = true; for(int i = 1; i \u0026lt;= n; i++) { bool cur = false; for(int j = 1; j \u0026lt;= m; j++) { if(!ok[i][j]) continue; if((a[i] \u0026amp; b[j] \u0026amp; x) == 0) { cur = true; break; } } res \u0026amp;= cur; } if(res) { for(int i = 1; i \u0026lt;= n; i++) { for(int j = 1; j \u0026lt;= m; j++) { if((a[i] \u0026amp; b[j] \u0026amp; x) != 0) { ok[i][j] = false; } } } } return res; } int main() { file_read(); scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); for(int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; a[i]; for(int i = 1; i \u0026lt;= m; i++) cin \u0026gt;\u0026gt; b[i]; LL ans = 0; mset(ok, 1); for(LL i = 32; i \u0026gt;= 0; i--) { if(!check(1LL\u0026lt;\u0026lt;i)) { ans |= (1LL\u0026lt;\u0026lt;i); } } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; return 0; } D 题意\n给以序列$a$,可以选$n$次数字，如果数字大于$m$,那么后$d$次就不能选，求选出的数字的最大值\nSolution\n枚举选的数字小于等于$m$的个数，可以选择超过$m$的数字就是固定的，选择最大的\n#include \u0026lt;cstdio\u0026gt; #include \u0026lt;stack\u0026gt; #include \u0026lt;set\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;map\u0026gt; #include \u0026lt;time.h\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; //#include \u0026lt;memory.h\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;iomanip\u0026gt; #include \u0026lt;cassert\u0026gt; #include \u0026lt;unordered_map\u0026gt; #define P pair\u0026lt;int, int\u0026gt; #define LL long long #define LD long double #define PLL pair\u0026lt;LL, LL\u0026gt; #define mset(a, b) memset(a, b, sizeof(a)) #define rep(i, a, b) for (int i = a; i \u0026lt; b; i++) #define PI acos(-1.0) #define random(x) rand() % x #define debug(x) cout \u0026lt;\u0026lt; #x \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34; using namespace std; const int inf = 0x3f3f3f3f; const LL __64inf = 0x3f3f3f3f3f3f3f3f; #ifdef DEBUG const int MAX = 2e3 + 50; #else const int MAX = 2e6 + 500; #endif const int mod = 1e9 + 7; void file_read() { #ifdef DEBUG freopen(\u0026#34;in\u0026#34;, \u0026#34;r\u0026#34;, stdin); // freopen(\u0026#34;out\u0026#34;, \u0026#34;w\u0026#34;, stdout); #endif } LL a[MAX]; LL A[MAX], B[MAX]; LL sa[MAX], sb[MAX]; int main() { file_read(); LL n, d, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; d \u0026gt;\u0026gt; m; for(int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; a[i]; sort(a+1, a+1+n, [](LL x, LL y) { return x \u0026gt; y; }); int tot1 = 0, tot2 = 0; for(int i = 1; i \u0026lt;= n; i++) { if(a[i] \u0026lt;= m) A[++tot1] = a[i]; else B[++tot2] = a[i]; } if(tot1 == 0) { LL nn = (n+d) / (d + 1); LL ans = 0; for(int i = 1; i \u0026lt;= nn; i++) { ans += B[i]; } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; return 0; } if(tot2 == 0) { LL ans = 0; for(int i = 1; i \u0026lt;= n; i++) { ans += A[i]; } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; return 0; } for(int i = 1; i \u0026lt;= tot1; i++) sa[i] = sa[i-1] + A[i]; for(int i = 1; i \u0026lt;= tot2; i++) sb[i] = sb[i-1] + B[i]; LL ans = 0; for(int i = 0; i \u0026lt;= tot1; i++) { LL cur = sa[i]; LL nn = (n-i+d) / (d+1); ans = max(cur+sb[nn], ans); } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; return 0; } E 题意\n给一个图$G=(V,E)$,选择一个tuple $(c_1,\\dots, c_k)$作为遍历图的规则，出度为$i$的点的下一个节点是第$c_i$小的边指向的点，问有多少种tuple可以把图遍历一遍\nSolution\n不能发现其实最后的路径是一个环，可以对每个点的下一个节点所组成的集合是$V$，因此可以通判断过这是否成立来检查一个tuple 另外可以将点按出度分类，维护$S[i][j]$表示出度为$i$的点，选第$j$小的边所到达的点的集合 可以用hash判断集合是否相等，有可能会冲突 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;stack\u0026gt; #include \u0026lt;set\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;map\u0026gt; #include \u0026lt;time.h\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; //#include \u0026lt;memory.h\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;iomanip\u0026gt; #include \u0026lt;cassert\u0026gt; #include \u0026lt;unordered_map\u0026gt; #define P pair\u0026lt;int, int\u0026gt; #define LL long long #define LD long double #define PLL pair\u0026lt;LL, LL\u0026gt; #define mset(a, b) memset(a, b, sizeof(a)) #define rep(i, a, b) for (int i = a; i \u0026lt; b; i++) #define PI acos(-1.0) #define random(x) rand() % x #define debug(x) cout \u0026lt;\u0026lt; #x \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34; using namespace std; const int inf = 0x3f3f3f3f; const LL __64inf = 0x3f3f3f3f3f3f3f3f; #ifdef DEBUG const int MAX = 2e3 + 50; #else const int MAX = 2e6 + 500; #endif const int mod = 1e9 + 7; void file_read() { #ifdef DEBUG freopen(\u0026#34;in\u0026#34;, \u0026#34;r\u0026#34;, stdin); // freopen(\u0026#34;out\u0026#34;, \u0026#34;w\u0026#34;, stdout); #endif } #define ULL unsigned long long const int mod2 = 998244353; vector\u0026lt;P\u0026gt; G[MAX]; ULL s[100][100]; LL g[100][100]; LL t[100][100]; bool vis[MAX]; ULL val[MAX]; ULL TARGET1 = 1; LL TARGET2 = 1; LL TARGET3 = 1; int n, m, k; int ans; void dfs(int u) { vis[u] = 1; for(int i = 0; i \u0026lt; G[u].size(); i++) { int v = G[u][i].first; s[G[u].size()][i+1] *= (ULL)val[v]; g[G[u].size()][i+1] = g[G[u].size()][i+1] * val[v] % mod; t[G[u].size()][i+1] = t[G[u].size()][i+1] * val[v] % mod2; if(vis[v]) continue; dfs(v); } } void dfs2(int x, ULL cur1, LL cur2, LL cur3) { if(x \u0026gt; k) { if(cur1 == TARGET1 and cur2 == TARGET2 and cur3 == TARGET3) ans ++; return ; } for(int i = 1; i \u0026lt;= x; i++) { dfs2(x+1, cur1*s[x][i], cur2*g[x][i]%mod, cur3 * t[x][i] % mod2); } } int main() { srand((int)time(0)); file_read(); for(int i = 0; i \u0026lt; 100; i++) for(int j = 0; j \u0026lt; 100; j++) s[i][j] = g[i][j] = t[i][j] = 1; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;n, \u0026amp;m, \u0026amp;k); for(int i = 1; i \u0026lt;= n; i++) val[i] = rand() % mod; for(ULL i = 1; i \u0026lt;= n; i++) TARGET1 = TARGET1 * val[i], TARGET2 = TARGET2 * val[i] % mod, TARGET3 = TARGET3 * val[i] % mod2; for(int i = 1; i \u0026lt;= m; i++) { int u, v, w; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;u, \u0026amp;v, \u0026amp;w); G[u].push_back({v, w}); } for(int i = 1; i \u0026lt;= n; i++) { sort(G[i].begin(), G[i].end(), [](const P\u0026amp;A, const P\u0026amp;B){ return A.second \u0026lt; B.second; }); } dfs(1); dfs2(1, 1, 1, 1); printf(\u0026#34;%d\\n\u0026#34;, ans); return 0; } F 题意\n定义串只有N和B，有四种操作，给$s_1, \\dots, s_n$，求一个串$t$使得和$s$的最大距离最小\nSolution\n不难发现字符串对应一个坐标，对于一个$x,y$可以移动上下左右，或者右上，左下 对于一个点，在固定距离内可以访问的点是一个六边形 要找一个最小半径的六边形覆盖所有的点 因此二分半径，计算六边形中心的可行区域 最后在可行区域选一个作为$t$,不能是空串 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;stack\u0026gt; #include \u0026lt;set\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;map\u0026gt; #include \u0026lt;time.h\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; //#include \u0026lt;memory.h\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;iomanip\u0026gt; #include \u0026lt;cassert\u0026gt; #include \u0026lt;unordered_map\u0026gt; #define P pair\u0026lt;int, int\u0026gt; #define LL long long #define LD long double #define PLL pair\u0026lt;LL, LL\u0026gt; #define mset(a, b) memset(a, b, sizeof(a)) #define rep(i, a, b) for (int i = a; i \u0026lt; b; i++) #define PI acos(-1.0) #define random(x) rand() % x #define debug(x) cout \u0026lt;\u0026lt; #x \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34; using namespace std; const int inf = 0x3f3f3f3f; const LL __inf64 = 0x3f3f3f3f3f3f3f3f; #ifdef DEBUG const int MAX = 2e3 + 50; #else const int MAX = 2e6 + 500; #endif const int mod = 1e9 + 7; void file_read() { #ifdef DEBUG freopen(\u0026#34;in\u0026#34;, \u0026#34;r\u0026#34;, stdin); // freopen(\u0026#34;out\u0026#34;, \u0026#34;w\u0026#34;, stdout); #endif } vector\u0026lt;P\u0026gt; pt; int xL, xR, yL, yR, zL, zR; bool check(int mid) { xL = -inf, xR = inf, yL = -inf, yR = inf, zL = -inf, zR = inf; for(auto p : pt) { xL = max(xL, p.first-mid); xR = min(xR, p.first+mid); yL = max(yL, p.second-mid); yR = min(yR, p.second+mid); zL = max(zL, p.first-p.second-mid); zR = min(zR, p.first-p.second+mid); } if(xL \u0026gt; xR || yL \u0026gt; yR || zL \u0026gt; zR) return false; yL = max(yL, xL-zR); yR = min(yR, xR-zL); if(yL \u0026gt; yR) return false; return true; } int main() { file_read(); int n; cin \u0026gt;\u0026gt; n; for(int i = 1; i \u0026lt;= n; i++) { string s; cin \u0026gt;\u0026gt; s; int x = 0, y = 0; for(auto c : s) { if(c == \u0026#39;B\u0026#39;) x++; else y++; } pt.emplace_back(x, y); } int l = 0, r = inf; while(l \u0026lt; r) { int mid = (l + r) \u0026gt;\u0026gt; 1; if(check(mid)) r = mid; else l = mid + 1; } // cout \u0026lt;\u0026lt; check(l) \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; check(l); int ansx, ansy; for(int x = max(0, xL); x \u0026lt;= xR; x++) { int curyL = max(yR, x-zR); int curyR = min(yR, x-zL); if(curyL \u0026gt; curyR) continue; if(x \u0026gt; 0 || curyR \u0026gt; 0) { ansx = x; ansy = curyR; break; }\t} cout \u0026lt;\u0026lt; l \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; while(ansx--) printf(\u0026#34;B\u0026#34;); while(ansy--) printf(\u0026#34;N\u0026#34;); return 0; } ","permalink":"https://Anlarry.github.io/posts/acm-icpc/codeforces-round-664/","summary":"Codeforces Round #664 https://codeforces.com/contest/1395\nA 题意\n给四种颜色的球，可以把一个红色一个蓝色一个绿色染成白色，问能不能变成回文串\n#include \u0026lt;cstdio\u0026gt; #include \u0026lt;stack\u0026gt; #include \u0026lt;set\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;map\u0026gt; #include \u0026lt;time.h\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; //#include \u0026lt;memory.h\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;iomanip\u0026gt; #include \u0026lt;cassert\u0026gt; #include \u0026lt;unordered_map\u0026gt; #define P pair\u0026lt;int, int\u0026gt; #define LL long long #define LD long double #define PLL pair\u0026lt;LL, LL\u0026gt; #define mset(a, b) memset(a, b, sizeof(a)) #define rep(i, a, b) for (int i = a; i \u0026lt; b; i++) #define PI acos(-1.","title":"Codeforces Round #664"},{"content":"Gym - 102501D Gnalcats https://codeforces.com/gym/102501/problem/D\n题意 给两种栈操作判断是否相等,如果两个操作都fail，也认为相等\nSolution 模拟，每个氨基酸一个hash值。通过判断最后栈元素是否对应hash相等，判断操作是否相等\n#include \u0026lt;cstdio\u0026gt; #include \u0026lt;stack\u0026gt; #include \u0026lt;set\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;map\u0026gt; #include \u0026lt;time.h\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; //#include \u0026lt;memory.h\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;iomanip\u0026gt; #include \u0026lt;cassert\u0026gt; #include \u0026lt;unordered_map\u0026gt; #define P pair\u0026lt;int, int\u0026gt; #define LL long long #define LD long double #define PLL pair\u0026lt;LL, LL\u0026gt; #define mset(a, b) memset(a, b, sizeof(a)) #define rep(i, a, b) for (int i = a; i \u0026lt; b; i++) #define PI acos(-1.0) #define random(x) rand() % x #define debug(x) cout \u0026lt;\u0026lt; #x \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34; using namespace std; const int inf = 0x3f3f3f3f; const LL __64inf = 0x3f3f3f3f3f3f3f3f; #ifdef DEBUG const int MAX = 2e3 + 50; #else const int MAX = 1e6 + 50; #endif const int mod = 1e9 + 7; void file_read() { #ifdef DEBUG freopen(\u0026#34;in\u0026#34;, \u0026#34;r\u0026#34;, stdin); // freopen(\u0026#34;out\u0026#34;, \u0026#34;w\u0026#34;, stdout); #endif } #define ULL unsigned long long struct DNA { struct Node { int l, r; unsigned LL val; Node(){} Node(int l, int r, unsigned LL val) : l(l), r(r), val(val) {} bool complex() const { return l and r; } }tr[MAX]; stack\u0026lt;int\u0026gt; stk; int tot; int num; DNA() : tot(1), num(1) { for(int i = 1; i \u0026lt;= (int)1e5; i++) { tr[tot] = Node(0, 0, num++); stk.push(tot); tot++; } } ULL hash(int u, int v) { ULL base = 131; return tr[u].val * base + tr[v].val; } bool op_C() { auto u = stk.top(); tr[tot] = tr[u]; stk.push(tot); tot++; return true;\t} bool op_D() { stk.pop(); return true; } bool op_L() { auto u = stk.top(); stk.pop(); if(!tr[u].complex()) return false;\t// tr[tot] = tr[tr[u].l]; // stk.push(tot); stk.push(tr[u].l); return true; } bool op_P() { auto u = stk.top(); stk.pop(); auto v = stk.top(); stk.pop(); tr[tot] = Node(u, v, hash(u, v)); stk.push(tot); tot++; return true; } bool op_R() { auto u = stk.top(); stk.pop(); if(!tr[u].complex()) return false; // tr[tot] = tr[tr[u].r]; // stk.push(tot++); stk.push(tr[u].r); return true; } bool op_S() { auto u = stk.top(); stk.pop(); auto v = stk.top(); stk.pop(); stk.push(u); stk.push(v); return true; } bool op_U() { auto u = stk.top(); stk.pop(); if(!tr[u].complex()) return false; stk.push(tr[u].r); stk.push(tr[u].l); return true; } bool op(const string \u0026amp;s) { bool res = true; for(auto c : s) { switch (c) { case \u0026#39;C\u0026#39;:res \u0026amp;= op_C(); break; case \u0026#39;D\u0026#39;:res \u0026amp;= op_D(); break; case \u0026#39;L\u0026#39;:res \u0026amp;= op_L(); break; case \u0026#39;P\u0026#39;:res \u0026amp;= op_P(); break; case \u0026#39;R\u0026#39;:res \u0026amp;= op_R(); break; case \u0026#39;S\u0026#39;:res \u0026amp;= op_S(); break; case \u0026#39;U\u0026#39;:res \u0026amp;= op_U(); break; default: break; } } return res ; } }; DNA A, B; int main() { file_read(); string s, t; cin \u0026gt;\u0026gt; s \u0026gt;\u0026gt; t; A = DNA(); B = DNA(); bool a = A.op(s); bool b = B.op(t); if(a ^ b) { puts(\u0026#34;False\u0026#34;); return 0; } if(!a and !b) { puts(\u0026#34;True\u0026#34;); return 0; } while(!A.stk.empty() and !B.stk.empty()) { auto u = A.stk.top(); A.stk.pop(); auto v = B.stk.top(); B.stk.pop(); if(A.tr[u].val != B.tr[v].val) { puts(\u0026#34;False\u0026#34;); return 0; } } if(!A.stk.empty() || !B.stk.empty()) { puts(\u0026#34;False\u0026#34;); return 0; } puts(\u0026#34;True\u0026#34;); return 0; } Gym - 102501J https://codeforces.com/gym/102501/problem/J\n题意 给一个树的中序遍历序列，判断有多少满足类似小根堆的树，$n\u0026lt;=1e5$\nSolution 直接dp一定会超时 考虑根可能在的位置，即当前最小元素的位置 考虑选这些元素为根会有哪些树，就可以发现当前的最小元素将序列分成子段，当前元素作为根的种类数是卡特兰数 因此递归解决这个问题，每次用最小元素分割当前序列，最后其实就是一些卡特兰数的乘积 用单调栈会更优美一点 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;stack\u0026gt; #include \u0026lt;set\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;map\u0026gt; #include \u0026lt;time.h\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; //#include \u0026lt;memory.h\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;iomanip\u0026gt; #include \u0026lt;cassert\u0026gt; #include \u0026lt;unordered_map\u0026gt; #define P pair\u0026lt;int, int\u0026gt; #define LL long long #define LD long double #define PLL pair\u0026lt;LL, LL\u0026gt; #define mset(a, b) memset(a, b, sizeof(a)) #define rep(i, a, b) for (int i = a; i \u0026lt; b; i++) #define PI acos(-1.0) #define random(x) rand() % x #define debug(x) cout \u0026lt;\u0026lt; #x \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34; using namespace std; const int inf = 0x3f3f3f3f; const LL __64inf = 0x3f3f3f3f3f3f3f3f; #ifdef DEBUG const int MAX = 2e3 + 50; #else const int MAX = 2e6 + 500; #endif const int mod = 1e9 + 7; void file_read() { #ifdef DEBUG freopen(\u0026#34;in\u0026#34;, \u0026#34;r\u0026#34;, stdin); // freopen(\u0026#34;out\u0026#34;, \u0026#34;w\u0026#34;, stdout); #endif } int a[MAX]; LL fact[MAX]; LL inv[MAX]; map\u0026lt;int, vector\u0026lt;int\u0026gt;\u0026gt; pos; LL qpow(LL x, LL n) { LL res = 1; while(n) { if(n \u0026amp; 1) { res = res * x % mod; } x = x * x % mod; n \u0026gt;\u0026gt;= 1; } return res; } LL f(LL x) { return fact[2*x] * inv[x] % mod * inv[x+1] % mod; } int main() { file_read(); int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for(int i = 1; i \u0026lt;= n; i++) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i]); } fact[0] = 1; for(int i = 1; i \u0026lt; MAX; i++) fact[i] = 1LL * fact[i-1] * i % mod; inv[MAX-1] = qpow(fact[MAX-1], mod-2); for(int i = MAX-2; i \u0026gt;= 1; i--) inv[i] = 1LL * (i+1) * inv[i+1] % mod; inv[0] = 1; LL res = 1; stack\u0026lt;int\u0026gt; stk; for(int i = 1; i \u0026lt;= n; i++) { if(stk.empty()) { stk.push(a[i]); continue; } int cnt = 0; int cur = inf; while(!stk.empty() and stk.top() \u0026gt; a[i]) { if(stk.top() == cur) { cnt++; } else { res = res * f(cnt) % mod; cnt = 1; cur = stk.top(); } stk.pop(); } stk.push(a[i]); res = res * f(cnt) % mod; } int cur = inf; int cnt = 0; while(!stk.empty()) { if(stk.top() == cur) { cnt++; } else { res = res * f(cnt) % mod; cur = stk.top(); cnt = 1; } stk.pop(); } res = res * f(cnt ) % mod; printf(\u0026#34;%lld\\n\u0026#34;, res); } ","permalink":"https://Anlarry.github.io/posts/acm-icpc/gym-102501%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/","summary":"Gym - 102501D Gnalcats https://codeforces.com/gym/102501/problem/D\n题意 给两种栈操作判断是否相等,如果两个操作都fail，也认为相等\nSolution 模拟，每个氨基酸一个hash值。通过判断最后栈元素是否对应hash相等，判断操作是否相等\n#include \u0026lt;cstdio\u0026gt; #include \u0026lt;stack\u0026gt; #include \u0026lt;set\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;map\u0026gt; #include \u0026lt;time.h\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; //#include \u0026lt;memory.h\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;iomanip\u0026gt; #include \u0026lt;cassert\u0026gt; #include \u0026lt;unordered_map\u0026gt; #define P pair\u0026lt;int, int\u0026gt; #define LL long long #define LD long double #define PLL pair\u0026lt;LL, LL\u0026gt; #define mset(a, b) memset(a, b, sizeof(a)) #define rep(i, a, b) for (int i = a; i \u0026lt; b; i++) #define PI acos(-1.","title":"Gym 102501部分题解"},{"content":"Gym 102460L Largest Quadrilateral Largest Quadrilateral\n题意 给$n$个点从中选出四个点，使得面积最大\nSolution 首先，肯定是求凸包，要求的点一定在凸包上。 不难联想到凸包对每个边求最大三角形面积的问题，也就是旋转卡壳。 可以将问题转化为，对凸包的每一个对角线$A_iA_j$，求最大面积的两个三角形，$\\triangle{A_iA_jP}$, $\\triangle{A_iA_jQ}$, 然后就可以枚举对角线，旋转卡壳算最大面积 细节\n输出的格式 凸包上应该留下共线的点 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;stack\u0026gt; #include \u0026lt;set\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;map\u0026gt; #include \u0026lt;time.h\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; //#include \u0026lt;memory.h\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;iomanip\u0026gt; #include \u0026lt;cassert\u0026gt; // #include \u0026lt;unordered_map\u0026gt; #define P pair\u0026lt;int, int\u0026gt; #define LL long long #define LD long double #define PLL pair\u0026lt;LL, LL\u0026gt; #define mset(a, b) memset(a, b, sizeof(a)) #define rep(i, a, b) for (int i = a; i \u0026lt; b; i++) #define PI acos(-1.0) #define random(x) rand() % x #define debug(x) cout \u0026lt;\u0026lt; #x \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34; using namespace std; const int inf = 0x3f3f3f3f; const LL __64inf = 0x3f3f3f3f3f3f3f3f; #ifdef DEBUG const int MAX = 2e3 + 50; #else const int MAX = 1e6 + 50; #endif const int mod = 1e9+9; void file_read(){ #ifdef DEBUG freopen(\u0026#34;in\u0026#34;, \u0026#34;r\u0026#34;, stdin); // freopen(\u0026#34;out\u0026#34;, \u0026#34;w\u0026#34;, stdout); #endif } template\u0026lt;typename type\u0026gt; struct Vec { type x, y; Vec() {} Vec(type x, type y) : x(x), y(y) {} friend istream \u0026amp; operator \u0026gt;\u0026gt; (istream \u0026amp;in, Vec \u0026amp;A) { in \u0026gt;\u0026gt; A.x \u0026gt;\u0026gt; A.y; return in; } friend Vec operator - (const Vec \u0026amp;A, const Vec \u0026amp;B) { return Vec(A.x-B.x, A.y-B.y); } friend Vec operator + (const Vec \u0026amp;A, const Vec \u0026amp;B) { return Vec(A.x + B.x, A.y + B.y); } friend type det(const Vec \u0026amp;A, const Vec \u0026amp;B) { return A.x * B.y - A.y * B.x; } friend type dot(const Vec \u0026amp;A, const Vec \u0026amp;B) { return A.x * B.x + A.y * B.y; } friend bool operator \u0026lt; (const Vec \u0026amp;A, const Vec \u0026amp;B) { if(A.x != B.x) return A.x \u0026lt; B.x; return A.y \u0026lt; B.y; } friend type area(const Vec \u0026amp;A, const Vec \u0026amp;B) { return abs(det(A, B)); } friend type operator == (const Vec \u0026amp;A, const Vec \u0026amp;B) { return A.x == B.x and A.y == B.y; } }; template\u0026lt;typename type\u0026gt; vector\u0026lt;Vec\u0026lt;type\u0026gt;\u0026gt; convex_hull(vector\u0026lt;Vec\u0026lt;type\u0026gt;\u0026gt; \u0026amp;pt) { sort(pt.begin(), pt.end()); int n = pt.size(); vector\u0026lt;Vec\u0026lt;type\u0026gt;\u0026gt; res(2*n); int k = 0 ; for(int i = 0; i \u0026lt; n; i++) { while(k \u0026gt; 1 and det(res[k-1]-res[k-2], pt[i]-res[k-1]) \u0026lt; 0) // \u0026lt;=会wa k--; res[k++] = pt[i]; } for(int i = n-2, t = k; i \u0026gt;= 0; i--) { while(k \u0026gt; t and det(res[k-1]-res[k-2], pt[i]-res[k-1]) \u0026lt; 0) // \u0026lt;=会wa k--; res[k++] = pt[i]; } res.resize(k-1); return res; } struct ModI { int i, n; ModI(int n ) : i(0), n(n) { assert(n \u0026gt; 0) ;} ModI(int i, int n) : i(i%n), n(n) { assert(n \u0026gt; 0); } ModI operator ++ ( int ) { ModI row = ModI(i, n); i = (i + 1) % n; return row; } ModI operator + (int x) { ModI res = ModI(i, n); res.i = (res.i + x) % n; return res; } int operator = (int x) { return i = x; } bool operator \u0026lt; (int x) const { return i \u0026lt; x; } bool operator == (const ModI \u0026amp;other) const { return i == other.i; } operator int () { return i; } }; template\u0026lt;typename type\u0026gt; type area(const Vec\u0026lt;type\u0026gt; \u0026amp;A, const Vec\u0026lt;type\u0026gt; \u0026amp;B, const Vec\u0026lt;type\u0026gt; \u0026amp;C) { return area(A-B, A-C); } template\u0026lt;typename type\u0026gt; type rotateCalipers(vector\u0026lt;Vec\u0026lt;type\u0026gt;\u0026gt; pt) { int n = pt.size(); type res = 0; for(int i = 0; i \u0026lt; pt.size(); i++) { ModI p1 = ModI(i+1, n); ModI p2 = ModI(i+3, n); for(ModI j = ModI(i+2, n); j+1 != i; j++) { while(p1+1 != j and area(pt[p1], pt[i], pt[j]) \u0026lt; area(pt[p1+1], pt[i], pt[j])) p1 ++; if(j == p2) p2++; while(p2+1 != i and area(pt[p2], pt[i], pt[j]) \u0026lt; area(pt[p2+1], pt[i], pt[j])) p2 ++; auto cur = area(pt[p1], pt[i], pt[j]) + area(pt[p2], pt[i], pt[j]); res = max(res, cur); } } return res; } void out(LL ans) { if(ans \u0026amp; 1) { printf(\u0026#34;%lld.5\\n\u0026#34;, ans \u0026gt;\u0026gt; 1); } else { printf(\u0026#34;%lld\\n\u0026#34;, ans \u0026gt;\u0026gt; 1); } } int main() { file_read(); int T; scanf(\u0026#34;%d\u0026#34;, \u0026amp;T); while (T--) { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); vector\u0026lt;Vec\u0026lt;LL\u0026gt;\u0026gt; pt(n); for(int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; pt[i]; auto ch = convex_hull(pt); if(ch.size() \u0026lt; 3) { printf(\u0026#34;0\\n\u0026#34;); continue; } if(ch.size() == 3) { LL ans = 0; LL A = area(ch[0], ch[1], ch[2]); for(auto p : pt) { if(p == ch[0] or p == ch[1] or p == ch[2]) continue; auto a = area(p, ch[1], ch[2]); a = min(a, area(p, ch[0], ch[2])); a = min(a, area(p, ch[0], ch[1])); ans = max(ans, A-a); } out(ans); continue; } LL res = rotateCalipers(ch); out(res); } return 0; } ","permalink":"https://Anlarry.github.io/posts/acm-icpc/gym-102460l-largest-quadrilateral/","summary":"Gym 102460L Largest Quadrilateral Largest Quadrilateral\n题意 给$n$个点从中选出四个点，使得面积最大\nSolution 首先，肯定是求凸包，要求的点一定在凸包上。 不难联想到凸包对每个边求最大三角形面积的问题，也就是旋转卡壳。 可以将问题转化为，对凸包的每一个对角线$A_iA_j$，求最大面积的两个三角形，$\\triangle{A_iA_jP}$, $\\triangle{A_iA_jQ}$, 然后就可以枚举对角线，旋转卡壳算最大面积 细节\n输出的格式 凸包上应该留下共线的点 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;stack\u0026gt; #include \u0026lt;set\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;map\u0026gt; #include \u0026lt;time.h\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; //#include \u0026lt;memory.h\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;iomanip\u0026gt; #include \u0026lt;cassert\u0026gt; // #include \u0026lt;unordered_map\u0026gt; #define P pair\u0026lt;int, int\u0026gt; #define LL long long #define LD long double #define PLL pair\u0026lt;LL, LL\u0026gt; #define mset(a, b) memset(a, b, sizeof(a)) #define rep(i, a, b) for (int i = a; i \u0026lt; b; i++) #define PI acos(-1.","title":"Gym 102460L Largest Quadrilateral "},{"content":"Codeforces Round #663 http://codeforces.com/contest/1391\nC 题意\n对于一个排列${p_1, p_2, \\dots, p_n}$，对于每个数字$p_i$，向前找第一个大于$p_i$的$p_j$，$i$和$j$连一条边，向后同理。求多少种排列生成的图是有环的\nSolution\n对于$p_i$，如果存在$p_j\u0026gt;p_i(j\u0026lt;i)$, $p_k\u0026gt;p_i(k\u0026gt;i)$，那么就是存在环的 那么对于$\\forall i$都不成立时，就没有环 此时就是序列的特点就是,数字$n$左边和右边向两边递减 因此排列数就是$n!-2^{n-1}$ #include \u0026lt;cstdio\u0026gt; #include \u0026lt;stack\u0026gt; #include \u0026lt;set\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;map\u0026gt; #include \u0026lt;time.h\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;iomanip\u0026gt; #include \u0026lt;cassert\u0026gt; #define P pair\u0026lt;int, int\u0026gt; #define LL long long #define LD long double #define PLL pair\u0026lt;LL, LL\u0026gt; #define mset(a, b) memset(a, b, sizeof(a)) #define rep(i, a, b) for (int i = a; i \u0026lt; b; i++) #define PI acos(-1.0) #define random(x) rand() % x #define debug(x) cout \u0026lt;\u0026lt; #x \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34; using namespace std; const LL inf = 0x3f3f3f3f3f3f3f3f; #ifdef DEBUG const int MAX = 2e3 + 50; #else const int MAX = 2e6 + 50; #endif const int mod = 1e9+7; void file_read(){ #ifdef DEBUG freopen(\u0026#34;in\u0026#34;, \u0026#34;r\u0026#34;, stdin); #endif } int main(){ file_read(); LL n; scanf(\u0026#34;%lld\\n\u0026#34;, \u0026amp;n); LL fact = 1; for(LL i = 1; i \u0026lt;= n; i++) { fact = fact * i % mod; } LL pow2 = 1; for(int i = 1; i \u0026lt; n; i++) { pow2 = pow2 * 2 % mod; } LL res = (fact - pow2) % mod; if(res \u0026lt; 0) res += mod; printf(\u0026#34;%lld\\n\u0026#34;, res); } D 题意\n给一个01矩阵，对于每个变成位偶数的正方形，1的个数必须时奇数个，求最小改变01的次数\nSolution\n首先，对于4*4的矩阵是无解的，因此，$n,m$必有一个小于4，不妨假设$n\u0026lt;4$, 且$n\u0026lt;m$ 然后问题就可以dp，枚举状态转移 $$ dp[i][mask_y] = min(dp[i-1][mask_x]+cost(i,mask_y), dp[i][mask_y]) $$ #include \u0026lt;cstdio\u0026gt; #include \u0026lt;stack\u0026gt; #include \u0026lt;set\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;map\u0026gt; #include \u0026lt;time.h\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; //#include \u0026lt;memory.h\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;iomanip\u0026gt; #include \u0026lt;cassert\u0026gt; // #include \u0026lt;unordered_map\u0026gt; #define P pair\u0026lt;int, int\u0026gt; #define LL long long #define LD long double #define PLL pair\u0026lt;LL, LL\u0026gt; #define mset(a, b) memset(a, b, sizeof(a)) #define rep(i, a, b) for (int i = a; i \u0026lt; b; i++) #define PI acos(-1.0) #define random(x) rand() % x #define debug(x) cout \u0026lt;\u0026lt; #x \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34; using namespace std; const int inf = 0x3f3f3f3f; const LL __64inf = 0x3f3f3f3f3f3f3f3f; #ifdef DEBUG const int MAX = 2e3 + 50; #else const int MAX = 2e6 + 50; #endif const int mod = 1e9+7; void file_read(){ #ifdef DEBUG freopen(\u0026#34;in\u0026#34;, \u0026#34;r\u0026#34;, stdin); #endif } char s[10][MAX]; int dp[MAX][10]; int n, m; int cost(int col, int mask){ int res = 0; for(int i = 1; i \u0026lt;= n; i++) { int x = s[i][col] - \u0026#39;0\u0026#39;; int y = mask \u0026amp; 1; res += x != y; mask \u0026gt;\u0026gt;= 1; } return res; } bool check(int x, int y) { int A[2][10]; for(int i = 1; i \u0026lt;= n; i++) { int a = x \u0026amp; 1; int b = y \u0026amp; 1; A[0][i] = a; A[1][i] = b; x \u0026gt;\u0026gt;= 1; y \u0026gt;\u0026gt;= 1; } int res = A[0][1] ^ A[0][2] ^ A[1][1] ^ A[1][2]; if(!res) return false; if(n == 2) return true; res = A[0][2] ^ A[0][3] ^ A[1][2] ^ A[1][3]; return res; } int main(){ file_read(); scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); if(n == 1 || m == 1) { puts(\u0026#34;0\u0026#34;); return 0; } if(n \u0026gt;= 4 and m \u0026gt;= 4) { puts(\u0026#34;-1\u0026#34;); return 0; } if(n \u0026lt;= m) { for(int i = 1; i \u0026lt;= n; i++) scanf(\u0026#34;%s\u0026#34;, s[i]+1); } else { for(int i = 1; i \u0026lt;= n; i++) { char t[10]; scanf(\u0026#34;%s\u0026#34;, t+1); for(int j = 1; j \u0026lt;= m; j++) { s[j][i] = t[j]; } } swap(n, m); } // n \u0026lt;= m; mset(dp, 0x3f); int up = n == 2 ? 4 : 8; for(int i = 0; i \u0026lt; up; i++) { for(int j = 0; j \u0026lt; up; j++) { if(check(i, j)) dp[2][j] = min(dp[2][j], cost(1, i)+cost(2, j)); } } for(int i = 3; i \u0026lt;= m; i++) { for(int x = 0; x \u0026lt; up; x++) { for(int y = 0; y \u0026lt; up; y++) { if(check(x, y)) dp[i][y] = min(dp[i][y], dp[i-1][x]+cost(i, y)); } } } int res = inf; for(int i = 0; i \u0026lt; up; i++ ) { res = min(res, dp[m][i]); } printf(\u0026#34;%d\\n\u0026#34;, res); } E 题意\n给一个无向图连通图，有$n$个点，求下面任意一个，\n长度不小于$\\lceil n \\rceil$ 一个不小于$\\lceil n \\rceil$的点集，两两组成pair，pair之间的生成图边数不大于2 Solution\n这是个构造题 考虑在图上跑dfs后得到的树 对于一个节点，除了树边，不会存在向旁边连的边，只有连向祖先的边 如果存在一个深度不小于$\\lceil n \\rceil$，答案就存在了 否则，对于每个深度两两pair，对于任意的pair的生成图都是满足要求的。对于每一层，最多只剩一个，而且最多有$\\lfloor n\\rfloor$,因此点集的大小不小于$n-\\lfloor n \\rfloor$ #include \u0026lt;cstdio\u0026gt; #include \u0026lt;stack\u0026gt; #include \u0026lt;set\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;map\u0026gt; #include \u0026lt;time.h\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; //#include \u0026lt;memory.h\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;iomanip\u0026gt; #include \u0026lt;cassert\u0026gt; // #include \u0026lt;unordered_map\u0026gt; #define P pair\u0026lt;int, int\u0026gt; #define LL long long #define LD long double #define PLL pair\u0026lt;LL, LL\u0026gt; #define mset(a, b) memset(a, b, sizeof(a)) #define rep(i, a, b) for (int i = a; i \u0026lt; b; i++) #define PI acos(-1.0) #define random(x) rand() % x #define debug(x) cout \u0026lt;\u0026lt; #x \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34; using namespace std; const int inf = 0x3f3f3f3f; const LL __64inf = 0x3f3f3f3f3f3f3f3f; #ifdef DEBUG const int MAX = 2e3 + 50; #else const int MAX = 2e6 + 50; #endif const int mod = 1e9+7; void file_read(){ #ifdef DEBUG freopen(\u0026#34;in\u0026#34;, \u0026#34;r\u0026#34;, stdin); #endif } vector\u0026lt;int\u0026gt; G[MAX]; bool vis[MAX]; int dep[MAX]; vector\u0026lt;int\u0026gt; dep_set[MAX]; int p[MAX]; int pr[MAX]; void dfs(int u, int parent, int d) { dep[u] = d; vis[u] = 1; p[u] = parent; for(auto v : G[u]) { if(vis[v]) continue; dfs(v, u, d+1); } } int main(){ file_read(); int T; scanf(\u0026#34;%d\u0026#34;, \u0026amp;T); while (T--) { int n, m; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); memset(vis, 0, sizeof(bool) * (n +50)); memset(dep, 0, sizeof(int) * (n+50)); memset(p, 0, sizeof(int) * (n+50)); for(int i = 1; i \u0026lt;= n; i++) G[i].clear(); for(int i = 1; i \u0026lt;= n; i++) dep_set[i].clear(); for(int i = 1; i \u0026lt;= m; i++) { int u, v; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;u, \u0026amp;v); G[u].push_back(v); G[v].push_back(u); } dfs(1, -1, 1); int Max = -1, id = -1; for(int i = 1; i \u0026lt;= n; i++) { if(dep[i] \u0026gt; Max) { Max = dep[i]; id = i; } } if(Max * 2 \u0026gt;= n) { puts(\u0026#34;PATH\u0026#34;); vector\u0026lt;int\u0026gt; ans; int u = id; while(u != -1) { ans.push_back(u); u = p[u]; } printf(\u0026#34;%d\\n\u0026#34;, ans.size()); for(auto x: ans) printf(\u0026#34;%d \u0026#34;, x); puts(\u0026#34;\u0026#34;); continue; } for(int i = 1; i \u0026lt;= n; i++) { dep_set[dep[i]].push_back(i); } puts(\u0026#34;PAIRING\u0026#34;); vector\u0026lt;P\u0026gt; ans; for(int k = 1; k \u0026lt;= Max; k++) { for(int i = 0; i+1 \u0026lt; dep_set[k].size(); i+=2) { ans.emplace_back(dep_set[k][i], dep_set[k][i+1]); } } printf(\u0026#34;%d\\n\u0026#34;, ans.size()); for(auto p : ans ) printf(\u0026#34;%d %d\\n\u0026#34;, p.first, p.second); } return 0; } A B A B\n","permalink":"https://Anlarry.github.io/posts/acm-icpc/codeforces-round-663/","summary":"Codeforces Round #663 http://codeforces.com/contest/1391\nC 题意\n对于一个排列${p_1, p_2, \\dots, p_n}$，对于每个数字$p_i$，向前找第一个大于$p_i$的$p_j$，$i$和$j$连一条边，向后同理。求多少种排列生成的图是有环的\nSolution\n对于$p_i$，如果存在$p_j\u0026gt;p_i(j\u0026lt;i)$, $p_k\u0026gt;p_i(k\u0026gt;i)$，那么就是存在环的 那么对于$\\forall i$都不成立时，就没有环 此时就是序列的特点就是,数字$n$左边和右边向两边递减 因此排列数就是$n!-2^{n-1}$ #include \u0026lt;cstdio\u0026gt; #include \u0026lt;stack\u0026gt; #include \u0026lt;set\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;map\u0026gt; #include \u0026lt;time.h\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;iomanip\u0026gt; #include \u0026lt;cassert\u0026gt; #define P pair\u0026lt;int, int\u0026gt; #define LL long long #define LD long double #define PLL pair\u0026lt;LL, LL\u0026gt; #define mset(a, b) memset(a, b, sizeof(a)) #define rep(i, a, b) for (int i = a; i \u0026lt; b; i++) #define PI acos(-1.","title":"Codeforces Round #663"},{"content":"Codeforces Round #660 https://codeforces.com/contest/1388\nE 题意\n平面上有一些线段，将他们投影到$x$轴上，使得彼此不想交(但是可以挨着)，设最左边的点和最右边的点的横坐标分别是$x_l, x_r$， 求$min{x_r-x_l}$\nSolution\n首先对于两个线段$s_1, s_2$, 并且$s_1.y \u0026lt; s_2.y$, 交叉连接他们的左右端点，得到一个向量集合$bound$，对投影向量限制限制。 因此先两两枚举，得到投影向量的可行的取值。\n而且最优的投影向量，是集合$bound$中的某一项\n因此，对剩下的可行的投影向量, 假设当前枚举的方向是$k_i$，计算\n$$ max{x_j+y_jKi}-min{x_j+y_jk_i} $$\n计算这个式子可以用Convex hull trick, 然后不断更新ans\n#include \u0026lt;cstdio\u0026gt; #include \u0026lt;stack\u0026gt; #include \u0026lt;set\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;map\u0026gt; #include \u0026lt;time.h\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;memory.h\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;iomanip\u0026gt; #include \u0026lt;bitset\u0026gt; #include \u0026lt;unordered_map\u0026gt; #include \u0026lt;assert.h\u0026gt; #include \u0026lt;list\u0026gt; #define P pair\u0026lt;int, int\u0026gt; #define LL long long #define LD long double #define PLL pair\u0026lt;LL, LL\u0026gt; #define mset(a, b) memset(a, b, sizeof(a)) #define rep(i, a, b) for (int i = a; i \u0026lt; b; i++) #define PI acos(-1.0) #define random(x) rand() % x #define debug(x) cout \u0026lt;\u0026lt; #x \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34; using namespace std; const int inf = 0x3f3f3f3f; const LL __64inf = 0x3f3f3f3f3f3f3f3f; #ifdef DEBUG const int MAX = 1e3 + 50; #else const int MAX = 1e6 + 50; #endif const int mod = 998244353; void file_read(){ #ifdef DEBUG freopen64(\u0026#34;in\u0026#34;, \u0026#34;r\u0026#34;, stdin); #endif } struct Seg { double xl, xr, y; Seg(double xl, double xr, double y) : xl(xl), xr(xr), y(y) {} }; vector\u0026lt;Seg\u0026gt; seg; vector\u0026lt;pair\u0026lt;double, double\u0026gt;\u0026gt; bd; void bound() { for(int i = 0; i \u0026lt; seg.size(); i++) { for(int j = i+1; j \u0026lt; seg.size(); j++) { if(seg[i].y == seg[j].y) continue; auto s1 = seg[i]; auto s2 = seg[j]; if(s1.y \u0026gt; s2.y) swap(s1, s2); double beta1 = (s1.xr - s2.xl) / (s2.y - s1.y); double beta2 = (s1.xl - s2.xr) / (s2.y - s1.y); bd.emplace_back(beta2, beta1); } } } void filter(vector\u0026lt;double\u0026gt; \u0026amp;theta) { double cur = -__64inf; for(auto x : bd) { if(x.first \u0026gt;= cur) { theta.push_back(x.first); if(cur \u0026gt; -__64inf) theta.push_back(cur); } cur = max(cur, x.second); } theta.push_back(cur); } double cross(pair\u0026lt;double, double\u0026gt; A, pair\u0026lt;double, double\u0026gt; B) { return (A.first - B.first) / (B.second - A.second); } template\u0026lt;typename Cmp_1, typename Cmp_2\u0026gt; struct Convex { int top; vector\u0026lt;pair\u0026lt;double, double\u0026gt;\u0026gt; pts; vector\u0026lt;double\u0026gt; X; pair\u0026lt;double, double\u0026gt; stk[3000]; Cmp_1 cmp_1; Cmp_2 cmp_2; Convex(vector\u0026lt;Seg\u0026gt; \u0026amp;seg) : cmp_1(Cmp_1()), cmp_2(Cmp_2()) { for(auto s : seg) { pts.emplace_back(s.xl, s.y); pts.emplace_back(s.xr, s.y); } sort(pts.begin(), pts.end(), [this](const pair\u0026lt;double, double\u0026gt; \u0026amp;A, const pair\u0026lt;double, double\u0026gt; \u0026amp;B){ if(abs(A.second - B.second) \u0026lt; 1e-8 ) return this-\u0026gt;cmp_1(A.first, B.first);//return A.first \u0026lt; B.first; // return A.second \u0026gt; B.second; return this-\u0026gt;cmp_2(A.second, B.second); }); int i = 0; top = 0; stk[top++] = pts[0]; while(i \u0026lt; pts.size() and abs(pts[i].second-pts[0].second) \u0026lt; 1e-8) i++; if(i == pts.size()) { X.push_back(-__64inf); return ; } stk[top++] = pts[i++]; while(i \u0026lt; pts.size()) { int j = i; while(j \u0026lt; pts.size() and abs(pts[j].second-pts[i].second) \u0026lt; 1e-8) j++; if(j == pts.size()) break; auto cur = pts[j]; while(top \u0026gt;= 2) { double cross_x = cross(stk[top-1], stk[top-2]); double cross_cur = cross(cur, stk[top-2]); if(cross_cur \u0026lt; cross_x) top--; else break; } stk[top++] = cur; i = j+1; } X.push_back(-__64inf); for(int i = 1; i \u0026lt; top; i++) { X.push_back(cross(stk[i-1], stk[i])); } } double query(double a) { int idx = lower_bound(X.begin(), X.end(), a)- X.begin(); idx--; return stk[idx].first + stk[idx].second * a; } }; struct Less { bool operator () (double A, double B) { return A \u0026lt; B; } }; struct Great { bool operator () (double A, double B) { return A \u0026gt; B; } }; int main(){ #ifdef DEBUG freopen64(\u0026#34;in\u0026#34;, \u0026#34;r\u0026#34;, stdin); #endif int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); set\u0026lt;double\u0026gt; Y; for(int i = 0; i \u0026lt; n; i++) { double xl, xr, y; scanf(\u0026#34;%lf%lf%lf\u0026#34;, \u0026amp;xl, \u0026amp;xr, \u0026amp;y) ; seg.emplace_back(xl, xr, y); Y.insert(y); } if(Y.size() == 1) { double Min = __64inf, Max = -__64inf; for(auto s : seg) { Min = min(s.xl, Min); Max = max(Max, s.xr); } printf(\u0026#34;%.10f\\n\u0026#34;, Max-Min); return 0; } bound(); vector\u0026lt;double\u0026gt; theta; sort(bd.begin(), bd.end()); filter(theta); #ifdef DEBUG for(auto t : theta) printf(\u0026#34;%.2f \u0026#34;, t); puts(\u0026#34;\u0026#34;); #endif double ans = __64inf; Convex\u0026lt;Less, Great\u0026gt; left(seg); Convex\u0026lt;Great, Less\u0026gt; right(seg); for(auto x : theta) { double l = left.query(x); double r = right.query(x); ans = min(ans, r-l); } printf(\u0026#34;%.10f\\n\u0026#34;, ans); } A B C D A B C D\n","permalink":"https://Anlarry.github.io/posts/acm-icpc/codeforces-round-660/","summary":"Codeforces Round #660 https://codeforces.com/contest/1388\nE 题意\n平面上有一些线段，将他们投影到$x$轴上，使得彼此不想交(但是可以挨着)，设最左边的点和最右边的点的横坐标分别是$x_l, x_r$， 求$min{x_r-x_l}$\nSolution\n首先对于两个线段$s_1, s_2$, 并且$s_1.y \u0026lt; s_2.y$, 交叉连接他们的左右端点，得到一个向量集合$bound$，对投影向量限制限制。 因此先两两枚举，得到投影向量的可行的取值。\n而且最优的投影向量，是集合$bound$中的某一项\n因此，对剩下的可行的投影向量, 假设当前枚举的方向是$k_i$，计算\n$$ max{x_j+y_jKi}-min{x_j+y_jk_i} $$\n计算这个式子可以用Convex hull trick, 然后不断更新ans\n#include \u0026lt;cstdio\u0026gt; #include \u0026lt;stack\u0026gt; #include \u0026lt;set\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;map\u0026gt; #include \u0026lt;time.h\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;memory.h\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;iomanip\u0026gt; #include \u0026lt;bitset\u0026gt; #include \u0026lt;unordered_map\u0026gt; #include \u0026lt;assert.h\u0026gt; #include \u0026lt;list\u0026gt; #define P pair\u0026lt;int, int\u0026gt; #define LL long long #define LD long double #define PLL pair\u0026lt;LL, LL\u0026gt; #define mset(a, b) memset(a, b, sizeof(a)) #define rep(i, a, b) for (int i = a; i \u0026lt; b; i++) #define PI acos(-1.","title":"Codeforces Round #660"},{"content":"nowcoder 2020 多校 第三场 E Two Matchings 题意\n可以简化题意为，每个点有个权重$w$，两个点$i,j$相连的代价$abs(w_i-w_j)$,找两个没有重叠的匹配使得代价最小\nSolution\n其实就是在将数字用长度为偶数的环连起来，求最小代价。进一步可以发现，环用长度为4或6，长度更长的环可以被分解达到更小的代价\nLL n; LL a[MAX]; LL dp[MAX][2]; LL four(const vector\u0026lt;LL\u0026gt; \u0026amp;a){ return 2LL * (a[3]-a[0]); } LL six(const vector\u0026lt;LL\u0026gt; \u0026amp;a){ return 2LL * (a[5]-a[0]); } int main(){ #ifdef DEBUG freopen(\u0026#34;in\u0026#34;, \u0026#34;r\u0026#34;, stdin); #endif int T; scanf(\u0026#34;%d\u0026#34;, \u0026amp;T); while (T--) { cin \u0026gt;\u0026gt; n; for(int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; a[i]; sort(a, a+n); for(LL i = 0; i \u0026lt;= n; i++ ) dp[i][0] = dp[i][1] = __64inf; dp[3][0] = 2LL * (a[3]-a[0]); dp[5][0] = 2LL * (a[5]-a[0]); dp[7][0] = 2LL * (a[7]-a[4] + a[3] - a[0]); for(LL i = 9; i \u0026lt; n; i+=2){ dp[i][0] = min(dp[i-4][0], dp[i-4][1]) + four(vector\u0026lt;LL\u0026gt;({a[i-3], a[i-2], a[i-1], a[i]})); dp[i][1] = min(dp[i-6][0], dp[i-6][1]) + six(vector\u0026lt;LL\u0026gt;({a[i-5], a[i-4], a[i-3], a[i-2], a[i-1], a[i]})); } printf(\u0026#34;%d\\n\u0026#34;, min(dp[n-1][0], dp[n-1][1])); } } F Fraction Construction Problem 题意\n问有没有满足$\\displaystyle\\frac{c}{d}-\\frac{e}{f}=\\frac{a}{b}$的$c,d,e,f$\nSolution\n感觉是分类讨论，然后构造解\nvoid ex_gcd(LL a, LL b, LL \u0026amp;x, LL \u0026amp;y){ if(b == 0){ x = 1; y = 0; return; } ex_gcd(b, a % b, x, y); LL tmp = x; x = y; y = tmp - (a / b) * y; } LL p[MAX]; LL cnt[MAX]; vector\u0026lt;LL\u0026gt; prime; bool isprime[MAX]; void init(){ mset(isprime, 1); isprime[0] = isprime[1] = 0; for(int i = 2; i \u0026lt; MAX; i++){ if(isprime[i]) { prime.push_back(i); cnt[i] = 1; p[i] = i; } for(int j = 0; j \u0026lt; prime.size() and i * prime[j] \u0026lt; MAX; j++){ isprime[i * prime[j]] = 0; cnt[i * prime[j]] = i % prime[j] == 0 ? cnt[i] : cnt[i] + 1; p[i * prime[j]] = prime[j]; } } } int main(){ #ifdef DEBUG #else ios::sync_with_stdio(0); cin.tie(0); #endif init(); int T; cin \u0026gt;\u0026gt; T; while (T--) { LL a, b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; LL g = __gcd(a, b); if(g \u0026gt; 1){ LL bb = b / g, aa = a / g; cout \u0026lt;\u0026lt; aa + 1 \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; bb \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; 1 \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; bb \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; continue; } LL tmp = b; if(cnt[b] \u0026lt;= 1) { cout \u0026lt;\u0026lt; \u0026#34;-1 -1 -1 -1\\n\u0026#34;; continue; } LL d = 1; tmp = b; while(tmp % p[b] == 0) { tmp /= p[b]; d *= p[b]; } LL f = b / d; LL c, e; ex_gcd(f, d, c, e); if(c \u0026lt; 0) { LL t = - (c -d + 1) / d; c += t * d; e -= t * f; } e = -e; e *= a; c *= a; cout \u0026lt;\u0026lt; c \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; d \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; e \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; f \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } } G Operating on a Graph 题意\n给一个图，一开始每个点$i$,属于$i$类，每次操作会吧某个类$x$的相邻的类归为$x$,求最后每个点属于那个类\nSolution\n并查集模拟\nlist\u0026lt;int\u0026gt; lk[MAX]; vector\u0026lt;int\u0026gt; G[MAX]; int fa[MAX]; int Find(int x) { return fa[x] == x ? x : fa[x] = Find(fa[x]); } int main(){ #ifdef DEBUG freopen64(\u0026#34;in\u0026#34;, \u0026#34;r\u0026#34;, stdin); #endif int T; scanf(\u0026#34;%d\u0026#34;, \u0026amp;T); while (T--) { int n, m; scanf(\u0026#34;%d%d\u0026#34;,\u0026amp;n, \u0026amp;m); for(int i = 1; i \u0026lt;= n; i++){ G[i].clear(); fa[i] = i; lk[i].clear(); lk[i].push_back(i); } for(int i = 0; i \u0026lt; m; i++) { int u, v; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;u, \u0026amp;v); u++, v++; G[u].push_back(v); G[v].push_back(u); } int q; scanf(\u0026#34;%d\u0026#34;,\u0026amp;q); while (q--) { int o; scanf(\u0026#34;%d\u0026#34;, \u0026amp;o); o++; int siz = lk[o].size(); if(Find(o) != o) continue; for(int i = 0; i \u0026lt; siz; i++) { int cur = lk[o].front(); lk[o].pop_front(); for(int j = 0; j \u0026lt; G[cur].size(); j++) { int v = G[cur][j]; int pv = Find(v); if(pv != o) { fa[pv] = o; lk[o].splice(lk[o].end(), lk[pv]); } } } } for(int i = 1; i \u0026lt;= n; i++) printf(\u0026#34;%d \u0026#34;, Find(i)-1); puts(\u0026#34;\u0026#34;); } return 0; } ","permalink":"https://Anlarry.github.io/posts/acm-icpc/nowcoder-2020-%E5%A4%9A%E6%A0%A1-%E7%AC%AC%E4%B8%89%E5%9C%BA/","summary":"nowcoder 2020 多校 第三场 E Two Matchings 题意\n可以简化题意为，每个点有个权重$w$，两个点$i,j$相连的代价$abs(w_i-w_j)$,找两个没有重叠的匹配使得代价最小\nSolution\n其实就是在将数字用长度为偶数的环连起来，求最小代价。进一步可以发现，环用长度为4或6，长度更长的环可以被分解达到更小的代价\nLL n; LL a[MAX]; LL dp[MAX][2]; LL four(const vector\u0026lt;LL\u0026gt; \u0026amp;a){ return 2LL * (a[3]-a[0]); } LL six(const vector\u0026lt;LL\u0026gt; \u0026amp;a){ return 2LL * (a[5]-a[0]); } int main(){ #ifdef DEBUG freopen(\u0026#34;in\u0026#34;, \u0026#34;r\u0026#34;, stdin); #endif int T; scanf(\u0026#34;%d\u0026#34;, \u0026amp;T); while (T--) { cin \u0026gt;\u0026gt; n; for(int i = 0; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; a[i]; sort(a, a+n); for(LL i = 0; i \u0026lt;= n; i++ ) dp[i][0] = dp[i][1] = __64inf; dp[3][0] = 2LL * (a[3]-a[0]); dp[5][0] = 2LL * (a[5]-a[0]); dp[7][0] = 2LL * (a[7]-a[4] + a[3] - a[0]); for(LL i = 9; i \u0026lt; n; i+=2){ dp[i][0] = min(dp[i-4][0], dp[i-4][1]) + four(vector\u0026lt;LL\u0026gt;({a[i-3], a[i-2], a[i-1], a[i]})); dp[i][1] = min(dp[i-6][0], dp[i-6][1]) + six(vector\u0026lt;LL\u0026gt;({a[i-5], a[i-4], a[i-3], a[i-2], a[i-1], a[i]})); } printf(\u0026#34;%d\\n\u0026#34;, min(dp[n-1][0], dp[n-1][1])); } } F Fraction Construction Problem 题意","title":"nowcoder 2020 多校 第三场"},{"content":"nowcoder 2020 多校 第五场 https://ac.nowcoder.com/acm/contest/5670\nB Graph tire树，最小生成树\n题意：\n给一个带有边权的树，可以删除或添加边，但要保证：\n图联通 环上边权异或为0 Solution\n不管怎么操作，两点路径上边权的异或值是固定的，于是问题就转化成一个最小生成树问题。每次选出不联通的点集$S_1$, $S_2$, 将他们联通的代价是\n$$ \\min\\limits_{u\\in S_1 v\\in S_2} {\\mathord{dis}(u,v)} $$\n可以通过tire树实现这个过程，就是tire树合并子节点，复杂度为$O(n\\log n)$\n#include \u0026lt;cstdio\u0026gt; #include \u0026lt;stack\u0026gt; #include \u0026lt;set\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;map\u0026gt; #include \u0026lt;time.h\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;memory.h\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;iomanip\u0026gt; #include \u0026lt;bitset\u0026gt; #include \u0026lt;unordered_map\u0026gt; #include \u0026lt;assert.h\u0026gt; #define P pair\u0026lt;int, int\u0026gt; #define LL long long #define LD long double #define PLL pair\u0026lt;LL, LL\u0026gt; #define mset(a, b) memset(a, b, sizeof(a)) #define rep(i, a, b) for (int i = a; i \u0026lt; b; i++) #define PI acos(-1.0) #define random(x) rand() % x #define debug(x) cout \u0026lt;\u0026lt; #x \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34; using namespace std; const int inf = 0x3f3f3f3f; const LL __64inf = 0x3f3f3f3f3f3f3f3f; #ifdef DEBUG const int MAX = 1e3 + 50; #else const int MAX = 3e6 + 50; #endif const int mod = 10007; LL pow2[100]; vector\u0026lt;P\u0026gt; G[MAX]; int dis[MAX]; struct Tire{ int nex[MAX][2]; int siz[MAX]; int tot ; LL ans; void init(){ ans = 0; siz[0] = 0; mset(nex[0], 0); tot = 1; } void add(int x, int d) { int rt = 0; for(int i = d; i \u0026gt;= 0; i--){ int e = x \u0026amp; pow2[i] ? 1 : 0; if(!nex[rt][e]) { mset(nex[tot], 0); siz[tot] = 0; nex[rt][e] = tot ++; } rt = nex[rt][e]; siz[rt] ++; } } LL query(int val, int u, int d) { int rt = u; LL res = val; for(int i = d; i \u0026gt;= 0; i--){ if(res \u0026amp; pow2[i]) { if(nex[rt][1]) { res ^= pow2[i]; rt = nex[rt][1]; } else rt = nex[rt][0]; } else { if(nex[rt][0]) { rt = nex[rt][0]; } else { res ^= pow2[i]; rt = nex[rt][1]; } } } return res; } LL merge(int l, int r, int val, int d, int row_d){ if(!nex[l][0] and !nex[l][1]) { return query(val, r, row_d); } LL res = inf; if(nex[l][0]) res = min(res, merge(nex[l][0], r, val, d-1, row_d)); if(nex[l][1]) res = min(res, merge(nex[l][1], r, val^pow2[d], d-1, row_d)); return res; } void dfs(int u, int val, int d) { if(nex[u][0]) dfs(nex[u][0], val, d-1); if(nex[u][1]) dfs(nex[u][1], val ^ pow2[d], d-1); if(!nex[u][0] or !nex[u][1]) return; int l = nex[u][0], r = nex[u][1]; if(siz[l] \u0026gt; siz[r]) swap(l, r); ans += 1LL * merge(l, r, 0, d-1, d-1) + pow2[d]; } }tire; void dfs(int u, int p, int d){ dis[u] = d; for(int i = 0; i \u0026lt; G[u].size(); i++){ int v = G[u][i].first; if(v == p) continue; dfs(v, u, d^G[u][i].second); } } int main(){ #ifdef DEBUG freopen64(\u0026#34;in\u0026#34;, \u0026#34;r\u0026#34;, stdin); #endif pow2[0] = 1; for(int i = 1; i \u0026lt; 32; i++) pow2[i] = pow2[i-1] \u0026lt;\u0026lt; 1; int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for(int i = 1; i \u0026lt; n; i++) { int u, v, c; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;u, \u0026amp;v, \u0026amp;c); u++, v++; G[u].emplace_back(v, c); G[v].emplace_back(u, c); } dfs(1, -1, 0); tire.init(); for(int i = 1; i \u0026lt;= n; i++) tire.add(dis[i], 29); tire.dfs(0, 0, 29); printf(\u0026#34;%lld\\n\u0026#34;, tire.ans); return 0; } D Drop Voicing 最长上升子序列\n题意\n给一个序列$p_1\\dots p_n$，可以进行两种操作，进行连续的第一个操作耗费一个代价\n把$p_{n-1}$放到最前面 $p_1$放到最后面 求把序列变成升序的最小代价\nSolution\n结合两种操作其实就是把一个元素$p_i$移到一个位置，需要一个代价。于是变成求LIS\nint n; int a[MAX]; int b[MAX]; int solve(){ mset(b, 0); int ans = 0; for(int i = 1; i \u0026lt;= n; i++) { int idx = lower_bound(b, b+ans, a[i]) - b; b[idx] = a[i]; if(idx == ans) ans ++; } // cout \u0026lt;\u0026lt; n - ans \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; return ans; } int main(){ #ifdef DEBUG freopen64(\u0026#34;in\u0026#34;, \u0026#34;r\u0026#34;, stdin); #else ios::sync_with_stdio(0); cin.tie(0); #endif cin \u0026gt;\u0026gt; n; for(int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; a[i]; int ans = 0; for(int i = 0; i \u0026lt; n; i++) { rotate(a+1, a+2, a+n+1); ans = max(ans, solve()); } cout \u0026lt;\u0026lt; n - ans \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; return 0; } E Bogo Sort 题意\n给一个置换，求有多少种排列可以通过这个置换变成升序\nfrom math import gcd def lcm(a:int, b:int) -\u0026gt;int: return a * b // gcd(a, b) n = int(input()) a = [0] + list(map(int, input().split())) vis = [False for i in range(len(a))] ans = 1 for i in range(1, n+1): x = a[i] if vis[x] : continue cur = 0 while not vis[x] : vis[x] = True cur += 1 x = a[x] ans = lcm(ans, cur) print(ans) ","permalink":"https://Anlarry.github.io/posts/acm-icpc/nowcoder-2020-%E5%A4%9A%E6%A0%A1-%E7%AC%AC%E4%BA%94%E5%9C%BA/","summary":"nowcoder 2020 多校 第五场 https://ac.nowcoder.com/acm/contest/5670\nB Graph tire树，最小生成树\n题意：\n给一个带有边权的树，可以删除或添加边，但要保证：\n图联通 环上边权异或为0 Solution\n不管怎么操作，两点路径上边权的异或值是固定的，于是问题就转化成一个最小生成树问题。每次选出不联通的点集$S_1$, $S_2$, 将他们联通的代价是\n$$ \\min\\limits_{u\\in S_1 v\\in S_2} {\\mathord{dis}(u,v)} $$\n可以通过tire树实现这个过程，就是tire树合并子节点，复杂度为$O(n\\log n)$\n#include \u0026lt;cstdio\u0026gt; #include \u0026lt;stack\u0026gt; #include \u0026lt;set\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;map\u0026gt; #include \u0026lt;time.h\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;memory.h\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;iomanip\u0026gt; #include \u0026lt;bitset\u0026gt; #include \u0026lt;unordered_map\u0026gt; #include \u0026lt;assert.h\u0026gt; #define P pair\u0026lt;int, int\u0026gt; #define LL long long #define LD long double #define PLL pair\u0026lt;LL, LL\u0026gt; #define mset(a, b) memset(a, b, sizeof(a)) #define rep(i, a, b) for (int i = a; i \u0026lt; b; i++) #define PI acos(-1.","title":"nowcoder 2020 多校 第五场"},{"content":"POJ 3376 tire + manacher\n题意 http://poj.org/problem?id=3376 给$n$个串，两两连接，一共$n^2$种，求其中有多少是回文， 字符串的长度和小于$2e6$\nSolution 在考虑第$i$个串$t$和多少个串$s$拼接是回文时，计算$s+t$是回文的数量，将所有数量累加就是最终的回文数。\n首先考虑什么情况下，两个串拼接会是一个回文串。\ncase 1： s=reverse(t)\n$$ \\begin{cases} s = a_0\\dots a_{n-1} \\newline t = a_{n-1}\\dots a_0 \\end{cases} $$\ncase 2\n$$ \\begin{cases} \\begin{matrix} \u0026amp;\\mathrm{palindrome} \\newline s = a_0\\dots a_i \u0026amp;\\overbrace{a_{i+1}\\dots a_{n-1}} \\end{matrix} \\newline \\newline t = a_i\\dots a_0 \\end{cases} $$ 以及对称的情况 $$ \\begin{cases} s = a_{n-1}\\dots a_i \\newline \\begin{matrix} \\ \\ \\ \\ \\ \\mathrm{palindrome} \u0026amp;\\newline t = \\overbrace{a_0\\dots a_{i-1}} \u0026amp;a_i\\dots a_{n-1} \\end{matrix} \\end{cases} $$\n因此可以对每个串，求出前缀和后缀是否是回文。把所有的串放到tire树上，统计答案。\n用stl可能会TLE\n#include \u0026lt;cstdio\u0026gt; #include \u0026lt;stack\u0026gt; #include \u0026lt;set\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;map\u0026gt; #include \u0026lt;time.h\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; //#include \u0026lt;memory.h\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;iomanip\u0026gt; #include \u0026lt;cassert\u0026gt; // #include \u0026lt;unordered_map\u0026gt; #define P pair\u0026lt;int, int\u0026gt; #define LL long long #define LD long double #define PLL pair\u0026lt;LL, LL\u0026gt; #define mset(a, b) memset(a, b, sizeof(a)) #define rep(i, a, b) for (int i = a; i \u0026lt; b; i++) #define PI acos(-1.0) #define random(x) rand() % x #define debug(x) cout \u0026lt;\u0026lt; #x \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34; using namespace std; const int inf = 0x3f3f3f3f; const LL __64inf = 0x3f3f3f3f3f3f3f3f; #ifdef DEBUG const int MAX = 2e6 + 50; #else const int MAX = 2e6 + 50; #endif const int mod = 998244353; int str_len[MAX]; char str[MAX\u0026lt;\u0026lt;1]; char* str_p[MAX]; int sufix_palin[MAX]; int prefix_parlin[MAX]; int *sufix_palin_p[MAX]; int *prefix_parlin_p[MAX]; int radius[MAX]; int n; int zero; int palin; struct Tire { int tot; int nex[MAX][26]; int siz[MAX]; int _siz[MAX]; int rest_palin[MAX]; void init(){ tot = 1; mset(nex[0], 0); siz[0] = 0; _siz[0] = 0; rest_palin[0] = 0; } void add(const int idx, char *s){ int last = 0; int rt = 0; for(int i = 0; i \u0026lt; str_len[idx]; i++){ int c = s[i] - \u0026#39;a\u0026#39;; if(!nex[rt][c] ){ mset(nex[tot], 0); siz[tot] = 0; _siz[tot] = 0; rest_palin[tot] = 0; nex[rt][c] = tot ++; } last = rt; rt = nex[rt][c]; if(i + 2 == str_len[idx]) _siz[rt]++; if(sufix_palin_p[idx][i]){ rest_palin[last]++; } } siz[rt]++; } int* operator [] (int idx){ return nex[idx]; } }tire; string manacherStr(int len, char *s){ string res = \u0026#34;#\u0026#34;; for(int i = 0; i \u0026lt; len; i++){ res += s[i]; res += \u0026#39;#\u0026#39;; } return res; } void solve(const int idx, char *s){ if(str_len[idx] == 0) return ; int R = -1; int C = -1; int Max = -1; string str = manacherStr(str_len[idx], s); for(int i = 0; i \u0026lt; str.size(); i++){ radius[i] = R \u0026gt; i ? min(radius[2*C-i], R-i+1) : 1; while(i + radius[i] \u0026lt; str.size() and i - radius[i] \u0026gt; -1) { if(str[i-radius[i]] == str[i+radius[i]]) radius[i]++; else break; } if(i + radius[i] \u0026gt; R) { R = i + radius[i]-1; C = i; } Max = max(Max, radius[i]); } if(Max - 1 == str_len[idx]) palin++; for(int i = 1; i+1 \u0026lt; str.size(); i++){ if(str[i] == \u0026#39;#\u0026#39;) { int len = radius[i]-1; int r = len / 2; int start_idx = (i-2) / 2 - r + 1; if(start_idx + len - 1 == str_len[idx]-1) sufix_palin_p[idx][start_idx] = 1; if(start_idx == 0) prefix_parlin_p[idx][start_idx+len-1] = 1; } else { int len = radius[i]-1; int r = len / 2; int start_idx = (i-1)/2 - r; if(start_idx + len - 1 == str_len[idx]-1) sufix_palin_p[idx][start_idx] = 1; if(start_idx == 0) prefix_parlin_p[idx][start_idx+len-1] = 1; } } } LL calcu(const int idx, char* s){ int rt = 0; LL res = 0; for(int i = str_len[idx]-1; i \u0026gt;= 0; i--){ int c = s[i] - \u0026#39;a\u0026#39;; rt = tire[rt][c] ; if(!rt) break; if(i == 0){ res += (LL)tire.siz[rt]; res += (LL)tire.rest_palin[rt]; } else if(i \u0026gt;= 1 and prefix_parlin_p[idx][i-1]){ res += (LL)tire.siz[rt]; } } return res; } int main(){ #ifdef DEBUG freopen(\u0026#34;in\u0026#34;, \u0026#34;r\u0026#34;, stdin); #endif tire.init(); scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); int cur = 0; for(int i = 0; i \u0026lt; n; i++) { int x; scanf(\u0026#34;%d%s\u0026#34;, \u0026amp;x, \u0026amp;str[cur]); zero += x == 0; str_p[i] = str+cur; str_len[i] = x; prefix_parlin_p[i] = prefix_parlin+cur; sufix_palin_p[i] = sufix_palin +cur; cur += x; } for(int i = 0; i \u0026lt; n; i++){ solve(i, str_p[i]); } for(int i = 0; i \u0026lt; n; i++) tire.add(i, str_p[i]); LL ans = 0; tire.rest_palin[0] = tire.siz[0] = 0; for(int i = 0; i \u0026lt; n; i++){ #ifdef DEBUG printf(\u0026#34;debug i:%d calcu:%d\\n\u0026#34;, i, calcu(i, str_p[i])); #endif ans += 1LL * calcu(i, str_p[i]); } ans += 1LL * zero * zero; ans += 1LL * zero * palin * 2; #ifdef DEBUG for(int i = 0; i \u0026lt; n; i++){ for(int j = 0; j \u0026lt; str_len[i]; j++) cout \u0026lt;\u0026lt; prefix_parlin_p[i][j] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; puts(\u0026#34;\u0026#34;); for(int j = 0; j \u0026lt; str_len[i]; j++) cout \u0026lt;\u0026lt; sufix_palin_p[i][j] \u0026lt;\u0026lt; \u0026#34; \u0026#34; ; puts(\u0026#34;\\n\u0026#34;); } #endif printf(\u0026#34;%lld\\n\u0026#34;, ans); return 0; } ","permalink":"https://Anlarry.github.io/posts/acm-icpc/poj-3376/","summary":"POJ 3376 tire + manacher\n题意 http://poj.org/problem?id=3376 给$n$个串，两两连接，一共$n^2$种，求其中有多少是回文， 字符串的长度和小于$2e6$\nSolution 在考虑第$i$个串$t$和多少个串$s$拼接是回文时，计算$s+t$是回文的数量，将所有数量累加就是最终的回文数。\n首先考虑什么情况下，两个串拼接会是一个回文串。\ncase 1： s=reverse(t)\n$$ \\begin{cases} s = a_0\\dots a_{n-1} \\newline t = a_{n-1}\\dots a_0 \\end{cases} $$\ncase 2\n$$ \\begin{cases} \\begin{matrix} \u0026amp;\\mathrm{palindrome} \\newline s = a_0\\dots a_i \u0026amp;\\overbrace{a_{i+1}\\dots a_{n-1}} \\end{matrix} \\newline \\newline t = a_i\\dots a_0 \\end{cases} $$ 以及对称的情况 $$ \\begin{cases} s = a_{n-1}\\dots a_i \\newline \\begin{matrix} \\ \\ \\ \\ \\ \\mathrm{palindrome} \u0026amp;\\newline t = \\overbrace{a_0\\dots a_{i-1}} \u0026amp;a_i\\dots a_{n-1} \\end{matrix} \\end{cases} $$","title":"POJ 3376"},{"content":"nowcoder 2020 多校 第二场 https://ac.nowcoder.com/acm/contest/5667\nA All with Pairs 题意\n给$n$个串，定义$f(s,t)$为$s$前缀和$t$后缀最长的长度，求$\\sum_i\\sum_j f(s_i, s_j)^2$\nSolution\n先把每个串的后缀hash的值存下来，对每个串$s_i$,求$\\sum_j f(s_i, s_j)^2$。对于$s_i$的每个前缀都可以查询hash求出 对应多少后缀，但是有可能一对$s_i, s_j$会有多个贡献，因此要用next数组去重\nconst unsigned long long base = 131; // vector\u0026lt;string\u0026gt; str; string str[MAX]; unordered_map\u0026lt;unsigned long long, int\u0026gt; mp; int nex[MAX]; int cnt[MAX]; void get_hash(const string \u0026amp;s){ unsigned long long res = 0; unsigned long long p = 1; for(int i = s.size()-1; i \u0026gt;= 0; i--){ // unsigned long long x = s[i] - \u0026#39;a\u0026#39;+1; res += (s[i]-\u0026#39;a\u0026#39;+1) * p; p *= base; mp[res]++; } } void get_next(const string \u0026amp;t){ nex[0] = -1; int k = -1; for(int i = 1; i \u0026lt; t.size(); i++){ while(k \u0026gt; -1 and t[k+1] != t[i]) k = nex[k]; if(t[k+1] == t[i]) k++; nex[i] = k; } } int main(){ #ifdef DEBUG freopen(\u0026#34;in\u0026#34;, \u0026#34;r\u0026#34;, stdin); #endif int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); // cin \u0026gt;\u0026gt; n; for(int i = 0; i \u0026lt; n; i++){ // string s; cin \u0026gt;\u0026gt; str[i]; // str.push_back(s); get_hash(str[i]); } LL ans = 0; for(int i = 0; i \u0026lt; n; i++){ unsigned long long cur_has = 0 ; for(int j = 0; j \u0026lt; str[i].size(); j++){ cur_has = cur_has * base + (str[i][j] - \u0026#39;a\u0026#39; + 1); // cnt[j] = mp[cur_has]; auto it = mp.find(cur_has); if(it != mp.end()) cnt[j] = it-\u0026gt;second; else cnt[j] = 0; } get_next(str[i]); for(int j = 1; j \u0026lt; str[i].size(); j++){ if(nex[j] \u0026gt;= 0) cnt[nex[j]] -= cnt[j]; } for(LL j = 0; j \u0026lt; str[i].size(); j++){ ans = (ans + 1LL * cnt[j] * (j+1LL) % mod * (j+1LL) % mod) % mod; } } printf(\u0026#34;%lld\\n\u0026#34;, ans); // cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } B Boundary 题意\n圆是过原点的，选一个能经过最多点的圆\nP pts[5000]; // map\u0026lt;tuple\u0026lt;LL, LL, LL, LL\u0026gt;, int\u0026gt; cnt; vector\u0026lt;pair\u0026lt;double, double\u0026gt;\u0026gt; p; void update(LL x1, LL y1, LL x2, LL y2){ LL cir_x1 = (x1*x1 + y1*y1) * y2 - (x2*x2 + y2*y2) * y1; LL cir_x2 = 2 * (x1 * y2 - x2 * y1); LL cir_y1 = (x2*x2 + y2*y2) * x1 - (x1*x1 + y1*y1) * x2; LL cir_y2 = 2 * (x1 * y2 - x2 * y1); if(cir_x2 == 0) return ; p.push_back(make_pair(1.0 * cir_x1 / cir_x2, 1.0 * cir_y1 / cir_y2)); } int main(){ #ifdef DEBUG freopen(\u0026#34;in\u0026#34;, \u0026#34;r\u0026#34;, stdin); #endif int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for(int i = 1; i \u0026lt;= n; i++){ scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;pts[i].first, \u0026amp;pts[i].second); } if(n \u0026lt;= 2) { printf(\u0026#34;%d\\n\u0026#34;, n); return 0; } for(int i = 1; i \u0026lt;= n; i++){ for(int j = 1; j \u0026lt; i; j++){ update(pts[i].first, pts[i].second, pts[j].first, pts[j].second); } } sort(p.begin(), p.end()); if(p.size() == 0){ printf(\u0026#34;%d\\n\u0026#34;, 1); return 0; } pair\u0026lt;double, double\u0026gt; cur = p[0]; int ans = 0, tmp = 0; for(int i = 0; i \u0026lt; p.size(); i++){ if(p[i] == cur) {tmp++; ans = max(ans, tmp);} else { cur = p[i]; tmp = 1; ans = max(ans, tmp); } } ans *= 2; int res ; for(int i = 1; i \u0026lt;= n; i++){ int cur = i; if(cur * (cur-1) == ans) { res = cur; break; } } printf(\u0026#34;%d\\n\u0026#34;, res); } F Fake Maxpooling 题意\n给一个矩阵，$A_{i,j}=lcm(i,j)$，在每个$k\\times k$子矩阵中选出最大的元素求和\nSolution\n维护横竖的单调队列，或者暴力\nint k; struct stk { P stack[5050]; int lenth; int start_idx; int front; stk() : lenth(0), start_idx(0), front(0) {} void push(int x, int idx){ while(!empty() and top() \u0026lt; x) { pop(); } stack[lenth++] = {x, idx}; start_idx = idx; } int max(){ while(!empty() and stack[front].second \u0026lt; start_idx - k + 1) front ++; return stack[front].first; } int top(){ return stack[lenth-1].first; } void pop(){ lenth--; } bool empty(){ return lenth == front; } void clear(){ lenth = 0; front = 0; start_idx = 0; } }; inline int A(int x, int y){ return x * y / __gcd(x, y); } stk col_stk[5050]; stk row_stk; int main(){ #ifdef DEBUG freopen64(\u0026#34;in\u0026#34;, \u0026#34;r\u0026#34;, stdin); #endif int n, m; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;n, \u0026amp;m, \u0026amp;k); for(int i = 1; i \u0026lt;= m; i++){ for(int j = 1; j \u0026lt; k; j++){ col_stk[i].push(A(i, j), j); } } LL ans = 0; for(int i = 1; i \u0026lt;= n-k+1; i++){ for(int j = 1; j \u0026lt;= m; j++){ col_stk[j].push(A(i+k-1,j), i+k-1); } for(int j = 1; j \u0026lt; k; j++){ row_stk.push(col_stk[j].max(), j); } for(int j = k; j \u0026lt;= m; j++){ row_stk.push(col_stk[j].max(), j); ans += (LL) row_stk.max(); } row_stk.clear(); } printf(\u0026#34;%lld\\n\u0026#34;, ans); return 0; } G Greater and Greater 题意\n给一个长度为$n$的序列A, 和一个长度位$m$的序列B，求A有多少位置对应元素都大于B\nSolution\n考虑bitset，$f(i, j)$表示序列A位置$i$,序列B位置$j$，后面的元素A对应大于B，要求的就是$\\sum f(i, 1)$\nA : 1 4 2 8 5 7 B : 2 3 3 比如$f(3, 1)$可以通过$f(4, 2)$转移过来，$f(3, 2)$可以用$f(4, 3)$转移过来，$f(3, 3)$直接比较A[3],B[3]，可以发现这些转移都要比较A[3],B[i]\n所以对每个A[i]求一个新的bitset\\ S，A[i]大于B[j]第$j$位就为1\n转移就是 $f_i=(f_{i+1}\u0026raquo;1 | I_m) \u0026amp; S_i$\nint a[MAX], b[MAX]; P A[MAX], B[MAX]; vector\u0026lt;bitset\u0026lt;N\u0026gt;\u0026gt; bits; int idx[MAX]; int main(){ #ifdef DEBUG freopen64(\u0026#34;in\u0026#34;, \u0026#34;r\u0026#34;, stdin); #endif int n, m; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); for(int i = 1; i \u0026lt;= n; i++) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i]); A[i] = make_pair(a[i], i); } for(int i = 1; i \u0026lt;= m; i++){ scanf(\u0026#34;%d\u0026#34;, \u0026amp;b[i]); B[i] = make_pair(b[i], i); } sort(A+1, A+1+n); sort(B+1, B+1+m); int i = 1, j = 0; bitset\u0026lt;N\u0026gt; cur; bits.push_back(cur); while(i \u0026lt;= n){ bool new_bit = 0; while(j \u0026lt; m \u0026amp;\u0026amp; A[i].first \u0026gt;= B[j+1].first){ new_bit = 1; cur[B[j+1].second] = 1; j++; } if(new_bit) { bits.push_back(cur); } idx[A[i].second] = bits.size()-1; i++; } bitset\u0026lt;N\u0026gt; f; int ans = 0; for(int i = n; i \u0026gt;= 1; i--){ f \u0026gt;\u0026gt;= 1; f[m] = 1; f \u0026amp;= bits[idx[i]]; ans += f[1]; } printf(\u0026#34;%d\\n\u0026#34;, ans); } J Just Shuffle 题意\n要求一个置换$P$，使得${1,2,\\dots,n}$在$P$置换$k$次后成为排列$A$\nk是素数\nSolution\n就是说$A=P^k$,已知$A,k$，求$P$。把$A$分解成$(cir_1)(cir_2)\\dots$，对每个循环$cir$,我们知道$P^k(cir_i)=cir_{i+1}$。\n我们想让$cir_i$置换$sk$次，让$sk\\ mod\\ len(cir)=1$，就可以求出$P(cir_i)$\nint a[MAX]; int ans[MAX]; bool vis[MAX]; void extend_Euclid(int a, int b, int \u0026amp;x, int \u0026amp;y) { if(b == 0){ x = 1; y = 0; return; } extend_Euclid(b, a % b, x, y); int tmp = x; x = y; y = tmp - (a / b) * y; } int main(){ #ifdef DEBUG freopen(\u0026#34;in\u0026#34;, \u0026#34;r\u0026#34;,stdin); #endif int n, k; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;k); for(int i = 1; i \u0026lt;= n; i++){ scanf(\u0026#34;%d\u0026#34;, \u0026amp;a[i]); } for(int i = 1; i \u0026lt;= n; i++){ if(vis[i]) continue; vector\u0026lt;int\u0026gt; cir; int x = i; while(!vis[x]) { cir.push_back(x); vis[x] = 1; x = a[x]; } int s = k % cir.size(); int y = 1; int w, m; extend_Euclid(s, cir.size(), w, m); if(w \u0026lt; 0) { int ww = -w; int tmp = (ww + cir.size() -1) / cir.size(); w += tmp * cir.size(); } y = w; // while(s * y % cir.size() != 1){ // y ++; // // printf(\u0026#34;%d\u0026#34;, s * y % cir.size()); // } for(int j = 0; j \u0026lt; cir.size(); j++){ ans[cir[j]] = cir[(j+y)%cir.size()]; } } for(int i = 1; i \u0026lt;= n; i++) printf(\u0026#34;%d \u0026#34;, ans[i]); puts(\u0026#34;\u0026#34;); return 0; } ","permalink":"https://Anlarry.github.io/posts/acm-icpc/nowcoder-2020-%E5%A4%9A%E6%A0%A1-%E7%AC%AC%E4%BA%8C%E5%9C%BA/","summary":"nowcoder 2020 多校 第二场 https://ac.nowcoder.com/acm/contest/5667\nA All with Pairs 题意\n给$n$个串，定义$f(s,t)$为$s$前缀和$t$后缀最长的长度，求$\\sum_i\\sum_j f(s_i, s_j)^2$\nSolution\n先把每个串的后缀hash的值存下来，对每个串$s_i$,求$\\sum_j f(s_i, s_j)^2$。对于$s_i$的每个前缀都可以查询hash求出 对应多少后缀，但是有可能一对$s_i, s_j$会有多个贡献，因此要用next数组去重\nconst unsigned long long base = 131; // vector\u0026lt;string\u0026gt; str; string str[MAX]; unordered_map\u0026lt;unsigned long long, int\u0026gt; mp; int nex[MAX]; int cnt[MAX]; void get_hash(const string \u0026amp;s){ unsigned long long res = 0; unsigned long long p = 1; for(int i = s.size()-1; i \u0026gt;= 0; i--){ // unsigned long long x = s[i] - \u0026#39;a\u0026#39;+1; res += (s[i]-\u0026#39;a\u0026#39;+1) * p; p *= base; mp[res]++; } } void get_next(const string \u0026amp;t){ nex[0] = -1; int k = -1; for(int i = 1; i \u0026lt; t.","title":"nowcoder 2020 多校 第二场"},{"content":"AtCoder-Sum of gcd of Tuples (Hard) 题意 https://atcoder.jp/contests/abc162/tasks/abc162_e\n求$\\sum\\gcd(a_1,a_2,\\cdots,a_n)$,其中$a_i\\in[1,K]$\nSolution 直接计算肯定是不好计算的，可以考虑按$gcd$的值进行分类，问题就转化为一个计数问题\n$\\displaystyle \\gcd(a,b)=d\\Rightarrow\\gcd(\\frac{a}{d},\\frac{b}{d})=1$\n$\\displaystyle {\\gcd(a_1,\\cdots, a_n)=d的数量}={\\gcd(\\frac{a_1}{d},\\cdots,\\frac{a_n}{d})=1的数量}$\n那么，\n$$ Ans=\\sum_{d=1}^{K}dF(\\lfloor\\frac{K}{d}\\rfloor, N) $$\n其中$F(K,N)$表示$\\gcd(a_1,\\cdots,a_N)=1$的个数，$a_i\\in[1,K]$\n可以用容斥算出$\\displaystyle F(K,N)=K^N-\\sum_{i=1}^{K}F(\\lfloor\\frac{K}{i}\\rfloor)$\n#include \u0026lt;cstdio\u0026gt; #include \u0026lt;stack\u0026gt; #include \u0026lt;set\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;map\u0026gt; #include \u0026lt;time.h\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;memory.h\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;iomanip\u0026gt; // #include \u0026lt;unordered_map\u0026gt; #define P pair\u0026lt;int, int\u0026gt; #define LL long long #define LD long double #define PLL pair\u0026lt;LL, LL\u0026gt; #define mset(a, b) memset(a, b, sizeof(a)) #define rep(i, a, b) for (int i = a; i \u0026lt; b; i++) #define PI acos(-1.0) #define random(x) rand() % x #define debug(x) cout \u0026lt;\u0026lt; #x \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34; using namespace std; const int inf = 0x3f3f3f3f; const LL __64inf = 0x3f3f3f3f3f3f3f3f; #ifdef DEBUG const int MAX = 1e6 + 50; #else const int MAX = 1e6 + 50; #endif const int mod = 1e9 + 7; LL N,K; LL f[MAX]; LL fact[MAX]; inline LL add(LL x, LL y){ LL res = x + y; return res \u0026gt;= mod ? res - mod : res; } inline LL qpow(LL x, LL n){ LL res = 1; while (n) { if(n \u0026amp;1) res = res * x % mod; x = x * x % mod; n \u0026gt;\u0026gt;= 1; } return res; } LL F(LL K, LL N){ if(f[K]) return f[K]; LL \u0026amp;res =f[K]; if(K==1){ return res = 1; } // res = qpow(K, N); res = fact[K]; for(LL i = 2, j; i \u0026lt;= K; i=j+1){ j = K/(K/i); // res = add(res, mod-F(K/i, N)); LL tmp = (j-i+1LL) * F(K/i, N) % mod; res = add(res, mod-tmp); } return res; } int main(){ #ifdef DEBUG freopen(\u0026#34;in\u0026#34;, \u0026#34;r\u0026#34;, stdin); #endif scanf(\u0026#34;%lld%lld\u0026#34;, \u0026amp;N, \u0026amp;K); for(LL i = 1; i \u0026lt;= K; i++) fact[i] = qpow(i, N); LL ans = 0; f[1] = 1LL; for(LL k= 1; k \u0026lt;= K; k++){ F(k, N); } for(LL i = 1, j; i \u0026lt;= K; i++){ ans += f[K/i] % mod * i % mod; if(ans \u0026gt;= mod) ans -= mod; } printf(\u0026#34;%lld\\n\u0026#34;, ans); } ","permalink":"https://Anlarry.github.io/posts/acm-icpc/atcoder-sum-of-gcd-of-tuples/","summary":"AtCoder-Sum of gcd of Tuples (Hard) 题意 https://atcoder.jp/contests/abc162/tasks/abc162_e\n求$\\sum\\gcd(a_1,a_2,\\cdots,a_n)$,其中$a_i\\in[1,K]$\nSolution 直接计算肯定是不好计算的，可以考虑按$gcd$的值进行分类，问题就转化为一个计数问题\n$\\displaystyle \\gcd(a,b)=d\\Rightarrow\\gcd(\\frac{a}{d},\\frac{b}{d})=1$\n$\\displaystyle {\\gcd(a_1,\\cdots, a_n)=d的数量}={\\gcd(\\frac{a_1}{d},\\cdots,\\frac{a_n}{d})=1的数量}$\n那么，\n$$ Ans=\\sum_{d=1}^{K}dF(\\lfloor\\frac{K}{d}\\rfloor, N) $$\n其中$F(K,N)$表示$\\gcd(a_1,\\cdots,a_N)=1$的个数，$a_i\\in[1,K]$\n可以用容斥算出$\\displaystyle F(K,N)=K^N-\\sum_{i=1}^{K}F(\\lfloor\\frac{K}{i}\\rfloor)$\n#include \u0026lt;cstdio\u0026gt; #include \u0026lt;stack\u0026gt; #include \u0026lt;set\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;map\u0026gt; #include \u0026lt;time.h\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;memory.h\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;iomanip\u0026gt; // #include \u0026lt;unordered_map\u0026gt; #define P pair\u0026lt;int, int\u0026gt; #define LL long long #define LD long double #define PLL pair\u0026lt;LL, LL\u0026gt; #define mset(a, b) memset(a, b, sizeof(a)) #define rep(i, a, b) for (int i = a; i \u0026lt; b; i++) #define PI acos(-1.","title":"AtCoder-Sum of gcd of Tuples"},{"content":"arch lab Download archlab-handout\n安装模拟器 解决undefined reference to ’matherr‘\n参考 Y86-64模拟器的安装与出现对\u0026rsquo;matherr\u0026rsquo;未定义引用问题的解决\nPart A 在这部分要在sim/misc中完成，我们要编写和模拟三个Y86-64程序\nsum.ys： 遍历链表求和\n# begin at 0 .pos 0 irmovq stack,%rsp call main halt .align 8 ele1: .quad 0x00a .quad ele2 ele2: .quad 0x0b0 .quad ele3 ele3: .quad 0xc00 .quad 0 main: irmovq ele1,%rdi call rsum ret rsum: xorq %rax,%rax andq %rdi,%rdi je L1 pushq %rbx mrmovq (%rdi),%rbx mrmovq 8(%rdi),%rdi call rsum addq %rbx,%rax popq %rbx L1: ret .pos 0x200 stack: 用YAS编译后，再用YIS运行\nlinux\u0026gt; make *.yo inux\u0026gt; ../misc/yis *.yo rsum.ys: 用递归的方式求和\n# begin at 0 .pos 0 irmovq stack,%rsp call main halt .align 8 ele1: .quad 0x00a .quad ele2 ele2: .quad 0x0b0 .quad ele3 ele3: .quad 0xc00 .quad 0 main: irmovq ele1,%rdi call rsum ret rsum: xorq %rax,%rax andq %rdi,%rdi je L1 pushq %rbx mrmovq (%rdi),%rbx mrmovq 8(%rdi),%rdi call rsum addq %rbx,%rax popq %rbx L1: ret .pos 0x200 stack: copy.ys: 将src复制到dst\n# begin at 0 .pos 0 irmovq stack,%rsp call main halt .align 8 src: .quad 0x00a .quad 0x0b0 .quad 0xc00 # Destination block dest: .quad 0x111 .quad 0x222 .quad 0x333 main: irmovq src,%rdi irmovq dest,%rsi irmovq $3,%rdx call copy_block ret copy_block: xorq %rax, %rax irmovq $1,%r14 irmovq $8,%r13 pushq %rbx andq %rdx,%rdx jmp test loop: mrmovq (%rdi),%rbx addq %r13,%rdi rmmovq %rbx,(%rsi) addq %r13,%rsi xorq %rbx,%rax subq %r14,%rdx test: jne loop popq %rbx ret .pos 0x200 stack: Part B 这部分在sim/seq完成，我们需要修改seq-full.hcl， 给SEQ添加iaddq指令\nseq-full.hcl\n然后根据文档测试\n./ssim -t ../y86-code/asumi.yo (cd ../y86-code; make testssim) (cd ../ptest; make SIM=../seq/ssim) (cd ../ptest; make SIM=../seq/ssim TFLAGS=-i) 测试均成功\nPart C 这部分要在sim/pipe中完成\n我们的目的是优化ncopy，然他更快完成，会根据CPE给出一个分数\nStep1\n添加iaddq（类似于PartB），然后测试\nunix\u0026gt; make psim VERSION=full unix\u0026gt; ./psim -t sdriver.yo unix\u0026gt; ./psim -t ldriver.yo unix\u0026gt; ./correctness.pl unix\u0026gt; ./benchmark.pl 然而竟然还是0.0/60.0，此时CPE大概可以达到11左右，可是从10.5才开始记分\nStep2\n考虑循环展开，将循环展开8次，分数大概可以提高到40多\n循环展开后，就可以改变指令执行的顺序，避免数据冒险\nmrmovq (%rdi),%r8 rmmovq %r8,(%rsi) 这样会有一个气泡，如果先把8个数据都放到寄存器，在放到目标地址就可以消除气泡，降低执行的周期数\nStep3\n然而还有剩下的余数没有处理，可以考虑将剩下的余数再循环展开一次，此时已经有50多分了\nStep4\n将循环展开的次数提高到10次，那么性能会提高一点，但不是很明显\n优化余数的处理方法，最终可以将分数提高到56.1,平均CPE=7.69, ncopy length= 847 bytes\n应该还可以优化pipe-full.hcl，ncopy.ys因该也还有提高的空间，以后在补上。。。\nncopy.ys\nncopy: xorq %rax,%rax\t# count = 0 iaddq $-10,%rdx # jl L2\t# if so, goto Done: ## if so, goto Loop Loop:\tmrmovq (%rdi), %r8 mrmovq 0x8(%rdi), %r9 mrmovq 0x10(%rdi), %r10 mrmovq 0x18(%rdi), %r11 mrmovq 0x20(%rdi), %r12 mrmovq 0x28(%rdi), %r13 mrmovq 0x30(%rdi), %r14 mrmovq 0x38(%rdi), %rcx mrmovq 0x40(%rdi), %rbx mrmovq 0x48(%rdi), %rbp andq %r8,%r8 rmmovq %r8, (%rsi) rmmovq %r9, 8(%rsi) rmmovq %rbx, 0x40(%rsi) rmmovq %rbp, 0x48(%rsi) jle L1_2 iaddq $1, %rax L1_2: andq %r9,%r9 jle L1_3 iaddq $1, %rax L1_3: andq %r10,%r10 rmmovq %r10, 0x10(%rsi) rmmovq %r11, 0x18(%rsi) jle L1_4 iaddq $1, %rax L1_4: andq %r11,%r11 jle L1_5 iaddq $1, %rax L1_5: andq %r12,%r12 rmmovq %r12, 0x20(%rsi) rmmovq %r13, 0x28(%rsi) jle L1_6 iaddq $1, %rax L1_6: andq %r13,%r13 jle L1_7 iaddq $1, %rax L1_7: andq %r14,%r14 rmmovq %r14, 0x30(%rsi) rmmovq %rcx, 0x38(%rsi) jle L1_8 iaddq $1, %rax L1_8: andq %rcx,%rcx jle L1_9 iaddq $1, %rax L1_9: andq %rbx, %rbx jle L1_10 iaddq $1, %rax L1_10: andq %rbp, %rbp jle L1_11 iaddq $1, %rax L1_11: iaddq $0x50, %rdi iaddq $0x50, %rsi iaddq $-10, %rdx jge Loop L2: iaddq $9, %rdx jg Loop2 jl L2_Done mrmovq (%rdi),%r8 rmmovq %r8, (%rsi) andq %r8, %r8 jle Done iaddq $1, %rax L2_Done: ret Loop2: mrmovq (%rdi), %r8 mrmovq 8(%rdi), %r9 iaddq $-2, %rdx jg L2_0 je D3 # last 3 rmmovq %r8, (%rsi) rmmovq %r9, 8(%rsi) andq %r8,%r8 jle D2_1 iaddq $1, %rax D2_1: andq %r9, %r9 jle Done iaddq $1, %rax ret D3: mrmovq 0x10(%rdi), %r10 rmmovq %r8, (%rsi) rmmovq %r9, 8(%rsi) rmmovq %r10, 0x10(%rsi) andq %r8, %r8 jle D3_1 iaddq $1, %rax D3_1: andq %r9, %r9 jle D3_2 iaddq $1, %rax D3_2: andq %r10, %r10 jle Done iaddq $1, %rax ret L2_0: rmmovq %r8, (%rsi) rmmovq %r9, 8(%rsi) andq %r8,%r8 jle L2_1 iaddq $1, %rax L2_1: andq %r9, %r9 jle L2_2 iaddq $1, %rax L2_2: iaddq $0x10, %rdi iaddq $0x10, %rsi jmp Loop2 Done: ret End: Step5 待更\n。。。\n","permalink":"https://Anlarry.github.io/posts/csapp/csapp-arch-lab/","summary":"arch lab Download archlab-handout\n安装模拟器 解决undefined reference to ’matherr‘\n参考 Y86-64模拟器的安装与出现对\u0026rsquo;matherr\u0026rsquo;未定义引用问题的解决\nPart A 在这部分要在sim/misc中完成，我们要编写和模拟三个Y86-64程序\nsum.ys： 遍历链表求和\n# begin at 0 .pos 0 irmovq stack,%rsp call main halt .align 8 ele1: .quad 0x00a .quad ele2 ele2: .quad 0x0b0 .quad ele3 ele3: .quad 0xc00 .quad 0 main: irmovq ele1,%rdi call rsum ret rsum: xorq %rax,%rax andq %rdi,%rdi je L1 pushq %rbx mrmovq (%rdi),%rbx mrmovq 8(%rdi),%rdi call rsum addq %rbx,%rax popq %rbx L1: ret .","title":"CSAPP arch lab"},{"content":"Prime Distance On Tree 题意 Prime Distance On Tree\n给个树，从树上随机选取一对点$u,v$,求$\\delta(u,v)$是素数的概率\nSolution 可以从生成函数的角度考虑\n假设rt是一个树的树根，而且rt的深度是d，将树中节点的深度统计出来，记为$f_{rt，d}$，如果$u,v\u0026hellip;$是rt的子节点，那么rt对答案的贡献就是生成函数中素数项的系数，那么问题就是怎么计算生成函数了\n$$ \\sum_{u,v \\in son(rt)} f_{u,1} * f_{v, 1} $$\n这个式子中的素数项系数和与下式是相等的,计算$f$是很简单的\n$$ \\Big(f_{rt,0}^2 - \\sum_{u \\in son(rt) }f_{u,1}^2\\Big) / 2 $$\n为了确保复杂度不会太高，需要用点分治\n#include \u0026lt;cstdio\u0026gt; #include \u0026lt;stack\u0026gt; #include \u0026lt;set\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;map\u0026gt; #include \u0026lt;time.h\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;memory.h\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;iomanip\u0026gt; // #include \u0026lt;unordered_map\u0026gt; #define P pair\u0026lt;int, int\u0026gt; #define LL long long #define LD long double #define PLL pair\u0026lt;LL, LL\u0026gt; #define mset(a, b) memset(a, b, sizeof(a)) #define rep(i, a, b) for (int i = a; i \u0026lt; b; i++) #define PI acos(-1.0) #define random(x) rand() % x #define debug(x) cout \u0026lt;\u0026lt; #x \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34; using namespace std; const int inf = 0x3f3f3f3f; const LL __64inf = 0x3f3f3f3f3f3f3f3f; #ifdef DEBUG const int MAX = 2e3 + 50; #else const int MAX = 1e5 + 50; #endif const int mod = 1e9 + 7; #include \u0026lt;complex\u0026gt; namespace Prime { vector\u0026lt;int\u0026gt; prime; bool isprime[MAX\u0026lt;\u0026lt;1]; void init(int n){ mset(isprime, 1); isprime[0] = isprime[1] = 0; for(int i = 2; i \u0026lt; n; i++){ if(isprime[i]){ prime.push_back(i); } for(int j = 0; j \u0026lt; prime.size() and prime[j] * i \u0026lt; n; j++){ isprime[i * prime[j]] = 0; if(i * prime[j] == 0) break; } } } } // namespace namePrimPrime namespace FFT { complex\u0026lt;double\u0026gt; a[MAX\u0026lt;\u0026lt;2], b[MAX\u0026lt;\u0026lt;2]; int rev[MAX]; void fft(complex\u0026lt;double\u0026gt; *a, int n, int inv){ int bit = 0; while((1\u0026lt;\u0026lt;bit) \u0026lt; n) bit++; for(int i = 0; i \u0026lt; n; i++){ rev[i] = (rev[i\u0026gt;\u0026gt;1]\u0026gt;\u0026gt;1) | ((i \u0026amp; 1) \u0026lt;\u0026lt; (bit-1)); if(i \u0026lt; rev[i]) swap(a[i], a[rev[i]]); } for(int mid = 1; mid \u0026lt; n; mid \u0026lt;\u0026lt;= 1){ complex\u0026lt;double\u0026gt; wn(cos(PI/mid), inv*sin(PI/mid)); for(int i = 0; i \u0026lt; n; i += (mid\u0026lt;\u0026lt;1)){ complex\u0026lt;double\u0026gt; w(1, 0); for(int j = 0; j \u0026lt; mid; j++, w *= wn){ complex\u0026lt;double\u0026gt; u = a[i+j], t = w * a[i+j+mid]; a[i+j] = u + t, a[i+j+mid] = u - t; } } } } void product(int n){ fft(a, n, 1); fft(b, n, 1); for(int i = 0; i \u0026lt;= n; i++) a[i] *= b[i]; fft(a, n, -1); } } // namespace nameFFTFFT vector\u0026lt;int\u0026gt; E[MAX]; bool vis[MAX]; // LL dep[MAX]; LL dep[MAX], dep_num[MAX]; int cnt; int siz[MAX]; int dfsG(int u, int p, int\u0026amp; Min, int \u0026amp;rt, int n){ siz[u] = 1; int Max = -1; for(int i = 0; i \u0026lt; E[u].size(); i++){ int v = E[u][i]; if(vis[v] or v == p) continue; siz[u] += dfsG(v, u, Min, rt, n); Max = max(Max, siz[v]); } Max = max(Max, n - siz[u]); if(Max \u0026lt; Min){ Min = Max, rt = u; } return siz[u]; } int dfsN(int u, int p){ int res = 1; for(int i = 0; i \u0026lt; E[u].size(); i++){ int v = E[u][i]; if(vis[v] or v == p) continue; res += dfsN(v, u); } return res; } int find_rt(int u){ int Min = inf; int rt = -1; int n = dfsN(u, -1); dfsG(u, -1, Min, rt, n); return rt; } LL dfs(int u, int p, int d){ // return max_dep dep[cnt++] = d; LL max_dep = d; for(int i = 0; i \u0026lt; E[u].size(); i++){ int v = E[u][i]; if(v == p or vis[v]) continue; max_dep = max(max_dep, dfs(v, u, d+1)); } return max_dep; } LL calcu(int u, int d){ // mset(dep, 0); cnt = 0; dfs(u, -1, d); LL Max = 0; for(int i = 0; i \u0026lt; cnt; i++){ dep_num[dep[i]]++; Max = max(Max, dep[i]); } LL res = 0; int N = 1; while(N \u0026lt;= Max * 2) N \u0026lt;\u0026lt;= 1; for(int i = 0; i \u0026lt; N; i++){ if(i \u0026lt;= Max) FFT::a[i] = FFT::b[i] = complex\u0026lt;double\u0026gt;(dep_num[i], 0); else FFT::a[i] = FFT::b[i] = complex\u0026lt;double\u0026gt;(0, 0); } FFT::product(N); for(int i = 0; i \u0026lt; Prime::prime.size() and Prime::prime[i] \u0026lt;= 2*Max; i++){ res += (LL)(FFT::a[Prime::prime[i]].real() / N + 0.5); } for(int i = 0; i \u0026lt; cnt; i++) dep_num[dep[i]]--; return res; } LL solve(int u){ // vis[u] = 1; int rt = find_rt(u); vis[rt] = 1; LL res = calcu(rt, 0); for(int i = 0; i \u0026lt; E[rt].size(); i++){ if(vis[E[rt][i]]) continue; res -= calcu(E[rt][i], 1); res += solve(E[rt][i]); } // for(int i = 0; i \u0026lt; E[rt].size(); i++){ // if(vis[E[rt][i]]) continue; // res += solve(E[rt][i]); // } return res; } int main(){ #ifdef DEBUG freopen(\u0026#34;in\u0026#34;, \u0026#34;r\u0026#34;, stdin); #endif int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); Prime::init(MAX \u0026lt;\u0026lt; 1); for(int i = 1; i \u0026lt; n; i++){ int u, v; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;u, \u0026amp;v); E[u].push_back(v); E[v].push_back(u); } LL up = solve(1); LL down = (LL)n * (n-1); printf(\u0026#34;%.7lf\\n\u0026#34;, 1.0 * up / down); return 0; } ","permalink":"https://Anlarry.github.io/posts/acm-icpc/codechef-primedst/","summary":"Prime Distance On Tree 题意 Prime Distance On Tree\n给个树，从树上随机选取一对点$u,v$,求$\\delta(u,v)$是素数的概率\nSolution 可以从生成函数的角度考虑\n假设rt是一个树的树根，而且rt的深度是d，将树中节点的深度统计出来，记为$f_{rt，d}$，如果$u,v\u0026hellip;$是rt的子节点，那么rt对答案的贡献就是生成函数中素数项的系数，那么问题就是怎么计算生成函数了\n$$ \\sum_{u,v \\in son(rt)} f_{u,1} * f_{v, 1} $$\n这个式子中的素数项系数和与下式是相等的,计算$f$是很简单的\n$$ \\Big(f_{rt,0}^2 - \\sum_{u \\in son(rt) }f_{u,1}^2\\Big) / 2 $$\n为了确保复杂度不会太高，需要用点分治\n#include \u0026lt;cstdio\u0026gt; #include \u0026lt;stack\u0026gt; #include \u0026lt;set\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;map\u0026gt; #include \u0026lt;time.h\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;memory.h\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;iomanip\u0026gt; // #include \u0026lt;unordered_map\u0026gt; #define P pair\u0026lt;int, int\u0026gt; #define LL long long #define LD long double #define PLL pair\u0026lt;LL, LL\u0026gt; #define mset(a, b) memset(a, b, sizeof(a)) #define rep(i, a, b) for (int i = a; i \u0026lt; b; i++) #define PI acos(-1.","title":"CodeChef - PRIMEDST"},{"content":"Polya计数 将波利亚计数定理整理在这里，作为一个总结和介绍，也方便以后复习\n为什么学习Polya计数定理\n通过Polya计数定理，我们可以计算等价类的数量，比如下面这个问题：\n用$m$种颜色给一个正方形染色，如果正方形可以自由转动，求染色方案数\n让我们从一些概念开始\n1 等价关系 1.1 等价关系的定义 假设$V$是一个集合，$S$是定义在$V$上的一个关系，若$S$有如下性质：\n自反性 传递性 对称性 那么， $S$就是一个等价关系\n$a$和$b$有关系$S$,可以记为$aSb$\n假设定义关系$S$，图形$a$可以旋转得到$b$ $\\Leftrightarrow$ $aSb$\n例如图中的$方块_1$和$方块_2$具有关系$S$，即他们可以通过旋转得到彼此，而$方块_1$和$方块_2$则没有关系$S$\n1.2 等价类 通过上图，可以看出来：$方块_1$和$方块_2$是同一类的，而$方块_1$和$方块_2$则是另外两类，于是可以想到集合$V$上的等价关系$S$将集合的元素划分到不同的类中，我们把它称为等价类\n而包含元素$a$的等价类则是由满足$aSb$的所有元素$b$组成的(当然也包含元素$a$),即$C(a)={b\\in V | \\ aSb}$\n仔细想一想，不难发现两个不同等价类是不相交的\n2 置换群 2.1 置换群的定义 假设$A={1,2,\\dotsc, n}$，通过置换，将$A$中的元素重新排列，得到另一个排列$a_1, a_2, \\dotsc, a_n$，可以把这个过程写成\n$$ \\left ( \\begin{matrix} 1 \u0026amp; 2 \u0026amp; \\dotsc \u0026amp; n \\newline a_1 \u0026amp; a_2 \u0026amp; \\dotsc \u0026amp; a_n \\end{matrix} \\right ) $$\n所以，可以将置换看成一个双射函数$f:{1,2,\\dotsc, n} \\rightarrow {1,2,\\dotsc, n}$\n置换之间也可进行合成运算\n$$ \\pi_1 = \\left ( \\begin{matrix} 1 \u0026amp; 2 \u0026amp; 3 \u0026amp; 4 \\newline 4 \u0026amp; 2 \u0026amp; 1 \u0026amp; 3 \\end{matrix} \\right ) \\ \\ \\pi_2 = \\left ( \\begin{matrix} 1 \u0026amp; 2 \u0026amp; 3 \u0026amp; 4 \\newline 2 \u0026amp; 1 \u0026amp; 4 \u0026amp; 3 \\end{matrix} \\right ) $$\n$$ \\pi_1 \\circ \\pi_2 =\\left ( \\begin{matrix} 1 \u0026amp; 2 \u0026amp; 3 \u0026amp; 4 \\newline 2 \u0026amp; 4 \u0026amp; 3 \u0026amp; 1 \\end{matrix} \\right ) $$ $\\pi_1 \\circ \\pi_2 (1) = \\pi_1(\\pi_2(1))=2$\n而在置换集合$X$上定义的群则称为置换群，置换群也是群也要满足群的性 质\n运算封闭 $\\pi_1 \\in X, \\pi_2 \\in X \\Rightarrow \\pi_1 \\circ \\pi_2 \\in X$ 满足结合律 有单位元，置换$I(a)=a$ 有逆元，$\\pi \\circ \\pi^{-1} = I$ 但是置换与计算不同染色模式数量有什么关系？图形的旋转等变换都可以用一个只置换来表示\n我们把1-4按顺时针放到正方形的四个方块中\n$\\pi_1=\\left(\\begin{matrix} 1 \u0026amp; 2 \u0026amp; 3 \u0026amp; 4 \\newline 1 \u0026amp; 2 \u0026amp; 3 \u0026amp; 4 \\end{matrix}\\right)$\n旋转$90^\\circ$\n$\\pi_2=\\left(\\begin{matrix} 1 \u0026amp; 2 \u0026amp; 3 \u0026amp; 4 \\newline 4 \u0026amp; 1 \u0026amp; 2 \u0026amp; 3 \\end{matrix}\\right)$\n2.2 置换群衍生的等价关系 假设$G=(X,\\circ)$，通过置换$\\pi\\in X$，元素$a$可以被置换为其他元素$\\pi(a)=b$，可以发现这里也存在一种等价关系， 可以定义等价关系$S$:\n$$ aSb \\Leftrightarrow \\exist \\pi \\in G, \\pi(a)=b $$\n$\\pi \\in G 也可以来表示 \\pi \\in X$\n而包含$a$的等价类$C(a)$是由所有满足$aSb$的元素$b$组成的，因此我们也可以说 $$ C(a)={\\pi(a) \\ | \\ \\pi \\in G} $$\n如果$A={1,2,3}$\n$\\pi_1=\\left(\\begin{matrix} 1 \u0026amp; 2 \u0026amp; 3 \\newline 1 \u0026amp; 2 \u0026amp; 3 \\end{matrix}\\right)$\n$\\pi_2=\\left(\\begin{matrix} 1 \u0026amp; 2 \u0026amp; 3 \\newline 3 \u0026amp; 2 \u0026amp; 1 \\end{matrix}\\right)$\n$X={\\pi_1, \\pi_2}$,可以验证$G={X,\\circ}$是一个置换群，${1,3}$是一个等价类，${2}$是一个等价类\n可以证明自反、对称、传递是满足的\n3 伯恩赛德引理 这个定理将给出置换群衍生出的等价关系的（不同）等价关系数量的计数方法\n3.1 伯恩赛德引理 假设$G$是一个置换群，$a$是$A$中的元素，如果$\\pi(a)=a$，则称$A$中的元素$a$在置换$\\pi$下是不变的(Invariant)，$Inv(\\pi)$表示不变元素的数量\n定理 假设$G$是一个集合$A$的置换群，设$S$是$G$上衍生出来的等价关系，那么$S$中的等价类的数量由下式给出:\n$$ \\frac{1}{|G|} \\sum_{\\pi\\in G}Inv(\\pi) $$\n$|G|$是置换群中置换的数量，让我们来用一下这个定理，假设$G$下面的置换组成\n$$ \\pi_1=\\left(\\begin{matrix} 1 \u0026amp; 2 \u0026amp; 3 \u0026amp; 4\\newline 1 \u0026amp; 2 \u0026amp; 3 \u0026amp; 4 \\end{matrix}\\right) , \\pi_2=\\left(\\begin{matrix} 1 \u0026amp; 2 \u0026amp; 3 \u0026amp; 4 \\newline 2 \u0026amp; 1 \u0026amp; 3 \u0026amp; 4 \\end{matrix}\\right) , $$\n$$ \\pi_3=\\left(\\begin{matrix} 1 \u0026amp; 2 \u0026amp; 3 \u0026amp; 4\\newline 1 \u0026amp; 2 \u0026amp; 4 \u0026amp; 3 \\end{matrix}\\right) , \\pi_4=\\left(\\begin{matrix} 1 \u0026amp; 2 \u0026amp; 3 \u0026amp; 4 \\newline 2 \u0026amp; 1 \u0026amp; 4 \u0026amp; 3 \\end{matrix}\\right) , $$\n可以看出来，有两个等价类分别是${1,2}$，${3, 4}$，等价类的数量为$2$\n可以验证$Inv(\\pi_1)=4,Inv(\\pi_2)=2,Inv(\\pi_3)=2,Inv(\\pi_4)=0$\n$$ 等价类的数量=\\frac{1}{4}(4+2+2+0)=2 $$\n3.2 伯恩赛德引理的证明 Part 1 这个证明可以跳过，对后面阅读没有什么影响\n对于$A$中的元素$a$，我们可以定义稳定算子(Stabilizer)的概念，$St(a)$是保持元素$a$不变的置换的集合，$St(a)={\\pi \\in G | \\pi(a) = a}$，\n$$ \\pi_1=\\left(\\begin{matrix} 1 \u0026amp; 2 \u0026amp; 3 \\newline 1 \u0026amp; 2 \u0026amp; 3 \\end{matrix}\\right) , \\pi_2=\\left(\\begin{matrix} 1 \u0026amp; 2 \u0026amp; 3 \\newline 2 \u0026amp; 3 \u0026amp; 1 \\end{matrix}\\right) , \\pi_3=\\left(\\begin{matrix} 1 \u0026amp; 2 \u0026amp; 3 \\newline 3 \u0026amp; 1 \u0026amp; 2 \\end{matrix}\\right) , $$ $St(2) = {\\pi_1}$，\n包含$2$的等价类$C(2)={\\pi_1(2),\\pi_2(2),\\pi_3(2)}={1, 2, 3}$\n可以发现$|St(2)| \\times |C(2)| = |G| = 3$，这不是巧合\n引理 假设$G$是一个置换群，而且$a \\in A$，那么， $$ |St(a)| \\times |C(a)| = |G| $$\n让我们来简单证明这个定理\n假设$C(a)={b_1,b_2,\\dotsb, b_r}$，那么存在一个$\\pi_1$，满足$\\pi_1(a)=b_1$，同样存在$\\pi_2(a)=b_2$,$\\dotsb$,设$P={\\pi_1, \\pi_2, \\dotsc, \\pi_r}$，而且$|P|=|C(a)|$，于是转化为证明$|St(a)|\\times |P|=|G|$\n从$G$中选一个置换$\\pi$, $\\pi$一定将$a$置换成一个元素，设该元素为$b_k$，即$\\pi(a)=b_k$，\n另一个方面，$\\pi_k(a)=b_k$,因此$\\pi^{-1}_k \\circ \\pi(a)=a$，即$\\pi^{-1}_k \\circ \\pi \\in St(a)$，\n$$ \\pi_k \\circ (\\pi_k^{-1} \\circ \\pi) = \\pi $$ 这说明$G$中的元素$\\pi$可以由$St(a)$和$C(a)$中的元素合成得到\n然后我们再来说明这是唯一的\n假设$\\pi=\\pi_k\\circ \\gamma=\\pi_l \\circ \\delta$ ，$\\gamma$和$\\delta$都在$St(a)$中，因此$\\pi_k \\circ \\gamma(a)=b_k=\\pi_l \\circ \\delta (a)=b_l$，因此$l=k$，这种组合方式是唯一的，因此$|St(a)| \\times |C(a)| = |G|$\nPart 2 让我们继续证明伯恩赛德引理\n假设$A={1,2,\\dotsc,n}$, $G={\\pi_1, \\pi_2, \\dotsc, \\pi_m}$，让我们看看下面这个式子的是否成立\n$$ |Inv(\\pi_1)|+|Inv(\\pi_2)|+\\dotsb+|Inv(\\pi_m)|=|St(1)|+|St(2)|+\\dotsb+|St(n)| $$\n可以发现都计数的是满足$\\pi(a)=a$序对$\u0026lt;\\pi,a\u0026gt;$的个数，因此等式是成立的\n将等式两边同时除以|G|，左边就得到了伯恩赛德引理的型式，而右边，根据Part1中的引理可以转化为\n$$ \\frac{1}{C(1)}+\\frac{1}{C(2)}+\\dotsb+\\frac{1}{C(n)} \\ \\ \\ \\ (1) $$\n而$C(a)$是一个等价类，两个等价类的交集要么是全集要么是空集，假设$C(a)={b_1,b_2,\\dotsc, b_r}$,那么，\n$$ \\frac{1}{C(b_1)}+\\frac{1}{C(b_2)}+\\dotsb+\\frac{1}{C(b_r)}=\\frac{1}{r}+\\frac{1}{r}+\\dotsb+\\frac{1}{r}=1 $$\n于是(1)式计数的就是等价类的个数\n4 等价着色 伯恩赛德引理和计算等价着色数量有什么关系呢?其实伯恩赛德引理不能直接帮助我们计算等价着色的数量，但是我们可以适当的定义等价关系，然后再计算等价着色的数量\n假设$C(R,D)$使用$R$中的颜色，来给$D$中的元素染色的着色集合，\n假设$R$是黑色和白色，$D$是图中的节点，那么$C(R,D)$是给图中节点染色的集合 $C(R,D)={C_1,C_2,\\dotsb, C_{16}}$\n定义在$C(R,D)$上的置换$\\pi^*$，将一种着色变为另一种着色，更形式一点，假定$f$是一个着色，那么新着色$\\pi^*f$定义为$(\\pi^*f)(a)$是$f(\\pi(a))$\n同样，也可以定义$C(R,D)$上的置换群，$G^={\\pi^ \\ | \\ \\pi \\in G}$，$G$和$G^$的元素数量一样，因为$\\pi$和$\\pi^对应于一种相同旋转$。$G^$也可以衍生出等价关系$S^$，而$S^*$就是我们关注的。\n假设$f,g$是两个着色，如果有一个$\\pi \\in G$($\\pi^\\in G^$)，$\\pi^*f=g$，我们就认为$f,g$是等价的\n我们要求的$S^*$划分出来的等价类的数量\n从上图可以看出来$G^$的大小是$3$，设$G^={\\pi_1^,\\pi_2^,\\pi_3^*}$，分别对应逆时针旋转$0^\\circ,120^\\circ, 240^\\circ$\n$$ \\pi_1^*=\\left(\\begin{matrix} C_1 \u0026amp; C_2 \u0026amp; C_3 \u0026amp; C_4 \u0026amp;C_5 \u0026amp; C_6 \u0026amp;C_7 \u0026amp; C_8 \u0026amp;C_9 \u0026amp; C_{10} \u0026amp; C_{11} \u0026amp; C_{12} \u0026amp; C_{13} \u0026amp; C_{14} \u0026amp; C_{15} \u0026amp; C_{16} \\newline C_1 \u0026amp; C_2 \u0026amp; C_3 \u0026amp; C_4 \u0026amp;C_5 \u0026amp; C_6 \u0026amp;C_7 \u0026amp; C_8 \u0026amp;C_9 \u0026amp; C_{10} \u0026amp; C_{11} \u0026amp; C_{12} \u0026amp; C_{13} \u0026amp; C_{14} \u0026amp; C_{15} \u0026amp; C_{16} \\end{matrix}\\right) $$\n$$ \\pi_2^*=\\left(\\begin{matrix} C_1 \u0026amp; C_2 \u0026amp; C_3 \u0026amp; C_4 \u0026amp;C_5 \u0026amp; C_6 \u0026amp;C_7 \u0026amp; C_8 \u0026amp;C_9 \u0026amp; C_{10} \u0026amp; C_{11} \u0026amp; C_{12} \u0026amp; C_{13} \u0026amp; C_{14} \u0026amp; C_{15} \u0026amp; C_{16} \\newline C_1 \u0026amp; C_3 \u0026amp; C_4 \u0026amp; C_2 \u0026amp;C_5 \u0026amp; C_8 \u0026amp;C_6 \u0026amp; C_7 \u0026amp;C_{10} \u0026amp; C_{11} \u0026amp; C_{9} \u0026amp; C_{13} \u0026amp; C_{14} \u0026amp; C_{12} \u0026amp; C_{15} \u0026amp; C_{16} \\end{matrix}\\right) $$\n$$ \\pi_3^*=\\left(\\begin{matrix} C_1 \u0026amp; C_2 \u0026amp; C_3 \u0026amp; C_4 \u0026amp;C_5 \u0026amp; C_6 \u0026amp;C_7 \u0026amp; C_8 \u0026amp;C_9 \u0026amp; C_{10} \u0026amp; C_{11} \u0026amp; C_{12} \u0026amp; C_{13} \u0026amp; C_{14} \u0026amp; C_{15} \u0026amp; C_{16} \\newline C_1 \u0026amp; C_4 \u0026amp; C_2 \u0026amp; C_3 \u0026amp;C_5 \u0026amp; C_7 \u0026amp;C_8 \u0026amp; C_6 \u0026amp;C_{11} \u0026amp; C_{9} \u0026amp; C_{10} \u0026amp; C_{14} \u0026amp; C_{12} \u0026amp; C_{13} \u0026amp; C_{15} \u0026amp; C_{16} \\end{matrix}\\right) $$\n$Inv(\\pi_1^)=16,Inv(\\pi_2^)=4,Inv(\\pi_2^*)=4$\n根据伯恩赛德引理，\n$$ 等价着色的个数=\\frac{1}{3}(16+4+4)=8 $$ 可以从上图中验证这个结果的正确性，为了与$S$中的等价类区分，我们称$S^*$中等价类为模式\n通过枚举$C(R,D)$中的元素，再枚举$\\pi^$计算$Inv(\\pi^)$过于麻烦，可以直接计算$Inv(\\pi^)$，于是有了下面的定理*\n5 Polya定理的特殊情况 5.1 循环分解 让我们再回到置换，设置换$\\pi_1=\\left(\\begin{matrix} 1 \u0026amp; 2 \u0026amp; 3 \u0026amp; 4 \u0026amp; 5\\newline 2 \u0026amp; 3 \u0026amp; 4 \u0026amp; 5 \u0026amp; 1 \\end{matrix}\\right)$ 让我们不断地重复这个置换，那么可以找到循环节$1\\rightarrow 2 \\rightarrow 3 \\rightarrow 4 \\rightarrow 5 \\rightarrow 1$，那我们就把$\\pi$简写$(12345)$\n再比如$\\pi_2=\\left(\\begin{matrix} 1 \u0026amp; 2 \u0026amp; 3 \u0026amp; 4 \u0026amp; 5 \u0026amp; 6 \\newline 5 \u0026amp; 1 \u0026amp; 6 \u0026amp; 3 \u0026amp; 2 \u0026amp; 4 \\end{matrix}\\right)$ 可以简写成$(152)(364)$，这一过程被称为循环分解\n定义$cyc(\\pi)$是$\\pi$循环分解中循环节的数量，比如$cyc(\\pi_1)=1，cyc(\\pi_2)=2$\n5.2 Polya 计数的特殊情况 定理 假设$G$是集合$D$的置换群，且$C(R,D)$是使用$R$中颜色给$D$中元素染色的集合，$R$中颜色的数量的$m$,$C(R,D)$中不同着色数量($S^*$中等价类的数量)由下式给出：\n$$ \\frac{1}{|G|} (m^{cyc(\\pi_1)}+m^{cyc(\\pi_2)}+\\dotsb+m^{cyc(\\pi_k)}) $$ 其中$G={\\pi_1, \\pi_2, \\dotsb, \\pi_k}$\n让我们用这个定理再算一次等价着色的个数，假定将中间的点记为$1$号 $0^\\circ旋转，\\pi_1=(1)(2)(3)(4)$\n$120^\\circ， \\pi_2=(1)(234)$\n$240^\\circ， \\pi_3=(1)(234)$\n$$ 等价着色的个数=\\frac{1}{3}(2^4+2^2+2^2)=8 $$\n5.3 循环指标$P_G$ 如果可以用一个生成函数来描述一个置换群，那将很有用，这将引出更一般的波利亚计数定理，因此有了循环指标$P_G$的概念\n假设$\\pi=(1)(23)(45)(6)(789)(10)$，可以将他编码为$x_1^3x_2^2x_3$\n可以看出来编码方式，$x_i$代表长度为$i$的循环节，$x_i$的幂次$b$代表有多少个长度为$i$的循环节\n于是可以用每个置换编码的和再除以$|G|$,\n$$ P_G(x_1,x_2,\\dotsc,x_k)=\\frac{1}{G}\\sum_{\\pi\\in G} x_1^{b_1}x_2^{b_2}\\dotsb x_k^{b_k} $$ 来编码一个置换群\n对5.2的例子中的置换群进行编码，$P_G=\\frac{1}{3}(x_1^4+x_1x_3+x_1x_3)$\n而且，波利亚计数的特殊情况就是$P_G$中$x_1,x_2,\\dotsc,x_k$都取$m$的情况\n5.4 Polya计数特殊情况的证明 同样可以跳过这一部分\n将Polya计数特殊情况的公式与伯恩赛德引理对比，因此只要证明$m^{cyc(\\pi)}=Inv(\\pi^*)$\n考虑一个具体的情况，假定$\\pi=(1)(23)(456)(7)$，经过置换2，3的颜色交换，$4,5,6$将颜色给下一个，若$f$是一个着色，要让$\\pi^*(f)=f$，那么$f$在每个循环节中的染色要一致，因此一共有$m^{cyc(\\pi)}$这么多$f$\n6 Polya计数定理 为什么还有这个？\n如果要求必须要用黑色$k$次，或者至少一次黑色，上面的定理就不好用了\n6.1 给颜色加权 假设着色$f$给$D$染色，使用红色$t_1$次，绿色$t_2$次，蓝色$t_3$次\n假定红色的权值$w$为$r$,绿色$g$,蓝色$b$，\n那么着色$f$的权$W(f)=r^{t_1}g^{t_2}b^{t_3}$，而如果染色$f,g$是等价的，那么他们的权是相等的\n于是，我们也可以定义一个着色等价类(模式)的权等于不同等价类的权之和，把这个称为着色等价类（模式）的权，或者模式集合的目录，因为他概括了模式的染色方式\n我们再来考虑5.2中的例子，模式目录是\n$$ w^4+2w^3b+2w^2b^2+2wb^3+b^4 $$\n所有系数之和等于不同等价类的个数，\n如果要求用了2个白色两个黑的着色方案数，可通过$w^2b^2$前的系数得知是2种\n下面的定理将给出计算模式目录的方法\n6.2 Polya定理内容 定理 假设$G$是集合$D$上的置换群，而$C(R,D)$是用$R$中的颜色给$D$着色的集合，$w$是颜色的权值，那么$C(R,D)的着色的模式目录为$：\n$$ P_G\\bigg(\\sum_{r\\in R}w(r),\\sum_{r\\in R}w^2(r),\\dotsb,\\sum_{r\\in R}w^k(r)\\bigg) $$ 其中$P_G(x_1,x_2,\\dotsb,x_k)$是循环指标\n再回到之前的例子\n我们已经知道$P_G=\\frac{1}{3}(x_1^4+x_1x_3+x_1x_3)$\n假定我们用白，黑染色，权值分别为$w,b$\n$$ \\sum_{r\\in R}w(r)=w+b,\\sum_{r\\in R}w^3(r)=w^3+b^3 $$ 带入$P_G$ $$ \\frac{1}{3}[(w+b)^4+2(w+b)(w^3+b^3)] $$\n通过对颜色权值的简单赋值就能的要一些有用的结论\n如果想知道以用有多少种染色模式，那么只要把所有的权值都设为$1$ 如果不想用某一颜色，就把颜色设为$0$，其他颜色设为$1$ 如果想知道用某个颜色$k$次的模式数，就把其他颜色设为$1$，求改颜色权值幂次为$k$前的系数 . . . QAQ, 终于写完了。。。\n","permalink":"https://Anlarry.github.io/posts/acm-icpc/%E6%B3%A2%E9%87%8C%E4%BA%9A%E8%AE%A1%E6%95%B0/","summary":"Polya计数 将波利亚计数定理整理在这里，作为一个总结和介绍，也方便以后复习\n为什么学习Polya计数定理\n通过Polya计数定理，我们可以计算等价类的数量，比如下面这个问题：\n用$m$种颜色给一个正方形染色，如果正方形可以自由转动，求染色方案数\n让我们从一些概念开始\n1 等价关系 1.1 等价关系的定义 假设$V$是一个集合，$S$是定义在$V$上的一个关系，若$S$有如下性质：\n自反性 传递性 对称性 那么， $S$就是一个等价关系\n$a$和$b$有关系$S$,可以记为$aSb$\n假设定义关系$S$，图形$a$可以旋转得到$b$ $\\Leftrightarrow$ $aSb$\n例如图中的$方块_1$和$方块_2$具有关系$S$，即他们可以通过旋转得到彼此，而$方块_1$和$方块_2$则没有关系$S$\n1.2 等价类 通过上图，可以看出来：$方块_1$和$方块_2$是同一类的，而$方块_1$和$方块_2$则是另外两类，于是可以想到集合$V$上的等价关系$S$将集合的元素划分到不同的类中，我们把它称为等价类\n而包含元素$a$的等价类则是由满足$aSb$的所有元素$b$组成的(当然也包含元素$a$),即$C(a)={b\\in V | \\ aSb}$\n仔细想一想，不难发现两个不同等价类是不相交的\n2 置换群 2.1 置换群的定义 假设$A={1,2,\\dotsc, n}$，通过置换，将$A$中的元素重新排列，得到另一个排列$a_1, a_2, \\dotsc, a_n$，可以把这个过程写成\n$$ \\left ( \\begin{matrix} 1 \u0026amp; 2 \u0026amp; \\dotsc \u0026amp; n \\newline a_1 \u0026amp; a_2 \u0026amp; \\dotsc \u0026amp; a_n \\end{matrix} \\right ) $$\n所以，可以将置换看成一个双射函数$f:{1,2,\\dotsc, n} \\rightarrow {1,2,\\dotsc, n}$\n置换之间也可进行合成运算\n$$ \\pi_1 = \\left ( \\begin{matrix} 1 \u0026amp; 2 \u0026amp; 3 \u0026amp; 4 \\newline 4 \u0026amp; 2 \u0026amp; 1 \u0026amp; 3 \\end{matrix} \\right ) \\ \\ \\pi_2 = \\left ( \\begin{matrix} 1 \u0026amp; 2 \u0026amp; 3 \u0026amp; 4 \\newline 2 \u0026amp; 1 \u0026amp; 4 \u0026amp; 3 \\end{matrix} \\right ) $$","title":"波里亚计数"},{"content":"Rock Paper Scissors Lizard Spock 题意： Rock Paper Scissors Lizard Spock\n有五种手势，类似于石头剪刀布，有两个串$s, t$,由这五种手势组成，从某个位置开始匹配，如果$t_i$能赢$s_j$得一分，求一个$pos(0\\le pos \\le len(s)-len(t))$，使得得分最多\nSolution： 将上图记为$G$，如果$op_1$可以赢$op_2$，则$G(op_1, op_2)=1$,\n枚举可以得分的手势,假设当前手势为$op$,\n$$ \\begin{aligned} t\u0026rsquo;_i \u0026amp;=(reverse\\ t_i == op ? 1 : 0) \\newline s\u0026rsquo;_i \u0026amp;= G[op][s_i] \\end{aligned} $$\n将$t\u0026rsquo;,s\u0026rsquo;$做卷积，累加每次的结果，再遍历一遍匹配的起始位置，取最大值\n#include \u0026lt;cstdio\u0026gt; #include \u0026lt;stack\u0026gt; #include \u0026lt;set\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;map\u0026gt; #include \u0026lt;time.h\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;memory.h\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;iomanip\u0026gt; #include \u0026lt;unordered_map\u0026gt; #define P pair\u0026lt;int, int\u0026gt; #define LL long long #define LD long double #define PLL pair\u0026lt;LL, LL\u0026gt; #define mset(a, b) memset(a, b, sizeof(a)) #define rep(i, a, b) for (int i = a; i \u0026lt; b; i++) #define PI acos(-1.0) #define random(x) rand() % x #define debug(x) cout \u0026lt;\u0026lt; #x \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34; using namespace std; const int inf = 0x3f3f3f3f; const LL __64inf = 0x3f3f3f3f3f3f3f3f; #ifdef DEBUG const int MAX = 2e3 + 50; #else const int MAX = 1e6 + 50; #endif const int mod = 1e9 + 7; #include \u0026lt;complex\u0026gt; namespace FFT { int rev[MAX * 4]; int cnt[MAX * 4]; void fft(complex\u0026lt;double\u0026gt; *a, int n, int inv){ int bit = 0; while((1\u0026lt;\u0026lt;bit) \u0026lt; n) bit++; for(int i = 0; i \u0026lt; n; i++){ rev[i] = (rev[i\u0026gt;\u0026gt;1]\u0026gt;\u0026gt;1) | ((i \u0026amp; 1) \u0026lt;\u0026lt; (bit-1)); if(i \u0026lt; rev[i]) swap(a[i], a[rev[i]]); } for(int mid = 1; mid \u0026lt; n; mid \u0026lt;\u0026lt;= 1){ complex\u0026lt;double\u0026gt; wn(cos(PI/mid), inv*sin(PI/mid)); for(int i = 0; i \u0026lt; n; i += (mid\u0026lt;\u0026lt;1)){ complex\u0026lt;double\u0026gt; w(1, 0); for(int j = 0; j \u0026lt; mid; j++, w*=wn){ complex\u0026lt;double\u0026gt; u = a[i+j], t = w * a[i+j+mid]; a[i+j] = u + t, a[i+j+mid] = u-t; } } } } }; int N; char s[MAX], t[MAX], rev_t[MAX]; complex\u0026lt;double\u0026gt; a[MAX*4], b[MAX*4]; int mark[100][100]; void init(){ mark[\u0026#39;S\u0026#39;][\u0026#39;P\u0026#39;] = 1; mark[\u0026#39;P\u0026#39;][\u0026#39;R\u0026#39;] = 1; mark[\u0026#39;R\u0026#39;][\u0026#39;L\u0026#39;] = 1; mark[\u0026#39;L\u0026#39;][\u0026#39;K\u0026#39;] = 1; mark[\u0026#39;K\u0026#39;][\u0026#39;S\u0026#39;] = 1; mark[\u0026#39;S\u0026#39;][\u0026#39;L\u0026#39;] = 1; mark[\u0026#39;L\u0026#39;][\u0026#39;P\u0026#39;] = 1; mark[\u0026#39;P\u0026#39;][\u0026#39;K\u0026#39;] = 1; mark[\u0026#39;K\u0026#39;][\u0026#39;R\u0026#39;] = 1; mark[\u0026#39;R\u0026#39;][\u0026#39;S\u0026#39;] = 1; } void solve(char op, int n, int m){ for(int i = 0; i \u0026lt; n; i++) a[i] = complex\u0026lt;double\u0026gt;(mark[op][s[i]], 0); for(int i = n; i \u0026lt; N; i++) a[i] = complex\u0026lt;double\u0026gt;(0, 0); for(int i = 0; i \u0026lt; m; i++) b[i] = complex\u0026lt;double\u0026gt;(rev_t[i]==op?1:0, 0); for(int i = m; i \u0026lt; N; i++) b[i] = complex\u0026lt;double\u0026gt;(0, 0); ; FFT::fft(a, N, 1); FFT::fft(b, N, 1); for(int i = 0; i \u0026lt; N;i++) a[i] *= b[i]; FFT::fft(a, N, -1); for(int i = m-1; i \u0026lt;= n-1; i++) FFT::cnt[i] += (int)(a[i].real() / N + 0.5); return; } int main(){ #ifdef DEBUG freopen(\u0026#34;in\u0026#34;, \u0026#34;r\u0026#34;, stdin); #endif init(); scanf(\u0026#34;%s%s\u0026#34;, s, t); int n = strlen(s), m = strlen(t); N = 1; while(N \u0026lt;= n+m) N \u0026lt;\u0026lt;= 1; for(int i = 0; i \u0026lt; m; i++) rev_t[i] = t[m-i-1]; vector\u0026lt;char\u0026gt; ops({\u0026#39;R\u0026#39;,\u0026#39;P\u0026#39;, \u0026#39;S\u0026#39;, \u0026#39;K\u0026#39;, \u0026#39;L\u0026#39;}); for(auto op : ops){ solve(op, n, m); } int ans = 0; for(int i = m-1; i \u0026lt;= n-1; i++){ ans = max(ans, FFT::cnt[i]); // printf(\u0026#34;%d \u0026#34;, FFT::cnt[i]); } // puts(\u0026#34;\u0026#34;); printf(\u0026#34;%d\\n\u0026#34;, ans); return 0; } ","permalink":"https://Anlarry.github.io/posts/acm-icpc/rock-paper-scissors-lizard-spock/","summary":"Rock Paper Scissors Lizard Spock 题意： Rock Paper Scissors Lizard Spock\n有五种手势，类似于石头剪刀布，有两个串$s, t$,由这五种手势组成，从某个位置开始匹配，如果$t_i$能赢$s_j$得一分，求一个$pos(0\\le pos \\le len(s)-len(t))$，使得得分最多\nSolution： 将上图记为$G$，如果$op_1$可以赢$op_2$，则$G(op_1, op_2)=1$,\n枚举可以得分的手势,假设当前手势为$op$,\n$$ \\begin{aligned} t\u0026rsquo;_i \u0026amp;=(reverse\\ t_i == op ? 1 : 0) \\newline s\u0026rsquo;_i \u0026amp;= G[op][s_i] \\end{aligned} $$\n将$t\u0026rsquo;,s\u0026rsquo;$做卷积，累加每次的结果，再遍历一遍匹配的起始位置，取最大值\n#include \u0026lt;cstdio\u0026gt; #include \u0026lt;stack\u0026gt; #include \u0026lt;set\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;map\u0026gt; #include \u0026lt;time.h\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;memory.h\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;iomanip\u0026gt; #include \u0026lt;unordered_map\u0026gt; #define P pair\u0026lt;int, int\u0026gt; #define LL long long #define LD long double #define PLL pair\u0026lt;LL, LL\u0026gt; #define mset(a, b) memset(a, b, sizeof(a)) #define rep(i, a, b) for (int i = a; i \u0026lt; b; i++) #define PI acos(-1.","title":"Rock Paper Scissors Lizard Spock"},{"content":"URAL - 1996 题意： URAL - 1996 给两个长度分别为$n, m$的字节串$A,B$，$A$串的最后一位可以修改，代价为$1$，求使得$B$串为$A$串字串的最小代价\nSolution : 因为$A$串只有最后最后一位可以修改，所以可以用KMP求出可能匹配的位置，然后计算每个位置的$cost$\n记$A$串最后一位构成的串为$a$， $B$串的为$b$, 假设$pos(0\\le pos \\le n-m)是可能匹配的位置$，如果将$b$反转得到$b\u0026rsquo;$, 在此处的的代价为\n$$ \\sum_{i+j=pos+m-1} [a_i \\ne b\u0026rsquo;_j ] $$\n而\n$$ \\sum_{i+j=posm-1} a_j * b\u0026rsquo;_j $$\n可以算出来相等的$1$的个数$cnt_1$，再将$a,b$串取反，再做一次卷积就可以算出$0$相等的个数$cnt_2$，$ans=m-cnt_1-cnt_2$\n#include \u0026lt;cstdio\u0026gt; #include \u0026lt;stack\u0026gt; #include \u0026lt;set\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;map\u0026gt; #include \u0026lt;time.h\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;memory.h\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;iomanip\u0026gt; #include \u0026lt;unordered_map\u0026gt; #define P pair\u0026lt;int, int\u0026gt; #define LL long long #define LD long double #define PLL pair\u0026lt;LL, LL\u0026gt; #define mset(a, b) memset(a, b, sizeof(a)) #define rep(i, a, b) for (int i = a; i \u0026lt; b; i++) #define PI acos(-1.0) #define random(x) rand() % x #define debug(x) cout \u0026lt;\u0026lt; #x \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34; using namespace std; const int inf = 0x3f3f3f3f; const LL __64inf = 0x3f3f3f3f3f3f3f3f; #ifdef DEBUG const int MAX = 2e3 + 50; #else const int MAX = 1e6 + 50; #endif const int mod = 1e9 + 7; #include \u0026lt;complex\u0026gt; namespace FFT { int rev[MAX]; int cnt[MAX]; void fft(complex\u0026lt;double\u0026gt; *a, int n, int inv){ int bit = 0; while((1 \u0026lt;\u0026lt; bit) \u0026lt; n) bit++; for(int i = 0; i \u0026lt; n; i++){ rev[i] = (rev[i\u0026gt;\u0026gt;1]\u0026gt;\u0026gt;1) | ((i \u0026amp; 1) \u0026lt;\u0026lt; (bit-1)); if(i \u0026lt; rev[i]) swap(a[i], a[rev[i]]); } for(int mid = 1; mid \u0026lt; n; mid \u0026lt;\u0026lt;= 1){ complex\u0026lt;double\u0026gt; wn(cos(PI/mid), inv*sin(PI/mid)); for(int i = 0; i \u0026lt; n; i += (mid\u0026lt;\u0026lt;1)){ complex\u0026lt;double\u0026gt; w(1, 0); for(int j = 0; j \u0026lt; mid; j++, w *= wn){ complex\u0026lt;double\u0026gt; u = a[i+j], t = w * a[i+j+mid]; a[i+j] = u+t, a[i+j+mid] = u-t; } } } } void work(complex\u0026lt;double\u0026gt; *ss, complex\u0026lt;double\u0026gt; *rev_t, int N, int n, int m){ FFT::fft(ss, N, 1); FFT::fft(rev_t, N, 1); for(int i = 0; i \u0026lt;= N; i++) { ss[i] *= rev_t[i]; } FFT::fft(ss, N, -1); for(int i = 0; i \u0026lt;= n-m; i++){ cnt[i] += (int)(ss[i+m-1].real() / N + 0.5); } } }; complex\u0026lt;double\u0026gt; a[MAX],b[MAX]; int x[MAX], y[MAX]; int s[MAX], t[MAX]; complex\u0026lt;double\u0026gt; ss[MAX], rev_t[MAX]; char ch[10]; void input(int *x, int *s, int n){ for(int i = 0; i \u0026lt; n; i++){ scanf(\u0026#34;%s\u0026#34;, ch); for(int j = 0; j \u0026lt; 6; j++) if(ch[j] == \u0026#39;1\u0026#39;) x[i] += 1 \u0026lt;\u0026lt; j; s[i] = (ch[7] == \u0026#39;1\u0026#39;); } } struct KMP { int next[MAX]; vector\u0026lt;int\u0026gt; pos; void init(int *x, int n){ next[0] = -1; int k = -1; for(int i = 1; i \u0026lt; n; i++){ while(k \u0026gt; -1 and x[k+1] != x[i]) k = next[k]; if(x[k+1] == x[i]) k++; next[i] = k; } } void work(int *x, int n, int *y, int m){ int k = -1; init(x, n); for(int i =0; i \u0026lt; m; i++){ while(k \u0026gt; -1 and x[k+1] != y[i]) k = next[k]; if(x[k+1] == y[i]) k++; if(k == n-1) { pos.push_back(i-n+1); k = next[k]; } } } }kmp; int main(){ #ifdef DEBUG freopen(\u0026#34;in\u0026#34;, \u0026#34;r\u0026#34;, stdin); #endif int n, m; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;m); input(x,s,n); input(y, t, m); kmp.init(y, m); kmp.work(y, m, x, n); if(kmp.pos.empty()){ puts(\u0026#34;No\u0026#34;); return 0; } int N = 1; while(N \u0026lt;= n+m) N\u0026lt;\u0026lt;=1; for(int i = 0; i \u0026lt; n; i++) ss[i] = complex\u0026lt;double\u0026gt;(s[i], 0); for(int i = 0; i \u0026lt; m; i++) rev_t[i] = complex\u0026lt;double\u0026gt;(t[m-1-i], 0); FFT::work(ss, rev_t, N, n, m); for(int i = 0; i \u0026lt; n; i++) s[i] ^= 1; for(int i = 0; i \u0026lt; m; i++) t[i] ^= 1; for(int i = 0; i \u0026lt; n; i++) ss[i] = complex\u0026lt;double\u0026gt;(s[i], 0); for(int i = n; i \u0026lt; N; i++) ss[i] = complex\u0026lt;double\u0026gt;(0, 0); for(int i = 0; i \u0026lt; m; i++) rev_t[i] = complex\u0026lt;double\u0026gt;(t[m-i-1], 0); for(int i = m; i \u0026lt; N; i++) rev_t[i] = complex\u0026lt;double\u0026gt;(0, 0); FFT::work(ss, rev_t, N, n, m); int res = inf, id = -1; for(int i = 0; i \u0026lt; kmp.pos.size(); i++){ int pos = kmp.pos[i]; // pos += m-1; int cost = m - FFT::cnt[pos]; if(cost \u0026lt; res){ res = cost, id = kmp.pos[i]; } } puts(\u0026#34;Yes\u0026#34;); printf(\u0026#34;%d %d\\n\u0026#34;, res, id+1); return 0; } ","permalink":"https://Anlarry.github.io/posts/acm-icpc/ural-1996/","summary":"URAL - 1996 题意： URAL - 1996 给两个长度分别为$n, m$的字节串$A,B$，$A$串的最后一位可以修改，代价为$1$，求使得$B$串为$A$串字串的最小代价\nSolution : 因为$A$串只有最后最后一位可以修改，所以可以用KMP求出可能匹配的位置，然后计算每个位置的$cost$\n记$A$串最后一位构成的串为$a$， $B$串的为$b$, 假设$pos(0\\le pos \\le n-m)是可能匹配的位置$，如果将$b$反转得到$b\u0026rsquo;$, 在此处的的代价为\n$$ \\sum_{i+j=pos+m-1} [a_i \\ne b\u0026rsquo;_j ] $$\n而\n$$ \\sum_{i+j=posm-1} a_j * b\u0026rsquo;_j $$\n可以算出来相等的$1$的个数$cnt_1$，再将$a,b$串取反，再做一次卷积就可以算出$0$相等的个数$cnt_2$，$ans=m-cnt_1-cnt_2$\n#include \u0026lt;cstdio\u0026gt; #include \u0026lt;stack\u0026gt; #include \u0026lt;set\u0026gt; #include \u0026lt;cmath\u0026gt; #include \u0026lt;map\u0026gt; #include \u0026lt;time.h\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;memory.h\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;iomanip\u0026gt; #include \u0026lt;unordered_map\u0026gt; #define P pair\u0026lt;int, int\u0026gt; #define LL long long #define LD long double #define PLL pair\u0026lt;LL, LL\u0026gt; #define mset(a, b) memset(a, b, sizeof(a)) #define rep(i, a, b) for (int i = a; i \u0026lt; b; i++) #define PI acos(-1.","title":"URAL - 1996"},{"content":" Fabula means story, which is a topic in A brief history of humankind\n简史三部曲 A brief history of humankind Homo Deus：A Brief History of Tomorrow 21 Lessons for the 21st Century 从史前到未来，再回到21世纪的旅行，有各种各样的意义之网。\nTo Kill a Mocking Bird “依然是夏天，孩子们走近了。男孩身后拖着根鱼竿踯躅不前。一个男人双手叉腰站在那里等他。夏天，他的孩子们在前院和朋友玩耍，自编自演着他们古怪的小话剧。\n秋天，他的孩子们在杜博斯太太房前的人行道上打架。男孩扶着他妹妹站起来，过后他们一起走回家去。秋天，他的孩子们小跑着来回经过那个街角，每天的苦恼和得意都写在脸上。他们在橡树前停下了，表情又欣喜又困惑，还带着忧虑。\n冬天，他的孩子们在院门前哆嗦着，黑色的剪影衬着熊熊燃烧的房屋。冬天，那男人走上街头，扔下眼镜，射死了一只疯狗。\n夏天，他眼看着他的孩子们心碎了。又到了秋天，怪人的孩子们需要他了。”\n进化心理学 从人类进化以适应生存问题的角度解释人类的行为。\n饮食的思迷 以摄入的能量等指标来衡量也可能并不合理，即使是相同的东西在不同人身上也会有不同的效果。我们不得不考虑微生物在这一过程中的 影响。虽然很多东西还不能得以解释，但总之多样性应该是对的。\n","permalink":"https://Anlarry.github.io/book-reading/2022-fabula/","summary":"Fabula means story, which is a topic in A brief history of humankind\n简史三部曲 A brief history of humankind Homo Deus：A Brief History of Tomorrow 21 Lessons for the 21st Century 从史前到未来，再回到21世纪的旅行，有各种各样的意义之网。\nTo Kill a Mocking Bird “依然是夏天，孩子们走近了。男孩身后拖着根鱼竿踯躅不前。一个男人双手叉腰站在那里等他。夏天，他的孩子们在前院和朋友玩耍，自编自演着他们古怪的小话剧。\n秋天，他的孩子们在杜博斯太太房前的人行道上打架。男孩扶着他妹妹站起来，过后他们一起走回家去。秋天，他的孩子们小跑着来回经过那个街角，每天的苦恼和得意都写在脸上。他们在橡树前停下了，表情又欣喜又困惑，还带着忧虑。\n冬天，他的孩子们在院门前哆嗦着，黑色的剪影衬着熊熊燃烧的房屋。冬天，那男人走上街头，扔下眼镜，射死了一只疯狗。\n夏天，他眼看着他的孩子们心碎了。又到了秋天，怪人的孩子们需要他了。”\n进化心理学 从人类进化以适应生存问题的角度解释人类的行为。\n饮食的思迷 以摄入的能量等指标来衡量也可能并不合理，即使是相同的东西在不同人身上也会有不同的效果。我们不得不考虑微生物在这一过程中的 影响。虽然很多东西还不能得以解释，但总之多样性应该是对的。","title":"2022-Fabula"},{"content":" Primus liber means the first book in latin, and means first commit here in some way.\n2021 Project Hail Mary\n讲述Grace和外星人Rocky一起“用魔法对抗魔法”（Astrophag和Taumoeba）的星际旅行故事，Save Earth \u0026amp; Save Erid。\nRich Dad, Poor Dad\n从一个与众不同的思路，讲述理财的重要性，从不同的角度再思考这个问题。\n","permalink":"https://Anlarry.github.io/book-reading/2021-primusliber/","summary":"Primus liber means the first book in latin, and means first commit here in some way.\n2021 Project Hail Mary\n讲述Grace和外星人Rocky一起“用魔法对抗魔法”（Astrophag和Taumoeba）的星际旅行故事，Save Earth \u0026amp; Save Erid。\nRich Dad, Poor Dad\n从一个与众不同的思路，讲述理财的重要性，从不同的角度再思考这个问题。","title":"2021-PrimusLiber"},{"content":"Friends 🐳 Wang Shuai, and his Github.\n🐳 SHEN Haiyang, and his Github.\n🐳 Peng Guanwen, and his Github.\n🐳 Yiming Chen, and his Github.\n🐳 Tao Wu, and his Github.\n🐳 yuanya, and his Github.\n","permalink":"https://Anlarry.github.io/links/","summary":"Friends 🐳 Wang Shuai, and his Github.\n🐳 SHEN Haiyang, and his Github.\n🐳 Peng Guanwen, and his Github.\n🐳 Yiming Chen, and his Github.\n🐳 Tao Wu, and his Github.\n🐳 yuanya, and his Github.","title":"Links"}]