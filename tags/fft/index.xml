<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>FFT on Hi-^_^</title>
    <link>https://Anlarry.github.io/tags/fft/</link>
    <description>Recent content in FFT on Hi-^_^</description>
    <generator>Hugo -- gohugo.io</generator>
    <copyright>Jiali Wang</copyright>
    <lastBuildDate>Sun, 01 Mar 2020 12:09:00 +0800</lastBuildDate><atom:link href="https://Anlarry.github.io/tags/fft/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>CodeChef - PRIMEDST</title>
      <link>https://Anlarry.github.io/posts/acm-icpc/codechef-primedst/</link>
      <pubDate>Sun, 01 Mar 2020 12:09:00 +0800</pubDate>
      
      <guid>https://Anlarry.github.io/posts/acm-icpc/codechef-primedst/</guid>
      <description>Prime Distance On Tree 题意  Prime Distance On Tree
 给个树，从树上随机选取一对点$u,v$,求$\delta(u,v)$是素数的概率
Solution 可以从生成函数的角度考虑
假设rt是一个树的树根，而且rt的深度是d，将树中节点的深度统计出来，记为$f_{rt，d}$，如果$u,v&amp;hellip;$是rt的子节点，那么rt对答案的贡献就是生成函数中素数项的系数，那么问题就是怎么计算生成函数了
$$ \sum_{u,v \in son(rt)} f_{u,1} * f_{v, 1} $$
这个式子中的素数项系数和与下式是相等的,计算$f$是很简单的
$$ \Big(f_{rt,0}^2 - \sum_{u \in son(rt) }f_{u,1}^2\Big) / 2 $$
为了确保复杂度不会太高，需要用点分治
#include &amp;lt;cstdio&amp;gt;#include &amp;lt;stack&amp;gt;#include &amp;lt;set&amp;gt;#include &amp;lt;cmath&amp;gt;#include &amp;lt;map&amp;gt;#include &amp;lt;time.h&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;string&amp;gt;#include &amp;lt;cstring&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;memory.h&amp;gt;#include &amp;lt;cstdlib&amp;gt;#include &amp;lt;queue&amp;gt;#include &amp;lt;iomanip&amp;gt;// #include &amp;lt;unordered_map&amp;gt; #define P pair&amp;lt;int, int&amp;gt; #define LL long long #define LD long double #define PLL pair&amp;lt;LL, LL&amp;gt; #define mset(a, b) memset(a, b, sizeof(a)) #define rep(i, a, b) for (int i = a; i &amp;lt; b; i++) #define PI acos(-1.</description>
    </item>
    
    <item>
      <title>Rock Paper Scissors Lizard Spock</title>
      <link>https://Anlarry.github.io/posts/acm-icpc/rock-paper-scissors-lizard-spock/</link>
      <pubDate>Tue, 11 Feb 2020 15:40:00 +0800</pubDate>
      
      <guid>https://Anlarry.github.io/posts/acm-icpc/rock-paper-scissors-lizard-spock/</guid>
      <description>Rock Paper Scissors Lizard Spock 题意：  Rock Paper Scissors Lizard Spock
  有五种手势，类似于石头剪刀布，有两个串$s, t$,由这五种手势组成，从某个位置开始匹配，如果$t_i$能赢$s_j$得一分，求一个$pos(0\le pos \le len(s)-len(t))$，使得得分最多
Solution： 将上图记为$G$，如果$op_1$可以赢$op_2$，则$G(op_1, op_2)=1$,
枚举可以得分的手势,假设当前手势为$op$,
$$ \begin{aligned} t&#39;_i &amp;amp;=(reverse\ t_i == op ? 1 : 0) \newline s&#39;_i &amp;amp;= G[op][s_i] \end{aligned} $$
将$t&#39;,s&#39;$做卷积，累加每次的结果，再遍历一遍匹配的起始位置，取最大值
#include &amp;lt;cstdio&amp;gt;#include &amp;lt;stack&amp;gt;#include &amp;lt;set&amp;gt;#include &amp;lt;cmath&amp;gt;#include &amp;lt;map&amp;gt;#include &amp;lt;time.h&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;string&amp;gt;#include &amp;lt;cstring&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;memory.h&amp;gt;#include &amp;lt;cstdlib&amp;gt;#include &amp;lt;queue&amp;gt;#include &amp;lt;iomanip&amp;gt;#include &amp;lt;unordered_map&amp;gt;#define P pair&amp;lt;int, int&amp;gt; #define LL long long #define LD long double #define PLL pair&amp;lt;LL, LL&amp;gt; #define mset(a, b) memset(a, b, sizeof(a)) #define rep(i, a, b) for (int i = a; i &amp;lt; b; i++) #define PI acos(-1.</description>
    </item>
    
    <item>
      <title>URAL - 1996</title>
      <link>https://Anlarry.github.io/posts/acm-icpc/ural-1996/</link>
      <pubDate>Tue, 11 Feb 2020 12:54:00 +0800</pubDate>
      
      <guid>https://Anlarry.github.io/posts/acm-icpc/ural-1996/</guid>
      <description>URAL - 1996 题意：  URAL - 1996 给两个长度分别为$n, m$的字节串$A,B$，$A$串的最后一位可以修改，代价为$1$，求使得$B$串为$A$串字串的最小代价
 Solution : 因为$A$串只有最后最后一位可以修改，所以可以用KMP求出可能匹配的位置，然后计算每个位置的$cost$
记$A$串最后一位构成的串为$a$， $B$串的为$b$, 假设$pos(0\le pos \le n-m)是可能匹配的位置$，如果将$b$反转得到$b&#39;$, 在此处的的代价为
$$ \sum_{i+j=pos+m-1} [a_i \ne b&#39;_j ] $$
而
$$ \sum_{i+j=posm-1} a_j * b&#39;_j $$
可以算出来相等的$1$的个数$cnt_1$，再将$a,b$串取反，再做一次卷积就可以算出$0$相等的个数$cnt_2$，$ans=m-cnt_1-cnt_2$
#include &amp;lt;cstdio&amp;gt;#include &amp;lt;stack&amp;gt;#include &amp;lt;set&amp;gt;#include &amp;lt;cmath&amp;gt;#include &amp;lt;map&amp;gt;#include &amp;lt;time.h&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;string&amp;gt;#include &amp;lt;cstring&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;memory.h&amp;gt;#include &amp;lt;cstdlib&amp;gt;#include &amp;lt;queue&amp;gt;#include &amp;lt;iomanip&amp;gt;#include &amp;lt;unordered_map&amp;gt;#define P pair&amp;lt;int, int&amp;gt; #define LL long long #define LD long double #define PLL pair&amp;lt;LL, LL&amp;gt; #define mset(a, b) memset(a, b, sizeof(a)) #define rep(i, a, b) for (int i = a; i &amp;lt; b; i++) #define PI acos(-1.</description>
    </item>
    
  </channel>
</rss>
